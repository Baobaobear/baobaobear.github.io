<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Baobaobear</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>Baobaobear</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 01 Jan 2022 00:00:00 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Baobaobear</title>
      <link>/</link>
    </image>
    
    <item>
      <title>体验copilot</title>
      <link>/post/20220110-copilot/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0800</pubDate>
      <guid>/post/20220110-copilot/</guid>
      <description>&lt;p&gt;体验了一段时间的copilot，是时候来写个简单的总结了。&lt;/p&gt;

&lt;h2 id=&#34;copilot是什么&#34;&gt;copilot是什么&lt;/h2&gt;

&lt;p&gt;copilot是一个vscode的插件。最初收到这个消息的时候，我就去申请参与内测，可能那时候已经晚了，一直等到公测才用上。它是一款自动提示插件，不过它的自动提示能力远超以前用过的，一用上，就把我惊艳到了，不是一般的函数名完成，或成员提示，而是一整段代码给你提示完成，甚至在尝试猜测你想要写的功能，直接给你补完一个函数甚至一个类。&lt;/p&gt;

&lt;p&gt;先来看几个补全效果图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/copilot/c1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上没有行号灰色部分就是自动补全的部分，你给出函数名，它就猜出你应该要的代码的效果，那以下来一个更复杂点的排序，当然也是没有问题的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/copilot/c2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不止如此，你只要写上接下来的函数的注释，有一些它也能直接给你补完这个函数的实现，你的注释还能帮助它提供更准确的信息。所以这又一次说明注释的作用，不但是给人看的，不但是用来生成自动化文档的，甚至是用来自动生成代码的。&lt;/p&gt;

&lt;h2 id=&#34;对刷题的作用&#34;&gt;对刷题的作用&lt;/h2&gt;

&lt;p&gt;刷题能用它吗？能，比如说写个并查集&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/copilot/c3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;并查集的代码有点长，就没能全部截图。或者再来写个快速幂&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/copilot/c4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在写这些基础模板代码的时候，补全的效果又快又不会错（只是大多数情况下，它不总是正确的），简直就是刷题利器。不过更复杂的模板它就帮不了你了，但是它还能在一些细节上给你帮助。更有甚者，直接用这个工具去刷力扣的题，当然，只有早期的题目能给出完整答案就是了。再比如说，我写一个bigint的类，它就直接给提示了一个，带了加法和减法，但可惜它不是我想要的。换言之，空缺的部分较多时，它多数能给你一个能用的代码，但要是想写优秀的代码的话，你最好还是自己来，细节部分再让它给你补全。&lt;/p&gt;

&lt;p&gt;不过还是建议老手使用这个插件，新手在练习阶段，要是依赖了这个插件，上赛场那是没有这个插件可用的，不可能你只靠它来写代码，没了它就不会写这些基础的模板代码吧。而且，它补全的结果很多时候还是需要手动调整的，不过这已经足够让我觉得它非常厉害了。&lt;/p&gt;

&lt;h2 id=&#34;在开发上的帮助&#34;&gt;在开发上的帮助&lt;/h2&gt;

&lt;p&gt;在软件开发上，尤其是逻辑不像算法那么复杂的时候，提示的代码显得更为准确，甚至有一种为什么它能猜出自己想做啥的感觉，有时候显得比自己还要了解自己。用了一次就觉得太香了，香得回不去了。&lt;/p&gt;

&lt;p&gt;另外这个插件产生过很多争议，比如说，因为Github除了通过公开的repo，还通过私有repo代码来训练AI产生的代码，于是提示的内容有时会包含有版权和非公开的代码，结果就很可能被用到其它地方，产生版权问题（详细可以自行Google）。&lt;/p&gt;

&lt;p&gt;网上有太多文章在吹这个插件，我不想吹得太过，毕竟准确率其实还是一般，但只要有20%的提示特别的准确，就已经让你觉得很神了。所以说它还远远没到能替代人的地步，只是大多数情况下提供的代码相当强，提升不少生产力还是没有问题的。&lt;/p&gt;

&lt;h2 id=&#34;一个完整演示&#34;&gt;一个完整演示&lt;/h2&gt;

&lt;p&gt;我用它在几分钟里写了一个简单的压位大整数实现，里面用注释注明哪些函数是自动完成的，哪些是手动写的，写起来还是挺轻松愉快的，只要你不让它给你补除法的话。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;

#include &amp;lt;cstdio&amp;gt;

using namespace std;
typedef long long ll;
const int maxn = 1000000 + 10;

struct bigint {
    vector&amp;lt; int &amp;gt; v; // hand write
    bigint() {} // auto complete
    bigint(int x) { // hand write
        v.clear();
        for (; x; x /= 10000)
            v.push_back(x % 10000);
    }
    bigint operator+(const bigint &amp;amp;b) const { // auto complete
        bigint c;
        int carry = 0;
        c.v.resize(max(v.size(), b.v.size()));
        for (int i = 0; i &amp;lt; (int)v.size() || i &amp;lt; (int)b.v.size(); i++) {
            c.v[i] = (i &amp;lt; (int)v.size() ? v[i] : 0) + (i &amp;lt; (int)b.v.size() ? b.v[i] : 0) + carry;
            carry = c.v[i] / 10000;
            c.v[i] %= 10000;
        }
        if (carry)
            c.v.push_back(carry);
        return c;
    }
    bigint operator*(const bigint &amp;amp;b) const { // auto complete
        bigint c;
        c.v.resize(v.size() + b.v.size());
        for (int i = 0; i &amp;lt; (int)v.size(); i++) {
            for (int j = 0; j &amp;lt; (int)b.v.size(); j++) {
                c.v[i + j] += v[i] * b.v[j];
                c.v[i + j + 1] += c.v[i + j] / 10000;
                c.v[i + j] %= 10000;
            }
        }
        while (c.v.back() == 0) // hand write
            c.v.pop_back();
        return c;
    }
    bigint operator*(int x) const { // auto complete
        bigint c;
        c.v.resize(v.size() + 2);
        for (int i = 0; i &amp;lt; (int)v.size(); i++) {
            c.v[i] += v[i] * x;
            c.v[i + 1] += c.v[i] / 10000;
            c.v[i] %= 10000;
        }
        while (c.v.back() == 0)
            c.v.pop_back();
        return c;
    }
    string to_str() const { // hand write
        char buf[10];
        sprintf(buf, &amp;quot;%d&amp;quot;, v.back());
        string s = buf;
        for (int i = (int)v.size() - 2; i &amp;gt;= 0; i--) {
            sprintf(buf, &amp;quot;%04d&amp;quot;, v[i]);
            s += buf;
        }
        return s;
    }
};

int main() {
    bigint s;
    s = 1;
    for (int i = 1; i &amp;lt;= 100; i++) {
        s = s * i;
    }
    printf(&amp;quot;%s\n&amp;quot;, s.to_str().c_str());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;核心代码里面，加法几乎不用动手，乘法修正了一个前导0去除问题，主体的乘法代码我一点不用动就是正确的，就是输出基本得自己写。测试过加法乘法都没有问
题。减法测试过能正确补全，但除法就不放进来了，因为提示的代码太辣鸡了。更离谱的是如果你打上ntt，它真的给你补上用ntt实现的大整数乘法，只是很多细节还是要去改，核心代码倒是看着没啥大问题。&lt;/p&gt;

&lt;p&gt;还有一个问题，它在不同时间给你的补全是可能不太一样的，我这里的补全结果不见得你能重现，所以以上只供参考。&lt;/p&gt;

&lt;h2 id=&#34;优点和缺点&#34;&gt;优点和缺点&lt;/h2&gt;

&lt;p&gt;优点：提示内容相当完整（除非你希望它给你补全一个红黑树之类的，太长的还是不行），最强的自动提示插件，强大到你会怀疑它是不是知道你在想什么。&lt;/p&gt;

&lt;p&gt;缺点：你需要连网，而且能连上Github，使用前需要申请，并绑定你的Github账号。在linux上使用起来也会因为不同的环境配置起来更麻烦一些。&lt;/p&gt;

&lt;h2 id=&#34;其它替代品&#34;&gt;其它替代品&lt;/h2&gt;

&lt;p&gt;四个字：目前没有。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>折腾NAND</title>
      <link>/post/20211220-ssd/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0800</pubDate>
      <guid>/post/20211220-ssd/</guid>
      <description>&lt;p&gt;近期在折腾SSD、SD、U盘，折腾差不多来写个总结，坑不少。本文部分内容会随着时间而变化，于2021年12月编写。&lt;/p&gt;

&lt;h2 id=&#34;常见nand硬件&#34;&gt;常见NAND硬件&lt;/h2&gt;

&lt;p&gt;用于储存的基于NAND的硬件，有SD卡、MicroSD卡，U盘，移动固态硬盘，固态硬盘，通常来说，SD卡这类体积小的速度最慢，U盘次之，再就是移动固态硬盘，最快是固态硬盘。之所以说通常，因为还要看接口和协议速度。&lt;/p&gt;

&lt;h2 id=&#34;颗粒品质-原片-白片-黑片&#34;&gt;颗粒品质，原片、白片、黑片&lt;/h2&gt;

&lt;p&gt;储存颗粒按品质划分可以分为三大类，原片、白片、黑片。原片就是品质最好的，原厂最严格标准下的产品，白片就是从晶圆上不及格的里面，把还相对较好的挑选出来，黑片就是白片也不如，在剩下的挑选还能用的，同时把坏区进行屏蔽后造出来的颗粒，某宝上特别便宜的U盘肯定是黑片，还有像MP3，玩具等，通常都是用的黑片。黑片寿命说不准，快的一个星期，慢的2年，看运气。&lt;/p&gt;

&lt;h2 id=&#34;颗粒类型-slc-mlc-tlc-qlc-3d-nand&#34;&gt;颗粒类型，SLC、MLC、TLC、QLC、3D NAND&lt;/h2&gt;

&lt;p&gt;SLC表示，一个存储单元，只存0和1，即1bit，MLC保存00、01、10、11，即2bits，同理，TLC可以保存3bits，QLC保存4bits。SLC最贵，速度最快，寿命最长，可达10W次擦除（原片颗粒的情况下，不算白片黑片，下同）。MLC次之，约3000到5000次擦除。TLC再次之，约1000次擦除。QLC速度最慢，寿命最短，约800次擦除。另外，3D NAND可以大幅度提升寿命，3D TLC可达3000到5000次擦除，3D QLC可达1000到3000次擦除。&lt;/p&gt;

&lt;h2 id=&#34;颗粒的读取-写入-擦除&#34;&gt;颗粒的读取、写入、擦除&lt;/h2&gt;

&lt;p&gt;一片NAND划分为很多个Die，Die是执行指令的最小单位。每个Die分为多个Plane，每个Plane分为多个Block，Block是擦除的最小单位，每个Block分为很多Page，读取时，以Page为单位，一次性读入整个Page的内容，如果一个Page大小有8k，那就是一次性读入8k的数据。而写入有点特殊，在一个Block里，只能按顺序写入，每次写入的单位为Page，不能跳着写，也不能回头写。擦除时，每次只能把整个Block擦除，然后再按顺序写入。&lt;/p&gt;

&lt;h2 id=&#34;主控&#34;&gt;主控&lt;/h2&gt;

&lt;p&gt;主控对SSD的寿命和速度处于非常主要的地位，同时也是NAND里面最容易挂掉的模块，它工作时发热很厉害，连续长时间下载写入或磁盘测速之类的可能会让主控过热烧毁。NAND是原片，多数情况下主控比NAND本身还要早挂掉。&lt;/p&gt;

&lt;p&gt;主控还负责FTL层，即从逻辑地址映射到物理地址的映射。FTL通常包含GC算法、Wear leveling（WL）磨损平衡算法。&lt;/p&gt;

&lt;p&gt;另外还有一个关键点，就是看主控支不支持TRIM指令（在NVME上不叫这个名字，但为了统一通常还是这么称呼），在支持TRIM指令的主控上，配合操作系统，能大大优化GC。绝大多数的MicroSD卡和SD卡都不支持TRIM，大部分低端U盘也不支持，少数移动SSD不支持。不支持TRIM的后果，是当写入量累计达到它的容量时，因为主控并不知道还有哪些地方可以写入，于是只好原地写入，磨损平衡就不存在了。当然并不是说不支持TRIM就一定没有磨损平衡，比如说，你的SD卡使用了exfat格式，SD卡主控能认出来，自己找到没有使用的地方进行GC的话，那确实不需要支持TRIM就可以达到相似的效果。如果SD卡厂商宣传上写了支持的文件系统，那有可能就是这个类型。所以，这种不支持TRIM指令的，如果没有做磨损平衡，会把它当普通硬盘一样写入（这种盘最好每次写满了再删掉，或直接做监控视频用），而如果有做，那格式化的时候就只开比如3/4的大小，保留一部分用来做磨损平衡。&lt;/p&gt;

&lt;p&gt;查看硬件支不支持TRIM，在Windows上有很多方式，最简单的方法，插入U盘或SD卡后，右键属性，在工具页面有个优化按钮，点进去就能看到当前所有驱动器的媒体类型，识别为固态硬盘的，就是支持TRIM，如果只是显示硬盘驱动器的，就是不支持TRIM。或者还可以用DiskGenius，对驱动器右键，看有没有“TRIM优化”这一项。&lt;/p&gt;

&lt;p&gt;也就是说，对于大多数SD卡，如果要寿命长，那么最好是老实地放相机之类的使用，就每次存资料放满了，格式化再存，不要只存一点点数据就删除了再存。除非确认它支持磨损平衡。&lt;/p&gt;

&lt;p&gt;对于支持GC和WL的，存在写入放大的问题。比如说，要写入一个10K大小的数据，需要占用2个page，但已经没有一个block可以直接写入2个Page，这时候就需要做一次GC，把2个各有一个空余page的block里有用的数据读出，再重新写入，这样再把原本要写入的数据写入到2个空出来的page里面。于是，原本写入2个page大小的数据，结果是写入了2个block，考虑到1个block里面假设有128个page的话，那就是放大写入128倍。但是，对于不支持GC和WL的，每满一次之后每次写入都在写入放大，每次写入都是把整个block读出，然后和要写入的数据合并，再整个写入。不论你写入的数据量是1字节还是10k，本质上都写入了一个block，这就是掉速原因之一。而且这种掉速无法通过格式化恢复。&lt;/p&gt;

&lt;p&gt;好的主控还能对过早损坏的块做屏蔽处理，比如说通常SSD标注为500G而不是512G（但SD卡会标注为512G），那一点空间一来是保存FTL的LBA/PBA表，二来是减少写入放大的次数，三是做坏块的替换品。而对于有屏蔽坏块能力的主控，即使用白片用户也很难感知（等到你能感知到的时候已经过了保修），所以SSD里用白片那是一大片，最简单可以用价格看出来，比如说，三星的SSD差不多0.9元/G，而还有西数之类的，有0.6元/G的，大概率是白片。&lt;/p&gt;

&lt;p&gt;另外，还有一个冷数据的问题，通常你保存的数据里，有80%是存了就长期不会改动的，这些就称之为冷数据。好的主控还应该能对冷数据定期进行移动，以避免剩余空间较少时，反复写入的都是相同的位置，导致过早擦除过量。所以好的主控对寿命的影响起到关键因素。&lt;/p&gt;

&lt;h2 id=&#34;tbw&#34;&gt;TBW&lt;/h2&gt;

&lt;p&gt;这是个单位，比如300TBW是指累计写入300TB。在SSD产品上，写入量超过这个数量就不保修，这个数值并不代表其寿命，但可以作为其寿命的参考值。&lt;/p&gt;

&lt;h2 id=&#34;wintogo&#34;&gt;Wintogo&lt;/h2&gt;

&lt;p&gt;所谓Wintogo，就是把Windows系统安装在移动设备上，这样要用自己安装的环境配置，直接插个U盘就可以了。不过这个对移动设备有不低的要求，有多不低呢？比如说Sandisk全线U盘没有一个能跑Wintogo，因为不支持TRIM，会导致用着用着系统很卡很慢，而且它的移动硬盘也很诡异的不支持TRIM，很多人反映会越用越慢。反过来，如果你想买优质U盘，搜索Wintogo的U盘即可，而且这种盘比同价位的Sandisk要快得多，读400M写300M是标配，性价比甩开几条大街。&lt;/p&gt;

&lt;p&gt;而使用硬盘盒+SSD来做大号U盘也是没有问题的，主要要注意的是硬盘盒，如果你用NVME M.2的SSD，而且你没有红色的USB3.2 Gen2接口的话，那避免使用高端硬盘盒，找那些支持Gen1就可以的硬盘盒，以避免供电不足导致掉盘。当然这样就会导致速度限制在400M到500M，略微比U盘快一点点的程度吧。或者，你如果有USB typec口，就直接用这种口的硬盘盒，就没有供电上的问题。相比较厂商卖的移动硬盘比呢？个人觉得自己配的性价比更高，700块不到可以搞到一块1T的SSD+盒子，比起Sandisk不但性能更高，还更便宜，还能上Wintogo。&lt;/p&gt;

&lt;p&gt;不过上WTG要注意的是安装最好选择离线，不然安装好后它会马上帮你更新驱动，在更新USB驱动时会可能会导致USB临时掉线，但同时你的系统盘就是USB，那后果就是突然死机，如果死机那一时刻还有别的东西正在更新（比如万恶的Windows更新），那就可能直接导致系统挂掉无法修复。可以先离线安装好并重启，再进行网络连接，避免系统在同时更新多个，外加一点运气，死机重启后就能用的话，就恭喜了。另外，WTG最好关闭休眠功能，不然有的机器唤醒时USB还没及时连上，又得死机。&lt;/p&gt;

&lt;h2 id=&#34;缓外&#34;&gt;缓外&lt;/h2&gt;

&lt;p&gt;所谓缓外，通常指写入超过缓存的量的时候的写入速度。现在的SSD对于使用TLC或QLC的，最大问题就是速度慢，通常是使用SLC作为缓存，有的是使用独立的SLC，有的是把TLC直接模拟为SLC。在缓存内的时候速度很好看，几百M甚至上G，而缓外才真正看出这个盘的实际水平。&lt;/p&gt;

&lt;h2 id=&#34;选购建议&#34;&gt;选购建议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SD卡（含MicroSD）：一定要网购，绝对不要在街上买（90%是假货而且比正品更贵），然后找那些声称终身质保的产品（单价超过1.5元/G），然后使劲用就好了。比如某迪最高端的红黑卡。&lt;/li&gt;
&lt;li&gt;U盘：一定要网购，找Wintogo的U盘，推荐Chipfancier。不建议买大厂的，贵且慢。&lt;/li&gt;
&lt;li&gt;移动硬盘：如果钱不是问题，那直接上三星，其它情况的话看你的需求来选择，500M到800M的速度就够用的话用硬盘盒+SSD，100出头的盒子就够用了，一定要有typec接口的。如果要买厂家完整方案的，不要选择某迪和雷某某。至于怎么选SSD看下面。&lt;/li&gt;
&lt;li&gt;SSD：一定要网购，挑质保长的，TBW除以容量大的。要品质上三星。如果是配置盒子用，盒子速度是10Gbps的，那要个大厂的便宜的就够了，最重要的是发热少。最好问清楚卖家缓外速度，缓外500M以上的是TLC，只有60到100M的肯定是QLC，在中间的说不准。貌似看不到有卖MLC的，所以只要别掉到QLC里，或者上钞能力就行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结，啥都不懂就盲选三星。如果你是想搞WTG，而且你的机器有雷电typec或USB 3.2 Gen2（红色），那么用硬盘盒+SSD，否则用U盘。&lt;/p&gt;

&lt;h2 id=&#34;商家标识的坑&#34;&gt;商家标识的坑&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;只标识读取速度，不标写入速度（大多数SD卡）：这样写入速度达不到你也没有理由要求售后，因为商家没保证写入。&lt;/li&gt;
&lt;li&gt;只标识读取和写入，不标缓外：同理，超出缓存的掉速，商家不保证其速度。商家经常在这种地方出新品的同时在降级（用更差的主控导致缓外速度更慢），以拉开商家自己其它产品的差距，避免特定型号“太香”，同时多赚钱。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其它-关于叠瓦盘srm&#34;&gt;其它：关于叠瓦盘SRM&lt;/h2&gt;

&lt;p&gt;叠瓦盘的原理这里就不介绍了，随便Google就有。叠瓦盘有着和NAND相似的特性，重叠区块写入如果规定必须按顺序来，那么就不存在写入特别慢的情况，否则就要按顺序一条一条磁道进行恢复，速度非常慢。为了克服这个问题，新式叠瓦盘是支持TRIM的，使用和SSD一样的管理算法来克服写入速度的问题，也就是说叠瓦是必然的发展趋势。也就是说，如果你看到磁盘上标示支持TRIM，那就是叠瓦盘。但如果你看到不支持TRIM的叠瓦盘，别买，买了就后悔。不过即使支持TRIM，磁盘还是不可避免地在长期使用后连续的数据变成碎片化，从而导致读写变慢，以及偶尔的GC可能会导致一段时间没有响应，外部表现为写入速度为0，会变多慢这完全依赖于主控。所以能买垂直式CRM就尽量用CRM，SRM的问题还不少。不过支持TRIM的SRM盘在系统里会怎么显示我还不清楚，我手上没这个可以测试。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;和硬件打交道，本质上就是和奸商斗智斗勇，并不是你多给钱就一定能得到应有的东西。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>折腾linux</title>
      <link>/post/20210621-ubuntu/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210621-ubuntu/</guid>
      <description>&lt;p&gt;近期在折腾linux，折腾差不多来写个总结，这货折腾了我很长的时间。由于USB3.0已经发展很久了，现在随便买的MicroSD/SD卡或U盘基本上都是USB3.0 class 10起步，所以考虑直接用这些来安装系统，这样你对哪个系统不满意直接换个U盘或SD卡就搞定了，而且测试下来速度也不慢。即使你的机器只有USB2.0接口，那也是能用的，就是启动时能感觉出来慢一些。这个也是方便咱们在校学生只有一台电脑，能方便更换系统不必每次折腾一次硬盘，同时可以熟悉比赛时所用的linux环境。另外，如果你想偷懒，我在这也准备了一些系统镜像，直接刷入U盘即可使用，请参见本文最末尾。本文主要针对LTS20版ubuntu，存在有效时限。&lt;/p&gt;

&lt;h2 id=&#34;在usb存储器上安装linux操作系统&#34;&gt;在USB存储器上安装linux操作系统&lt;/h2&gt;

&lt;p&gt;在USB设备上安装个linux系统是很容易的，比起windows和MacOS来说，容易很多。这里有两种操作方式，一是使用虚拟机，这样我们只需要准备一个U盘（或SD或MicroSD卡，下文中说的U盘通常指这三者，且容量必须是16G或以上），二是使用真实机器来安装，这样我们需要准备两个U盘，多出来的一个是用来制作安装盘，安装工具推荐 &lt;a href=&#34;https://rufus.ie/&#34; target=&#34;_blank&#34;&gt;Rufus&lt;/a&gt; 和 &lt;a href=&#34;https://www.pendrivelinux.com/yumi-multiboot-usb-creator/&#34; target=&#34;_blank&#34;&gt;YUMI&lt;/a&gt; 以及 &lt;a href=&#34;www.ventoy.net&#34; target=&#34;_blank&#34;&gt;Ventoy&lt;/a&gt;，后两者可以用于制作多启动的U盘。&lt;/p&gt;

&lt;p&gt;然后，我们要对目标U盘进行分区，可以用DiskGenius或linux上的分区工具GParted。首先要创建MBR分区表或GPT分区表（如果是GParted，要注意建立分区表的时候并没有MBR，而是显示为msdos），如果你的机器支持UEFI启动就可以用GPT，如果要简单好操作就MBR。MBR的话很简单，直接划分一个swap区，一个ext4即可。如果你同时需要它当U盘用，那多分第一个区分为fat32。而如果是GPT那就要多分1个100M的fat32，并且标记为boot/esp。这样U盘就准备好了。之所以要先分区，是因为安装程序的分区工具有可能无法做更细致的操作。GPT的稍微复杂些，来直接看我的GPT分区结果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/ubuntu/u_p.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后一个分区需要视发行版本来决定保留多大，有的没有要求，有的需要8M，那个分区设置&lt;code&gt;bios_grub&lt;/code&gt;标记，用于兼容传统Bios启动。如果使用虚拟机，则直接使用iso光盘启动，真实机器用U盘启动，启动后的安装步骤是几乎一样的。另外还有一点要注意的是，如果U盘分区总是出错，或后面安装系统总是出错，且这个盘的牌子是Kingston或SanDisk，那你很可能手上的是扩容盘或假货（我会说我被假货坑过么），要确认是不是扩容盘，一个简单点的方法是把盘用&lt;code&gt;Gparted&lt;/code&gt;创建gpt分区表，然后随便分个区，然后重新插入并刷新，如果Gparted会报错，那很可能是扩容盘。&lt;/p&gt;

&lt;p&gt;如果你用虚拟机来安装，那么请确认你的虚拟机是不是设置为EFI模式启动，必须以这个模式启动安装，才支持UEFI。启动ubuntu安装程序后，为了安装速度快一点，不要更新，需要更新的话可以安装好后操作。安装好后，它提示要重启，这里不要重启，继续执行以下命令来制作Bios启动（假如系统安装在sdb3，如果不是，要自行修改）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/sdb3 /mnt
sudo grub-install --target=i386-pc --recheck --boot-directory=/mnt/boot /dev/sdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，分区结果如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/ubuntu/u_part.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上安装方法不限于ubuntu，虽然基于ubuntu的成功率最高，但其它版本也有不少可以。有的发行版会要求你手动把那个100M标记为boot的分区，手动挂载到&lt;code&gt;/boot/efi&lt;/code&gt;，否则会导致安装失败。另外要注意一个情况，有的时候安装后那个U盘/SD卡启动失败或安装失败，这个时候要更换U盘或读卡器再次尝试，因为扩容U盘/黑片和部分差的读卡器确实会导致这种问题。另外如果系统支持btrfs文件系统，也建议格式化为btrfs文件系统，对U盘会更友好。&lt;/p&gt;

&lt;h2 id=&#34;基本软件的安装&#34;&gt;基本软件的安装&lt;/h2&gt;

&lt;h3 id=&#34;chromium&#34;&gt;Chromium&lt;/h3&gt;

&lt;p&gt;这里不提Firefox是因为它不存在Chromium的问题。安装它不难，在软件包找到它直接安装就是，关键问题是需要设置代理来访问扩展商店，解决方法是在命令行执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chromium --proxy-server=&amp;quot;socks5://127.0.0.1:1080&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chromium --proxy-server=&amp;quot;http://127.0.0.1:8080&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有了这个，就可以安装代理插件，之后的事情就容易多了。有相当的软件都有类似的命令行代理设置，通常Google一下即有答案。&lt;/p&gt;

&lt;h3 id=&#34;输入法&#34;&gt;输入法&lt;/h3&gt;

&lt;p&gt;如果你一开始选择的语言就是中文来安装，那么通常会给你自动安装好中文输入法，否则你要手动做以下步骤&lt;/p&gt;

&lt;p&gt;如果输入法进程没有默认启动，那么需要编辑&lt;code&gt;.bashrc&lt;/code&gt;，如果是ibus则添加以下内容到最末尾&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GTK_IM_MODULE=ibus 
export QT_IM_MODULE=ibus 
export XMODIFIERS=@im=ibus 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果还不行，那么还需要添加以下内容到&lt;code&gt;/etc/profile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GTK_IM_MODULE=ibus 
export QT_IM_MODULE=ibus 
export XMODIFIERS=@im=ibus 
ibus-daemon -drx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不管你使用iBus还是fcitx，都可以安装Rime，安装好后，如果是ibus，就创建并编辑 &lt;code&gt;~/.config/ibus/rime/default.custom.yaml&lt;/code&gt;，内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patch:
    schema_list:
        - schema: luna_pinyin
        - schema: wubi86
        - schema: wubi_pinyin
        - schema: double_pinyin

    &amp;quot;ascii_composer/switch_key/Shift_L&amp;quot;: commit_code
    &amp;quot;ascii_composer/switch_key/Shift_R&amp;quot;: commit_code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;schema_list&lt;/code&gt;就是输入法列表，依次为拼音，五笔，五笔拼音，自然码双拼。另外还需要安装对应的输入法码表&lt;/p&gt;

&lt;p&gt;五笔：
&lt;code&gt;sudo apt install librime-data-wubi&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;双拼：
&lt;code&gt;sudo apt install librime-data-double-pinyin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;更多的输入法可以在包管理器上查找。但默认xubuntu似乎没有安装这样的包管理器，但你可以搜索 Muon 软件包管理器安装，安装后就可以轻松查询到rime相关的输入法码表了。&lt;/p&gt;

&lt;p&gt;以上操作完成后，需要点击输入法的图标，点【部署】，成功后便可用&lt;code&gt;win+space&lt;/code&gt;或&lt;code&gt;ctrl+space&lt;/code&gt;在不同输入法之间切换，&lt;code&gt;ctrl+~&lt;/code&gt;用在rime里面切换不同码表或选项（半角全角简体繁体等）&lt;/p&gt;

&lt;p&gt;另外还有一种比较快捷的输入法方法，先安装Chromium，然后安装 Google Input 扩展，选择你要用的输入法即可在网页里输入，适用于做测试需要临时输入的情况。&lt;/p&gt;

&lt;h3 id=&#34;exfat文件格式支持&#34;&gt;exfat文件格式支持&lt;/h3&gt;

&lt;p&gt;默认是不支持的，但大容量的卡必然用到，所以肯定要安装一把&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt install exfat-utils&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外如果需要支持这个分区的分区软件，可以安装&lt;code&gt;KDE Partition Manager&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;rdp远程桌面或ssh-sftp&#34;&gt;RDP远程桌面或SSH/SFTP&lt;/h3&gt;

&lt;p&gt;安装Remmina即可，支持剪贴板复制文本和图片，但不支持剪贴板复制文件，且通过共享目录的方式传送文件在通常情况下非常慢（需要手动把连接质量设置为best），而且容易掉线。如果需要经常传送文件，这个功能建议使用SMB或NFS代替，速度差别巨大。&lt;/p&gt;

&lt;h3 id=&#34;音效软件-pulseeffects&#34;&gt;音效软件 PulseEffects&lt;/h3&gt;

&lt;p&gt;网上很多人说windows上有什么SRS啥的音效增强软件，而ubuntu上没有云云，其实软件包里自带的这个PulseEffects已经做得挺不错了，不过要注意的是安装好后，在设置里要勾上&lt;code&gt;Start Service at Login&lt;/code&gt;，这一步很重要。&lt;/p&gt;

&lt;p&gt;另外如果有时候重启了没有声音，多半是PulseAudio出问题了，&lt;a href=&#34;https://askubuntu.com/questions/748112/pulseaudio-process-is-not-starting&#34; target=&#34;_blank&#34;&gt;参见这个&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;刚安装好的时候，equaliser这个模块的功能通常是用不了的，需要执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt install lsp-plugins&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装&lt;code&gt;lsp-plugins&lt;/code&gt;后重启系统即可。&lt;/p&gt;

&lt;h3 id=&#34;屏幕截图&#34;&gt;屏幕截图&lt;/h3&gt;

&lt;p&gt;推荐安装Flameshot，然后在系统设置的键盘，在应用程序快捷键处，对快捷键Print的命令，修改为&lt;code&gt;/usr/bin/flameshot gui&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;windows上的字体&#34;&gt;windows上的字体&lt;/h3&gt;

&lt;p&gt;如果这个发行版有字体管理器，直接用它安装即可。但如果没有的话，那么把字体文件复制到fonts路径（如果后缀不是ttf，而是ttc的，要先改后缀），例如是&lt;code&gt;/usr/local/share/fonts&lt;/code&gt;，然后执行 &lt;code&gt;sudo fc-cache -f -v&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;系统备份&#34;&gt;系统备份&lt;/h3&gt;

&lt;p&gt;如果你的空间足够，那可以安装&lt;code&gt;timeshift&lt;/code&gt;使用。&lt;/p&gt;

&lt;h3 id=&#34;护眼红移&#34;&gt;护眼红移&lt;/h3&gt;

&lt;p&gt;有的发行版本身就支持，如果不支持时安装&lt;code&gt;redshift&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;屏保&#34;&gt;屏保&lt;/h3&gt;

&lt;p&gt;如果你实在是闲，可以安装xscreensaver，这个比windows自带的丰富得多。lubuntu版本已安装。&lt;/p&gt;

&lt;h3 id=&#34;其它坑&#34;&gt;其它坑&lt;/h3&gt;

&lt;p&gt;没事不要在home的模板文件夹里放东西，东西一多会卡得很慢。&lt;/p&gt;

&lt;h2 id=&#34;u盘或sd卡选择-深坑-且部分内容会随时间过期-所以不详细讲&#34;&gt;U盘或SD卡选择（深坑，且部分内容会随时间过期，所以不详细讲）&lt;/h2&gt;

&lt;h3 id=&#34;读写速度问题&#34;&gt;读写速度问题&lt;/h3&gt;

&lt;p&gt;这个要注意了，如果你是打算用这个卡较长时间玩，那么在选择上就要注意一点了，首先一盘的U盘或SD卡并没有提供4K小文件（不是4K视频，是指大小在4K以内的小文件）的读写速度，而是视频录制速度，而4K小文件的读写速度直接影响你的体验。但是这个由于没有标注，你只可以通过评测论坛来提供的测试数据来做参考。我就遇到过大文件写入没啥问题，但4K小文件奇慢的tf卡（没错，就是Kingston，不知道是不是假货，手上N个全部一个德行）。当然，这个和你直接上SSD的速度完全不能比，但替代老机械硬盘已经没有什么问题，所以如果你有一台笔记本有USB3.0接口同时不带SSD，那可以考虑上U盘。要买的话一定要容量至少是64G的，即使你只是想用来玩玩看。&lt;/p&gt;

&lt;h3 id=&#34;寿命问题&#34;&gt;寿命问题&lt;/h3&gt;

&lt;p&gt;在U盘或SD上安装这个不得不考虑的就是它的寿命。现在大多数的U盘或SD卡，都是用TLC甚至QLC，那么大概只有1000次写入。而中低端卡或U盘往往没有wear leveling即磨损均衡，导致坏得很快，但这个信息同样没有在卡上标注，那怎么办？如果你想稳定长期使用，那么建议找针对WTG设计的U盘，寿命最佳，随便折腾。其次是大牌子的中高端SD/Micro SD卡。低端卡和其它小牌子的质量真的不行，。&lt;/p&gt;

&lt;h3 id=&#34;读卡器的问题&#34;&gt;读卡器的问题&lt;/h3&gt;

&lt;p&gt;没错，这里也是有坑的。首先，有的笔记本虽然有读卡口，但是不支持从卡启动，所以还是必须上读卡器从USB启动。有的读卡器不支持引导（别以为是你没有设置好Bios启动顺序），有的读卡器不支持32G以上的卡（有的遇到64G的卡直接报只读），有的读卡器会莫名读写错误导致写入失败或启动失败（要是确认这个读卡器会有这个问题，千万不要再用了，谁和你有仇就送给他），有的读卡器不支持虚拟机，无法用在虚拟系统里（这种读卡器特点是支持同时读两张卡的那种），有的3.0的迷你读卡器发热厉害，同时卡的位置与发热位置近，温度过高会让卡的寿命大幅度缩小甚至导致写入出错。反正总会在你想象不到的地方出坑。这里也是提醒你有时候不是卡的锅。&lt;/p&gt;

&lt;p&gt;而且，既然读卡器有坑，那么MicorSD转SD的卡套自然也可能出问题。有一些卡套是假的，也有一些牌子都没写，这类卡容易存在读写错误，以及识别率低或容易磨损接触不良等问题。&lt;/p&gt;

&lt;h3 id=&#34;推荐&#34;&gt;推荐&lt;/h3&gt;

&lt;p&gt;鉴于我试过的实在太少，这里U盘我没有可推荐的，你可以上网搜索WTG，适合WTG的U盘都很耐折腾。如果你只是要用来玩玩，那么弄SD/MicroSD卡也行。我觉得可以考虑的品牌：SAMSUNG, SanDisk。而容量最好是128G及以上，SD卡的话速度建议选择标注U3，V30，A1或以上。&lt;/p&gt;

&lt;h3 id=&#34;对于非linux系统&#34;&gt;对于非linux系统&lt;/h3&gt;

&lt;p&gt;对于windows，那要求就高得多了，不要想着用SD卡，如果用普通的U盘，那是卡得你根本不想用（但同样的U盘安装linux跑跑还是过得去的），我也还没有足够的资源去尝试高端产品（主要是穷），所以这里略过。至于MacOS我还没有资源来测试。
。&lt;/p&gt;

&lt;h2 id=&#34;快速部署镜像&#34;&gt;快速部署镜像&lt;/h2&gt;

&lt;p&gt;我放在了&lt;a href=&#34;https://github.com/Baobaobear/linux_image/releases&#34; target=&#34;_blank&#34;&gt;这个github页面&lt;/a&gt;，你可以把压缩包下载后，直接写入U盘，然后做扩大分区的操作，就可以使用了。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;折腾linux你要准备好重装5次以上的打算，这就是一个踩坑的过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>二分搜索杂谈</title>
      <link>/post/20210507-binsearch/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210507-binsearch/</guid>
      <description>&lt;p&gt;二分搜索虽然基本思想简单，但其细节却令人意外的抓狂（Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky）。这里我们来分析一下常见写法的坑。&lt;/p&gt;

&lt;h2 id=&#34;两类不同的二分&#34;&gt;两类不同的二分&lt;/h2&gt;

&lt;p&gt;二分有两类，一是找值，即判断某个值存不存在，二是找边界，前者比后者简单很多，以下是找值的典型写法（来自中文wiki百科）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int binary_search(const int arr[], int start, int end, int key) {
	int ret = -1;       // 未搜索到数据返回-1下标

	int mid;
	while (start &amp;lt;= end) {
		mid = start + (end - start) / 2; //直接平均可能會溢位，所以用此算法
		if (arr[mid] &amp;lt; key)
			start = mid + 1;
		else if (arr[mid] &amp;gt; key)
			end = mid - 1;
		else {            // 最後檢測相等是因為多數搜尋狀況不是大於要不就小於
			ret = mid;  
			break;
		}
	}

	return ret;     // 单一出口
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于找边界，有四种情况，如以下例子，查找数值5的四种边界&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;1 1 1 2 2 5 5 5 5 7 9
        ^ 1 小于的最右元素
          ^ 2 大于等于的最左元素
                ^ 3 小于等于的最右元素
                  ^ 4 大于的最左元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然有四种边界，那就有四种写法。&lt;/p&gt;

&lt;h2 id=&#34;常见基本写法&#34;&gt;常见基本写法&lt;/h2&gt;

&lt;p&gt;为了好理解，这里直接用int写，且使用闭区间写法，而不使用模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int bin_search_1(int arr[], int len, int val) {
  int l = 0, r = len - 1;
  while (l &amp;lt; r) {
    int m = l + ((r - l + 1) / 2);
    if (arr[m] &amp;lt; val) {
      l = m;
    } else {
      r = m - 1;
    }
  }
  return l;
}

int bin_search_2(int arr[], int len, int val) {
  int l = 0, r = len - 1;
  while (l &amp;lt; r) {
    int m = l + ((r - l) / 2);
    if (arr[m] &amp;lt; val) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return l;
}

int bin_search_3(int arr[], int len, int val) {
  int l = 0, r = len - 1;
  while (l &amp;lt; r) {
    int m = l + ((r - l + 1) / 2);
    if (arr[m] &amp;lt;= val) {
      l = m;
    } else {
      r = m - 1;
    }
  }
  return l;
}

int bin_search_4(int arr[], int len, int val) {
  int l = 0, r = len - 1;
  while (l &amp;lt; r) {
    int m = l + ((r - l) / 2);
    if (arr[m] &amp;lt;= val) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return l;
}

int main() {
  int a[] = {1, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10};
  int len = 16, val = 5;
  cout &amp;lt;&amp;lt; bin_search_1(a, len, val) &amp;lt;&amp;lt; endl;
  cout &amp;lt;&amp;lt; bin_search_2(a, len, val) &amp;lt;&amp;lt; endl;
  cout &amp;lt;&amp;lt; bin_search_3(a, len, val) &amp;lt;&amp;lt; endl;
  cout &amp;lt;&amp;lt; bin_search_4(a, len, val) &amp;lt;&amp;lt; endl;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;以上写法的坑点&#34;&gt;以上写法的坑点&lt;/h2&gt;

&lt;p&gt;坑点主要有以下4个，当这4个你搞明白了以后，你就可以肉眼debug出一个二分写法的问题了。&lt;/p&gt;

&lt;h3 id=&#34;1-区间表示&#34;&gt;1. 区间表示&lt;/h3&gt;

&lt;p&gt;如果采用闭区间，那么循环的条件就是&lt;code&gt;l &amp;lt; r&lt;/code&gt;，当这个条件满足时，这个区间就表示了两个或以上的元素&lt;/p&gt;

&lt;p&gt;同理，如果采用半开半闭区间，那么循环的条件就是&lt;code&gt;l + 1 &amp;lt; r&lt;/code&gt;，如果采用开区间，那么循环条件就是&lt;code&gt;l + 2 &amp;lt; r&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-比较&#34;&gt;2. 比较&lt;/h3&gt;

&lt;p&gt;比较的方式取决于你的边界是左边界还是右边界，如果是左边界，那么边界左边的数均为小于，而右边的数是大于等于，那么你应该用 &lt;code&gt;arr[m] &amp;lt; val&lt;/code&gt;作为判断条件；同理地，如果是右边界，那么边界左边的数均为小于等于，而右边的数是大于，这时应该用&lt;code&gt;arr[m] &amp;lt;= val&lt;/code&gt;作为判断条件&lt;/p&gt;

&lt;h3 id=&#34;3-更新区间&#34;&gt;3. 更新区间&lt;/h3&gt;

&lt;p&gt;在比较后，更新区间时，有的+1有的-1有的不需要加减，这是怎么决定要不要加呢？这个由你所查找的区间是否包含这个数决定。举个具体例子，在&lt;code&gt;4 5 5 6&lt;/code&gt;中，给出要查找的数值&lt;code&gt;5&lt;/code&gt;，要查找到小于5的最大那个数，即4，那么比较方式是&lt;code&gt;arr[m] &amp;lt; val&lt;/code&gt;。如果这个小于号满足，比如说&lt;code&gt;arr[m]&lt;/code&gt;是4，那么这个数是可能在查找区间内，所以不应该+1或-1，但如果&lt;code&gt;arr[m]&lt;/code&gt;是5，这个数不应该在查找区间内，那么就果断要+1或-1。在边界查找写法里，必然有一边是需要+1或-1，而另一边不需要，这个会影响下面要介绍的中间数选择。&lt;/p&gt;

&lt;h3 id=&#34;4-中间数的选择&#34;&gt;4. 中间数的选择&lt;/h3&gt;

&lt;p&gt;中间数选择，即以上代码中的变量m，有的时候&lt;code&gt;(r - l) / 2&lt;/code&gt;，有的时候&lt;code&gt;(r - l + 1) / 2&lt;/code&gt;，这个写法取决于当&lt;code&gt;r - l == 1&lt;/code&gt;时，那么m要么等于l，要么等于r，为了这个循环能结束，如果下方代码是&lt;code&gt;l = m&lt;/code&gt;，那么m要取r，即要+1，如果下方代码是&lt;code&gt;r = m&lt;/code&gt;，那么m要取l，不需要+1。这个如果写错就会导致死循环的发生。&lt;/p&gt;

&lt;p&gt;另外，还有一个更多人犯的错误，很多人会写&lt;code&gt;m = (l + r) / 2&lt;/code&gt;，当然，这个其实在不少情况下确实也不会怎么样，但是，如果我们要做的事情并不是在数组中查找，而是在一个区间里面，比如找一个方程的整数解，或者求3次方根的整数部分，这就会产生问题了，当 l和r是负数的时候，与它们是正数的时候，除以2的含义是不一样的，C语言中的除法实际上是向0取整，比如说，&lt;code&gt;-7/2 == -3&lt;/code&gt;，但是，在二分搜索时，我们必须要么向上取整，要么向下取整，但存在负数时，这样做除法可能会导致二分死循环。采用&lt;code&gt;(r - l) / 2&lt;/code&gt;可以避免这个问题，或者，你还可以使用位运算技巧&lt;code&gt;(r - l) &amp;gt;&amp;gt; 1&lt;/code&gt;。当然，为了减少中坑起见，写&lt;code&gt;m = l + (r - l) / 2&lt;/code&gt;最保险。&lt;/p&gt;

&lt;h2 id=&#34;避免进坑的写法&#34;&gt;避免进坑的写法&lt;/h2&gt;

&lt;p&gt;以上写法坑太多（其实这些坑的有一部分的本质是你采用了闭区间），怎么样避免掉以上种种问题搞一个坑最少最不容易出错的写法呢？来看这个写法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int bin_search_r1(int arr[], int len, int val) {
  int l = -1, r = len;
  while (l + 1 &amp;lt; r) {
    int m = l + ((r - l) / 2);
    if (arr[m] &amp;lt; val) {
      l = m;
    } else {
      r = m;
    }
  }
  return l;
}

int bin_search_r2(int arr[], int len, int val) {
  int l = -1, r = len;
  while (l + 1 &amp;lt; r) {
    int m = l + ((r - l) / 2);
    if (arr[m] &amp;lt; val) {
      l = m;
    } else {
      r = m;
    }
  }
  return r;
}

int bin_search_r3(int arr[], int len, int val) {
  int l = -1, r = len;
  while (l + 1 &amp;lt; r) {
    int m = l + ((r - l) / 2);
    if (arr[m] &amp;lt;= val) {
      l = m;
    } else {
      r = m;
    }
  }
  return l;
}

int bin_search_r4(int arr[], int len, int val) {
  int l = -1, r = len;
  while (l + 1 &amp;lt; r) {
    int m = l + ((r - l) / 2);
    if (arr[m] &amp;lt;= val) {
      l = m;
    } else {
      r = m;
    }
  }
  return r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上写法看初值似乎是在采用开区间，其实不然，实际上是半开半闭区间表示（看循环条件），表示要查找的值在&lt;code&gt;[l, r)&lt;/code&gt;内或&lt;code&gt;(l, r]&lt;/code&gt;内，返回值如果是l那区间就是&lt;code&gt;[l, r)&lt;/code&gt;，反之就是&lt;code&gt;(l, r]&lt;/code&gt;。在循环结束前，区间&lt;code&gt;[l, r]&lt;/code&gt;内至少有3个元素，这样m肯定与l或r不相等，不存在死循环的可能性，也不需要关心向上取整还是向下取整的问题，这也是半开半闭区间表示的优点。另外，不论区间是3个还是4个元素，最终都会缩短为刚好2个元素，l指向满足比较条件的最右的元素，r指向不满足比较条件的最左元素。还有一点，由于m永远不会等于l或r，所以这样初始化并不会产生越界访问，而且这个初始化保证了m有可能取到&lt;code&gt;[l+1, r-1]&lt;/code&gt;中任何一个。所以，这个二分写法，我们只需要管比较条件的写法来决定找左边界或右边界，以及返回l或r决定具体边界元素即可，几乎就是个无坑版本写法，非常建议在比赛里采用这个写法。&lt;/p&gt;

&lt;h2 id=&#34;简单的参考模板&#34;&gt;简单的参考模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 等同于std::lower_bound
template &amp;lt;typename ITER, typename V&amp;gt;
ITER bin_search_lower(ITER begin, ITER end, const V &amp;amp;val) {
  ITER l = begin - 1, r = end;
  while (l + 1 &amp;lt; r) {
    ITER m = l + (r - l) / 2;
    if (*m &amp;lt; val) {
      l = m;
    } else {
      r = m;
    }
  }
  return l;
}

// 等同于std::upper_bound
template &amp;lt;typename ITER, typename V&amp;gt;
ITER bin_search_upper(ITER begin, ITER end, const V &amp;amp;val) {
  ITER l = begin - 1, r = end;
  while (l + 1 &amp;lt; r) {
    ITER m = l + (r - l) / 2;
    if (*m &amp;lt;= val) {
      l = m;
    } else {
      r = m;
    }
  }
  return r;
}

// cmp为true表示这个数在val的左边，否则在右边
template &amp;lt;typename ITER, typename V, class COMP&amp;gt;
ITER bin_search(ITER begin, ITER end, const V &amp;amp;val, COMP cmp) {
  ITER l = begin - 1, r = end;
  while (l + 1 &amp;lt; r) {
    ITER m = l + (r - l) / 2;
    if (cmp(*m, val)) {
      l = m;
    } else {
      r = m;
    }
  }
  return l;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;扩展-更通用的写法&#34;&gt;扩展：更通用的写法&lt;/h2&gt;

&lt;p&gt;前面的写法只能使用随机迭代器，如果现在只有前向迭代器，那这写法就不行了。以下写法来自cppreference&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class ForwardIt, class T, class Compare&amp;gt;
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp;amp; value, Compare comp)
{
  ForwardIt it;
  typename std::iterator_traits&amp;lt;ForwardIt&amp;gt;::difference_type count, step;
  count = std::distance(first, last);
 
  while (count &amp;gt; 0) {
    it = first;
    step = count / 2;
    std::advance(it, step);
    if (comp(*it, value)) {
      first = ++it;
      count -= step + 1;
    }
    else
      count = step;
  }
  return first;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，更通用意味着自己写时更容易出问题，尽量直接用STL不自己手写那是最好的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算3——快速傅里叶/数论变换及分治除法</title>
      <link>/post/20210320-bigint3/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210320-bigint3/</guid>
      <description>&lt;p&gt;在上一篇介绍了基础优化算法后，本篇介绍更复杂的内容。本篇的三大内容：FFT，NTT，分治除法。中文资料中我尚未发现有博客文章在介绍分治除法的，所以我就来写&lt;del&gt;第一个&lt;/del&gt;介绍吧。&lt;/p&gt;

&lt;h2 id=&#34;fft-schönhage-strassen-algorithm&#34;&gt;FFT (Schönhage–Strassen algorithm)&lt;/h2&gt;

&lt;p&gt;FFT就是快速傅里叶变换的缩写，FFT这里不重点介绍，参见&lt;a href=&#34;https://oi-wiki.org/math/poly/fft/&#34; target=&#34;_blank&#34;&gt;oiwiki中对FFT的介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用比较显浅且简要的方式来介绍的话，FFT可以在$O(nlogn)$时间里（注：严格来说应该是$O(nlognloglogn)$，&lt;a href=&#34;https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/The%20Design%20and%20Analysis%20of%20Computer%20Algorithms%20%5BAho%2C%20Hopcroft%20%26%20Ullman%201974-01-11%5D.pdf&#34; target=&#34;_blank&#34;&gt;论文链接在这&lt;/a&gt;，在274页7.8处开始证明）求出两个多项式的乘积，而大整数乘法就可以视为两个整数系数的多项式的积再处理进位即可。那这样就产生一个问题，如果这个大整数采用的基数base，且长度为n，那么多项式的积的最大值可能会达到$n(base-1)^2$，因为FFT采用浮点运算，那么这个最大值必须在double的精度内，所以如果采用万进制，那么很容易导致精度不足进而结果错误，另外，还有求单位复根时的误差也会让它提早出现结果错误。实际应用的时候，一般采用10进制来增加长度的上限。所以如果你的大整数采用压位表示，那么在运用FFT之前，要先做拆位拆成10进制。总之，因为浮点精度的问题，不建议在大整数实现里使用FFT，建议采用下文要介绍的NTT来代替。所以这里对FFT的优化不做介绍，重心放在NTT上。&lt;/p&gt;

&lt;h2 id=&#34;ntt&#34;&gt;NTT&lt;/h2&gt;

&lt;p&gt;NTT就是快速数论变换，它和FFT很像，但它在整数域上做变换，具体数学介绍参见&lt;a href=&#34;https://oi-wiki.org/math/poly/ntt/&#34; target=&#34;_blank&#34;&gt;oiwiki中对NTT的介绍&lt;/a&gt;。由于没有浮点数参与，于是没有精度上的问题。&lt;/p&gt;

&lt;p&gt;NTT里面有两个重要的数，一个是原根g，通常取3，另一个是素数p，通常取1004535809或998244353，之所以取这两个素数是因为3都是它们的原根，此外，这个素数p必须是形如$2^nm+1$，像$1004535809-1=2^{21} \times 479,\ 998244353-1=2^{23} \times 119$，而这个n限制了变换时的最大长度为$2^n$。在NTT变换的结果里，最大值可能会达到$n(base-1)^2$，为了保证这个值没有因为求解过程中被求模变小了，就要限制$n(base-1)^2 &amp;lt; p$，即这个大整数的最大长度n满足$n &amp;lt; \lfloor\dfrac{p}{(base-1)^2}\rfloor$且$n = 2^k$，那么比如说我们取p为998244353，然后用万进制，得到n的最大值是8！？只有8还用什么呢，我们换换，改用10进制，那可以算得n的最大值是$2^{23}=8388608$，这个长度就比较实用了，如果用万进制做拆位，那这个最大长度就是$2^{21}=2097152$，对付数据范围在1e6以内的题目是足够了。&lt;/p&gt;

&lt;p&gt;但是，在实际使用时，要是真出现比这还要长的数怎么办？这个倒不难解决，先用前一篇文章的分治乘法，拆成原来的一半长度，直到满足NTT的使用上限时，再使用NTT即可。&lt;/p&gt;

&lt;p&gt;但以上这还不是本文要讲的重点，以上方法需要做拆位，拆位的常数能优化得更小吗？或者说，如果我坚持要使用万进制的话，NTT还能用吗？重新考虑一开始的限制，那个限制的原因，是最大值可能大于等于p，导致在模运算下失去了原来的值，那么，如果我们使用两个不同的p，最后用中国剩余定理来还原实际值呢，假设这2个素数是p1和p2，分别取1004535809和998244353，这样的话上限就是$p1p2=1002772198720536577$，在这个条件下用万进制的话，长度即使上100亿也不会越界，如果用65536进制的话长度也能达2亿，已经远远超过那个素数p本身带来的限制，完全足够使用了。不过代价是需要多做一次NTT变换，但比起万进制拆位拆成4个来比较，常数还是更小的。而且，即使不拆位，直接用10进制，速度也还是比不过使用双素数万进制。&lt;/p&gt;

&lt;p&gt;方案有了，接下来又有新问题，就是要解这个数论方程$z = xp_1 + c_1 = yp_2 + c_2 \ (x,y,z \in N)$&lt;/p&gt;

&lt;p&gt;直接用中国剩余定理可解，先求出$p_1$在$p_2$下的逆元$i_1$以及$p_2$在$p_1$下的逆元$i_2$，那么$z = (c_1i_1p_1+c_2i_2p_2) \ mod \ p_1p_2$&lt;/p&gt;

&lt;p&gt;注意到，我们的p是在1e9附近，于是就出问题了，$c_1i_1p_1$的结果可能会达到1e27，爆掉了int64，当然如果你选的p比$2^{21}$小，那就不至于溢出，但长度又受限制了，那这时候怎么办？&lt;/p&gt;

&lt;p&gt;有一个办法是模仿快速幂的方式来求乘法的模，但这个方法常数很大，我们要找更好的方案。&lt;/p&gt;

&lt;p&gt;在《算法竞赛进阶指南》里面(page 6)就介绍了这么一段代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int64_t mul_mod(int64_t a, int64_t b, int64_t m) {
    a %= m;
    b %= m;
    int64_t c = (int64_t)((long double)a * b / m);
    int64_t ans = a * b - c * m;
    if (ans &amp;lt; 0)
        ans += m;
    else if (ans &amp;gt;= m)
        ans -= m;
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体原理就不介绍了，但要注意的一点问题是，比如在VS编译器上，&lt;code&gt;long double&lt;/code&gt;等于&lt;code&gt;double&lt;/code&gt;，那么a和b就需要同时小于$2^{53}$，即$n(base-1)^2 &amp;lt; 2^{53}$，否则产生的误差就不是后面一个if能解决得了的，那么比如你用65536进制，那么n的最大值只有$2^{21}=2097152$，这是要注意的点（嗯，没错，这就是我踩过的坑）。&lt;/p&gt;

&lt;p&gt;那再来，有没有办法避免这个问题？经过我一番资料搜索，还真有，那个同余方程还有另一种解法。先回顾一下原方程 $z = xp_1 + c_1 = yp_2 + c_2 \ (x,y,z \in N)$&lt;/p&gt;

&lt;p&gt;我们可以不直接求z，改成求y，那么 $y = (c_1 - c_2)i_2 \ mod \ p_1$&lt;/p&gt;

&lt;p&gt;于是不但完美避开int64的乘法求模，而且计算量更少，现在&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger项目&lt;/a&gt;中的实现就是使用这个方法。&lt;/p&gt;

&lt;p&gt;基本原理介绍完了，以下讲讲细节，在选取NTT的模p的时候，其实网上最常用的两个数1004535809和998244353并不是两个模的时候的最好的选择，通过暴力求解，最佳选择是$469762049=2^{26} \times 7 + 1,\ 167772161=2^{25} \times 5 + 1$，这个组合可以让最大长度达到$2^{25}$。&lt;/p&gt;

&lt;p&gt;不过在这里就不给出用NTT的写法模板了，具体实现细节及常数优化参见项目源代码。以下列举部分关键代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline ntt_base_t mul_mod(int64_t a, int64_t b) {
    return a * b % NTT_MOD;
}
ntt_base_t pow_mod(int64_t a, int64_t b) {
    int64_t ans = 1;
    a %= NTT_MOD;
    while (b) {
        if (b &amp;amp; 1) ans = ans * a % NTT_MOD;
        b &amp;gt;&amp;gt;= 1;
        a = a * a % NTT_MOD;
    }
    return (ntt_base_t)ans;
}
void transform(ntt_base_t a[], size_t len, int on) {
    for (size_t i = 0; i &amp;lt; len; i++) {
        if (i &amp;lt; ntt_r[i]) std::swap(a[i], a[ntt_r[i]]);
    }
    size_t id = 0;
    for (size_t h = 1; h &amp;lt; len; h &amp;lt;&amp;lt;= 1) {
        ntt_base_t wn = ntt_wn[on][++id];
        for (size_t j = 0; j &amp;lt; len; j += h &amp;lt;&amp;lt; 1) {
            ntt_base_t w = 1;
            size_t e = j + h;
            for (size_t k = j; k &amp;lt; e; k++, w = mul_mod(w, wn)) {
                ntt_base_t t = mul_mod(w, a[k + h]);
                a[k + h] = (a[k] - t + NTT_MOD) % NTT_MOD;
                a[k] = (a[k] + t) % NTT_MOD;
            }
        }
    }
    if (on == 0) {
        ntt_base_t inv = pow_mod(len, NTT_MOD - 2);
        for (size_t i = 0; i &amp;lt; len; i++)
            a[i] = mul_mod(a[i], inv);
    }
}
void mul_conv(size_t n) {
    transform(&amp;amp;ntt_a.front(), n, 1);
    transform(&amp;amp;ntt_b.front(), n, 1);
    for (size_t i = 0; i &amp;lt; n; i++)
        ntt_a[i] = mul_mod(ntt_a[i], ntt_b[i]);
    transform(&amp;amp;ntt_a.front(), n, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分治除法&#34;&gt;分治除法&lt;/h2&gt;

&lt;p&gt;没错，大整数除法也能分治，这很多人还不知道这点。并不只有牛顿迭代这一路线。&lt;del&gt;（也许本文是中文博客中第一篇介绍大整数的分治除法）&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;我们假设，相除的两个数表示为$\dfrac{a_1a_2a_3a_4}{b_1b_2}$，其中$a_1,a_2,a_3,a_4,b_1,b_2$看成是一个以$base^n$为基的“1位数字”，即看成是“4位数”除以“2位数”，并且，我们假设$b_1 \geq \dfrac{base^n}2$，接下来，我们就看成是模拟手算的除法，用前3位除以那个2位数，求出的余数便再来一次3位除以2位。而在3位除以2位时，我们需要的便是先试商，试商的方法是取被除数的最高2位除以除数的最高1位。因为我们在前面假设了$b_1 \geq \dfrac{base^n}2$ （这又叫做规则化），Knuth在TAOCP书中证明了在除数规则化后，可以证明这样试商的结果q&amp;rsquo;与实际商q的关系满足$q&amp;rsquo;-2 \leq q \leq q&amp;rsquo;$，所以最多只要对试商结果做2次减法修正便可。再看试商这一步，是“2位数”除以“1位数”，那我们就把原本以$base^n$为基，改为以$base^{n/2}$为基，于是就变成“4位数”除以“2位数”，便可以递归进行了。&lt;/p&gt;

&lt;p&gt;对于实际应用的时候，在使用分治法之前，要做两件事情，首先找出系数m，令除数B乘以m后，最高位的$b_1$尽可能接近且小于base，然后让被除数和除数，均乘以m，再开始做分治。计算完毕后，得到的余数只需要再除以m即可。另外，如果分治过程中出现B的位数是奇数，不能正好除以2时，那也没有关系，直接向下取整，那么多出来的1位就作为精度补充使用。&lt;/p&gt;

&lt;p&gt;再简单复述一篇，对于2n/n，降低base的指数，转为4n/2n，然后就是模拟手算，前3位除以2位，即3n/2n，需要这样除两个回合。而在3n/2n的时候，需要试商，试商时就是2n/n的除法，此步通过递归完成，除得的商修正个位数即可。&lt;/p&gt;

&lt;p&gt;但当然，这个分治法仍然有改进的余地，我的实现可能比较糟糕，是同长度乘法的约2到4倍时间，这个倍数取决于长度，即它的时间复杂度为$O(mlogn)$，其中n表示除数长度，m表示长度n的乘法的时间，所以在n较大的时候，用牛顿迭代会更好。以下是我的实现部分代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//返回右移后的结果
BigIntSimple shr_to(size_t n) const {
    BigIntSimple r;
    if (n &amp;gt;= v.size()) return r;
    r.v.assign(v.begin() + n, v.end());
    return r;
}

//对自身左移
BigIntSimple &amp;amp;shl(size_t n) {
    if (n == 0) return *this;
    v.insert(v.begin(), n, 0);
    return *this;
}

//分治除法递归部分
BigIntSimple &amp;amp;dividediv_recursion(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
    if (a &amp;lt; b) {
        r = a;
        return *this = BigIntSimple(0);
    } else if (b.v.size() &amp;lt;= 300) {
        return *this = a.div_mod(b, r);
    }
    size_t base = (b.v.size() + 1) / 2;
    //符合3/2时，进行试商
    if (a.v.size() &amp;lt;= base * 3) {
        base = b.v.size() / 2;
        BigIntSimple ma = a, mb = b, e;
        BigIntSimple ha = ma.shr_to(base);
        BigIntSimple hb = mb.shr_to(base);
        dividediv_recursion(ha, hb, r);
        ha = *this * b;
        while (a &amp;lt; ha) {
            ha.subtract(b);
            subtract(BigIntSimple(1));
        }
        r = a - ha;
        return *this;
    }
    //选择合适的base长度做分割
    if (a.v.size() &amp;gt; base * 4) base = a.v.size() / 2;
    BigIntSimple ha = a.shr_to(base);
    BigIntSimple c, d, m;
    dividediv_recursion(ha, b, d);
    shl(base);
    m.v.resize(base + d.v.size());
    for (size_t i = 0; i &amp;lt; base; ++i)
        m.v[i] = a.v[i];
    for (size_t i = 0; i &amp;lt; d.v.size(); ++i)
        m.v[base + i] = d.v[i];
    *this = *this + c.dividediv_recursion(m, b, r);
    return *this;
}

//分治除法规则化准备
BigIntSimple &amp;amp;dividediv(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
    if (b.v.size() &amp;lt;= 300) {
        return *this = a.div_mod(b, r);
    }
    //被除数不及两倍除数长度减2时，可以忽略一部分最低位且不影响结果
    if (b.v.size() * 2 - 2 &amp;gt; a.v.size()) {
        BigIntSimple ta = a, tb = b;
        size_t ans_len = a.v.size() - b.v.size() + 2;
        size_t shr = b.v.size() - ans_len;
        ta = ta.shr_to(shr);
        tb = tb.shr_to(shr);
        return dividediv(ta, tb, r);
    }
    //规则化
    int mul = (int)(((uint64_t)BIGINT_BASE * BIGINT_BASE - 1) /    //
        (*(b.v.begin() + b.v.size() - 1) * (uint64_t)BIGINT_BASE + //
            *(b.v.begin() + b.v.size() - 2) + 1));
    BigIntSimple ma = a * BigIntSimple(mul);
    BigIntSimple mb = b * BigIntSimple(mul);
    BigIntSimple d;
    ma.sign = mb.sign = 1;
    dividediv_recursion(ma, mb, d);
    r = d.div_mod(BigIntSimple(mul), ma);
    return *this;
}

BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
    BigIntSimple r, t;
    // t = div_mod(b, r);
    t.dividediv(*this, b, r);
    t.sign = sign * b.sign;
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bigintsimple类的完整代码&#34;&gt;BigIntSimple类的完整代码&lt;/h2&gt;

&lt;p&gt;事实上，代码写到这里，就已经和我在项目里实现的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger/blob/main/bigint_mini.h&#34; target=&#34;_blank&#34;&gt;bigint_mini&lt;/a&gt;没有什么区别了，直接看这个好了，主要区别就是少了进制转换输入输出，性能上也稍微差一丁点。完整代码有点长，近500行。&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; // 1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) { *this = n; }
    //判断是否为0
    bool iszero() const { return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0; }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero()) sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size()) return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i]) return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //分治进制转换输入
    BigIntSimple &amp;amp;_from_str(const std::string &amp;amp;s, int base) {
        //较短长度时直接计算，36^4 &amp;lt; 2^31，但取5就大于了，所以长度上限是4
        if (s.size() &amp;lt;= 4) {
            int v = 0;
            for (size_t i = 0; i &amp;lt; s.size(); ++i) {
                int digit = -1;
                if (s[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;9&#39;)
                    digit = s[i] - &#39;0&#39;;
                else if (s[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;Z&#39;)
                    digit = s[i] - &#39;A&#39; + 10;
                else if (s[i] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;z&#39;)
                    digit = s[i] - &#39;a&#39; + 10;
                v = v * base + digit;
            }
            return *this = v;
        }
        BigIntSimple m(base), h;
        size_t len = 1;
        //计算分割点
        for (; len * 3 &amp;lt; s.size(); len *= 2) {
            m = m * m;
        }
        h._from_str(s.substr(0, s.size() - len), base);
        _from_str(s.substr(s.size() - len), base);
        *this = *this + m * h;
        return *this;
    }
    //任意进制字符串输入（2~36进制）
    BigIntSimple &amp;amp;from_str(const char *s, int base = 10) {
        //特殊情况直接用原来的读入函数速度快
        if (base == 10) {
            set(s);
            return *this;
        }
        int vsign = 1, i = 0;
        while (s[i] == &#39;-&#39;) {
            ++i;
            vsign = -vsign;
        }
        _from_str(std::string(s + i), base);
        sign = vsign;
        return *this;
    }
    //字符串输出
    std::string to_dec() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }
    //递归分治进制转换输出
    std::string _to_str(int base, int pack) const {
        std::string s;
        //长度只剩下2时可以直接算
        if (v.size() &amp;lt;= 2) {
            int d = v[0] + (v.size() &amp;gt; 1 ? v[1] : 0) * BIGINT_BASE;
            do {
                int g = d % base;
                if (g &amp;lt; 10) {
                    s += char(g + &#39;0&#39;);
                } else {
                    s += char(g + &#39;a&#39; - 10);
                }
                d /= base;
            } while (d);
            //填充前导0
            while (s.size() &amp;lt; pack)
                s += &#39;0&#39;;
            std::reverse(s.begin(), s.end());
            return s;
        }
        BigIntSimple m(base), h, l;
        size_t len = 1; //计算余数部分要补的前导0
        //计算分割点
        for (; m.v.size() * 3 &amp;lt; v.size(); len *= 2) {
            m = m * m;
        }
        h = div_mod(m, l); //算出分割后的高位h和低位l
        s = h._to_str(base, std::max(pack - (int)len, 0));
        return s + l._to_str(base, len);
    }
    //任意进制（2~36进制）字符串输出
    std::string to_str(int base = 10) const {
        if (base == 10) {
            return to_dec();
        }
        std::string s;
        BigIntSimple m(*this);
        m.sign = 1;
        s = m._to_str(base, 0);
        return sign &amp;gt;= 0 ? s : &amp;quot;-&amp;quot; + s;
    }

    bool operator&amp;lt;(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return sign &amp;gt; 0 ? absless(b) : b.absless(*this);
        } else {
            return sign &amp;lt; 0;
        }
    }

    bool operator==(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return !absless(b) &amp;amp;&amp;amp; !b.absless(*this);
        }
        return false;
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty()) v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign) return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size()) r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }

    BigIntSimple &amp;amp;offset_add(const BigIntSimple &amp;amp;b, int offset) {
        //填充高位
        if (v.size() &amp;lt; b.v.size() + offset) v.resize(b.v.size() + offset);
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += v[i + offset] + b.v[i] - BIGINT_BASE;
            v[i + offset] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size() + offset; carry &amp;amp;&amp;amp; i &amp;lt; v.size(); ++i) {
            carry += v[i] - BIGINT_BASE;
            v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) v.push_back(carry);
        return *this;
    }

    BigIntSimple mul(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        return r;
    }

    BigIntSimple &amp;amp;fastmul(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b) {
        //小于某个阈值就直接用暴力乘法
        if (std::min(a.v.size(), b.v.size()) &amp;lt;= 300) {
            return *this = a.mul(b);
        }
        BigIntSimple ah, al, bh, bl, h, m;
        //计算分割点
        size_t split = std::max(                            //
            std::min((a.v.size() + 1) / 2, b.v.size() - 1), //
            std::min((b.v.size() + 1) / 2, a.v.size() - 1));
        //按分割点拆成4个数
        al.v.assign(a.v.begin(), a.v.begin() + split);
        ah.v.assign(a.v.begin() + split, a.v.end());
        bl.v.assign(b.v.begin(), b.v.begin() + split);
        bh.v.assign(b.v.begin() + split, b.v.end());
        //按公式递归计算
        fastmul(al, bl);
        h.fastmul(ah, bh);
        m.fastmul(al + ah, bl + bh);
        m.subtract(*this + h);
        v.resize(a.v.size() + b.v.size());

        offset_add(m, split);
        offset_add(h, split * 2);
        trim();
        return *this;
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        r.fastmul(*this, b);
        // r = mul(b);
        r.sign = sign * b.sign;
        return r;
    }

    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0) return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }

    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) + (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        return d;
    }

    //返回右移后的结果
    BigIntSimple shr_to(size_t n) const {
        BigIntSimple r;
        if (n &amp;gt;= v.size()) return r;
        r.v.assign(v.begin() + n, v.end());
        return r;
    }

    //对自身左移
    BigIntSimple &amp;amp;shl(size_t n) {
        if (n == 0) return *this;
        v.insert(v.begin(), n, 0);
        return *this;
    }

    //分治除法递归部分
    BigIntSimple &amp;amp;dividediv_recursion(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
        if (a &amp;lt; b) {
            r = a;
            return *this = BigIntSimple(0);
        } else if (b.v.size() &amp;lt;= 300) {
            return *this = a.div_mod(b, r);
        }
        size_t base = (b.v.size() + 1) / 2;
        //符合3/2时，进行试商
        if (a.v.size() &amp;lt;= base * 3) {
            base = b.v.size() / 2;
            BigIntSimple ma = a, mb = b, e;
            BigIntSimple ha = ma.shr_to(base);
            BigIntSimple hb = mb.shr_to(base);
            dividediv_recursion(ha, hb, r);
            ha = *this * b;
            while (a &amp;lt; ha) {
                ha.subtract(b);
                subtract(BigIntSimple(1));
            }
            r = a - ha;
            return *this;
        }
        //选择合适的base长度做分割
        if (a.v.size() &amp;gt; base * 4) base = a.v.size() / 2;
        BigIntSimple ha = a.shr_to(base);
        BigIntSimple c, d, m;
        dividediv_recursion(ha, b, d);
        shl(base);
        m.v.resize(base + d.v.size());
        for (size_t i = 0; i &amp;lt; base; ++i)
            m.v[i] = a.v[i];
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i)
            m.v[base + i] = d.v[i];
        *this = *this + c.dividediv_recursion(m, b, r);
        return *this;
    }

    //分治除法规则化准备
    BigIntSimple &amp;amp;dividediv(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
        if (b.v.size() &amp;lt;= 300) {
            return *this = a.div_mod(b, r);
        }
        //被除数不及两倍除数长度减2时，可以忽略一部分最低位且不影响结果
        if (b.v.size() * 2 - 2 &amp;gt; a.v.size()) {
            BigIntSimple ta = a, tb = b;
            size_t ans_len = a.v.size() - b.v.size() + 2;
            size_t shr = b.v.size() - ans_len;
            ta = ta.shr_to(shr);
            tb = tb.shr_to(shr);
            return dividediv(ta, tb, r);
        }
        //规则化
        int mul = (int)(((uint64_t)BIGINT_BASE * BIGINT_BASE - 1) /                //
                        (*(b.v.begin() + b.v.size() - 1) * (uint64_t)BIGINT_BASE + //
                         *(b.v.begin() + b.v.size() - 2) + 1));
        BigIntSimple ma = BigIntSimple(mul) * a;
        BigIntSimple mb = BigIntSimple(mul) * b;
        BigIntSimple d;
        ma.sign = mb.sign = 1;
        dividediv_recursion(ma, mb, d);
        r = d.div_mod(BigIntSimple(mul), ma);
        return *this;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r, t;
        // t = div_mod(b, r);
        t.dividediv(*this, b, r);
        t.sign = sign * b.sign;
        return t;
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const { return *this - *this / b * b; }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算2——乘法优化及进制转换</title>
      <link>/post/20210308-bigint2/</link>
      <pubDate>Mon, 08 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210308-bigint2/</guid>
      <description>&lt;p&gt;在上一篇介绍了基础算法后，本篇介绍算法级别的优化。本篇的三大内容：乘法优化，任意进制输入，任意进制输出。&lt;/p&gt;

&lt;h2 id=&#34;乘法优化&#34;&gt;乘法优化&lt;/h2&gt;

&lt;p&gt;这里要介绍的，是Karatsuba发现的分治法，我们假设要相乘的两个数，都有2n位，那么这两个数就可以分别表示为$a_1base^n+a_2, b_1base^n+b_2$，其中，$a_1,a_2,b_1,b_2$是n位的大整数，那么，它们的积就是&lt;/p&gt;

&lt;p&gt;$$\begin{align}
&amp;amp;   (a_1base^n+a_2) \times (b_1base^n+b_2) \\&lt;br /&gt;
&amp;amp; = a_1b_1base^{2n} + (a_1b_2+a_2b_1)base^n + a_2b_2 \\&lt;br /&gt;
&amp;amp; = a_1b_1base^{2n} + ((a_1+a_2)(b_1+b_2)-a_1b_1-a_2b_2)base^n + a_2b_2
\end{align}$$&lt;/p&gt;

&lt;p&gt;如果这样不够明显的话，我们用$c_1$代替$a_1b_1$，用$c_3$代替$a_2b_2$，得到&lt;/p&gt;

&lt;p&gt;$c_1base^{2n} + ((a_1+a_2)(b_1+b_2)-c_1-c_3)base^n + c_3$&lt;/p&gt;

&lt;p&gt;于是，这里一共有3次乘法，比起原来的4次暴力乘法减少了1次。而里面的乘法又可以进行递归优化，时间复杂度从$O(n^2)$下降到$O(n^{log_23})$约$O(n^{1.585})$&lt;/p&gt;

&lt;p&gt;当然，在实际应用时，这两个数不可能都正好一样的位，不过也不要紧，这个算法对分割点位置也没有要求，但当然分割位置尽可能在中间，效率越高，于是实际实现就会有一堆细节，这里就不做介绍了。只要在原有的模板里面增加移位加法操作，这个优化算法就能套上去用，用起来非常简单。以下就是在上文中对&lt;code&gt;BigIntSimple&lt;/code&gt;修改的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple &amp;amp;offset_add(const BigIntSimple &amp;amp;b, int offset) {
        //填充高位
        if (v.size() &amp;lt; b.v.size() + offset) v.resize(b.v.size() + offset);
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += v[i + offset] + b.v[i] - BIGINT_BASE;
            v[i + offset] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size() + offset; carry &amp;amp;&amp;amp; i &amp;lt; v.size(); ++i) {
            carry += v[i] - BIGINT_BASE;
            v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) v.push_back(carry);
        return *this;
    }

    BigIntSimple mul(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        return r;
    }

    BigIntSimple &amp;amp;fastmul(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b) {
        //小于某个阈值就直接用暴力乘法
        if (std::min(a.v.size(), b.v.size()) &amp;lt;= 300) {
            return *this = a.mul(b);
        }
        BigIntSimple ah, al, bh, bl, h, m;
        //计算分割点
        size_t split = std::max(
            std::min((a.v.size() + 1) / 2, b.v.size() - 1),
            std::min((b.v.size() + 1) / 2, a.v.size() - 1));
        //按分割点拆成4个数
        al.v.assign(a.v.begin(), a.v.begin() + split);
        ah.v.assign(a.v.begin() + split, a.v.end());
        bl.v.assign(b.v.begin(), b.v.begin() + split);
        bh.v.assign(b.v.begin() + split, b.v.end());
        //按公式递归计算
        fastmul(al, bl);
        h.fastmul(ah, bh);
        m.fastmul(al + ah, bl + bh);
        m.subtract(*this + h);
        v.resize(a.v.size() + b.v.size());
        offset_add(m, split);
        offset_add(h, split * 2);
        trim();
        return *this;
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        r.fastmul(*this, b);
        r.sign = sign * b.sign;
        return r;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个优化一加，那个10000阶乘的题目就轻松缩短到109ms。且代码不长，加起来轻松又愉快。&lt;/p&gt;

&lt;p&gt;类似地，以上优化算法是分成两路进行分治，如果分成三路，那么就叫做&lt;code&gt;Toom-3&lt;/code&gt;算法，时间复杂度为$O(n^{log_35})$约$O(n^{1.465})$，如果分成四路，那么就叫做&lt;code&gt;Toom-4&lt;/code&gt;算法，时间复杂度为$O(n^{log_47})$约$O(n^{1.404})$，Toom算法还有很多个变种，Karatsuba分治法其实就是Toom算法在n为2的情况。但很多时候，用Karatsuba已经足够了，除非你对性能有特别的追求。&lt;/p&gt;

&lt;h2 id=&#34;任意进制读入&#34;&gt;任意进制读入&lt;/h2&gt;

&lt;p&gt;所谓任意进制，如果用字符串输入，通常限定为2~36进制，当然如果你直接用数组作为输入，那确实可以支持任意进制。为了方便表述，以下假设你的大整数类使用base进制，输入是b进制，$base \neq b$。&lt;/p&gt;

&lt;p&gt;对于这个问题，最多人的想法是，按进制的定义直接加起来，假设输入是$s_ns_{n-1} \dots s_2s_1s_0$，那就求出$s_0+s_1b+s_2b^2+ \dots +s_nb^n$，再整理就得到$((\dots((s_n*b+s_{n-1}) *b+s_{n-2}) *b+\dots)+s_1) *b + s_0$，所以写一个循环，计算过程用这个大整数类即可。这样一共有n次乘法，而这里每次乘法是$O(n)$，所以整体复杂度是$O(n^2)$。&lt;/p&gt;

&lt;p&gt;但是，不能光看时间复杂度，来回忆一下在上一篇文章里，阶乘代码是怎么写的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BigIntSimple fac(int start, int n) {
    if (n &amp;lt; 16) {
        BigIntSimple s = 1;
        for (int i = start; i &amp;lt; start + n; ++i)
            s = BigIntSimple(i) * s;
        return s;
    }
    int m = (n + 1) / 2;
    return fac(start, m) * fac(start + m, n - m);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个写法丝毫没有减少&lt;code&gt;BigIntSimple&lt;/code&gt;之间做乘法的次数，但却比暴力乘法来的快，原因是什么？你有想过原因吗？&lt;/p&gt;

&lt;p&gt;假设有2n个小整数相乘，假设它们大小都在base附近，那么直接乘的话，那么小整数的乘法次数（即把大整数的乘法过程拆分来统计）就是&lt;/p&gt;

&lt;p&gt;$\sum\limits_{i=1}^{2n-1}{i} = n(2n-1) = 2n^2 - n$&lt;/p&gt;

&lt;p&gt;而我们分成两组，每组各n个先乘，再来做1次n位的乘法，那么总次数是&lt;/p&gt;

&lt;p&gt;$2\sum\limits_{i=1}^{n-1}{i} + n^2 = n(n-1) + n^2 = 2n^2 - n$&lt;/p&gt;

&lt;p&gt;完全没有差别！那再假设，它们的大小都在$\sqrt{base}$附近呢，那直接乘的话，是&lt;/p&gt;

&lt;p&gt;$\sum\limits_{i=1}^{2n-1}{\lceil\dfrac{i}{2}\rceil} = \dfrac{n(n-1)+n(n+1)}{2} = n^2$&lt;/p&gt;

&lt;p&gt;分组再乘是&lt;/p&gt;

&lt;p&gt;$2\sum\limits_{i=1}^{n-1}{\lceil\dfrac{i}{2}\rceil + (\dfrac{n}{2})^2} = \dfrac{n^2}{2} + \dfrac{n^2}{4} = \dfrac{3n^2}{4}$&lt;/p&gt;

&lt;p&gt;甚至直接分成n组，每组两两相乘&lt;/p&gt;

&lt;p&gt;$n + \sum\limits_{i=1}^{n-1}{i} = n + \dfrac{n(n-1)}{2} = \dfrac{n^2 + n}{2}$&lt;/p&gt;

&lt;p&gt;这回差别就产生了，也就是说，如果做多次小整数乘法（小整数的定义为小于base），那么通过分组便可以有效减少计算次数，而且，我们还可以进行递归分组来节省更多的时间，最终得到约$\dfrac{n^2}{2}$的计算量。而求阶乘正好满足这个条件，于是便有了这个求阶乘的优化代码，而且这个方法还可以拓展，用优先队列维护最小的两个，每次找最小的两个来相乘，用此法时间在那个阶乘题目里可以稍微减少到93ms。而且，转换成两个大整数相乘还能用上前面说的乘法优化节省更多的时间。&lt;/p&gt;

&lt;p&gt;那阶乘和这进制转换有啥关系啊？重新看看那个进制转换的循环过程，是不是有超多的小整数乘法？所以又可以分治了。&lt;/p&gt;

&lt;p&gt;找一个分割点n，且满足$n=2^k$，原输入分割为$a_1b^n+a_2$，其中$a_1,a_2$都是大整数，这样求出$b^n$只需要k次自乘，这样就把原输入分割为两小段，这两小段再分别做输入的进制转换，这就是一个递归。这k次自乘，相乘的两数必然是等长度的，可以非常好的利用乘法加速特性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    //分治进制转换输入
    BigIntSimple &amp;amp;_from_str(const std::string &amp;amp;s, int base) {
        //较短长度时直接计算，36^4 &amp;lt; 2^31，但取5就大于了，所以长度上限是4
        if (s.size() &amp;lt;= 4) {
            int v = 0;
            for (size_t i = 0; i &amp;lt; s.size(); ++i) {
                int digit = -1;
                if (s[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;9&#39;)
                    digit = s[i] - &#39;0&#39;;
                else if (s[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;Z&#39;)
                    digit = s[i] - &#39;A&#39; + 10;
                else if (s[i] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;z&#39;)
                    digit = s[i] - &#39;a&#39; + 10;
                v = v * base + digit;
            }
            return *this = v;
        }
        BigIntSimple m(base), h;
        size_t len = 1;
        //计算分割点
        for (; len * 3 &amp;lt; s.size(); len *= 2) {
            m = m * m;
        }
        h._from_str(s.substr(0, s.size() - len), base);
        _from_str(s.substr(s.size() - len), base);
        *this = *this + m * h;
        return *this;
    }
    //任意进制字符串输入（2~36进制）
    BigIntSimple &amp;amp;from_str(const char *s, int base = 10) {
        //特殊情况直接用原来的读入函数速度快
        if (base == 10) {
            set(s);
            return *this;
        }
        int vsign = 1, i = 0;
        while (s[i] == &#39;-&#39;) {
            ++i;
            vsign = -vsign;
        }
        _from_str(std::string(s + i), base);
        sign = vsign;
        return *this;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;任意进制输出&#34;&gt;任意进制输出&lt;/h2&gt;

&lt;p&gt;相信对于这个问题，如果那个数有n位，你不会考虑做n次除法吧，做n次除法的总时间复杂度是$O(n^3)$，一个一万位的大整数你要进制转换输出那你得计算到什么时候去。假设大整数类的基是base，要输出的进制是b，通过前一个输入的方案，你应该很容易想到做除法分割，这样下一次的长度就下降到n/2，即我们先求出分割点k，满足$log_{base}b^k \approx n/2$，原数是a的话，计算出$a_1=\lfloor\dfrac{a}{b^k}\rfloor, a_2=a\,mod\,b^k$，然后再分别对$a_1,a_2$做进制转换，最后$a_2$的结果视情况补充前导0后，与$a_1$的结果做字符串连接即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    //字符串输出
    std::string to_dec() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }
    //递归分治进制转换输出
    std::string _to_str(int base, int pack) const {
        std::string s;
        //长度只剩下2时可以直接算
        if (v.size() &amp;lt;= 2) {
            int d = v[0] + (v.size() &amp;gt; 1 ? v[1] : 0) * BIGINT_BASE;
            do {
                int g = d % base;
                if (g &amp;lt; 10) {
                    s += char(g + &#39;0&#39;);
                } else {
                    s += char(g + &#39;a&#39; - 10);
                }
                d /= base;
            } while (d);
            //填充前导0
            while (s.size() &amp;lt; pack)
                s += &#39;0&#39;;
            std::reverse(s.begin(), s.end());
            return s;
        }
        BigIntSimple m(base), h, l;
        size_t len = 1; //计算余数部分要补的前导0
        //计算分割点
        for (; m.v.size() * 3 &amp;lt; v.size(); len *= 2) {
            m = m * m;
        }
        h = div_mod(m, l); //算出分割后的高位h和低位l
        s = h._to_str(base, std::max(pack - (int)len, 0));
        return s + l._to_str(base, len);
    }
    //任意进制（2~36进制）字符串输出
    std::string to_str(int base = 10) const {
        if (base == 10) {
            return to_dec();
        }
        std::string s;
        BigIntSimple m(*this);
        m.sign = 1;
        s = m._to_str(base, 0);
        return sign &amp;gt;= 0 ? s : &amp;quot;-&amp;quot; + s;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法是有了，但问题是，这个方法并不够快，虽然复杂度确实下降到$O(n^2)$，但常数大，除法比乘法的常数大，而且除法不太好优化，但乘法的优化前面已经有了，有没有不需要除法的办法？有啊，考虑一下，既然输出是b进制，那么我们直接动态方式构造一个使用的base为$b^n$的大整数类，直接按前一个方法，把输出作为这个新大整数类的输入，这样输入完了再转了b进制输出不就只有乘法了。不过需要再另写一个类，这里不提供示例代码了，直接看项目代码吧，因为代码比较长。&lt;/p&gt;

&lt;p&gt;具体请参见&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger项目&lt;/a&gt;中BigIntBase的实现。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;最后，加上了乘法优化和任意进制输入输出的模板（用分治除法实现的输出）如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; // 1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) { *this = n; }
    //判断是否为0
    bool iszero() const { return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0; }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero()) sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size()) return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i]) return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //分治进制转换输入
    BigIntSimple &amp;amp;_from_str(const std::string &amp;amp;s, int base) {
        //较短长度时直接计算，36^4 &amp;lt; 2^31，但取5就大于了，所以长度上限是4
        if (s.size() &amp;lt;= 4) {
            int v = 0;
            for (size_t i = 0; i &amp;lt; s.size(); ++i) {
                int digit = -1;
                if (s[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;9&#39;)
                    digit = s[i] - &#39;0&#39;;
                else if (s[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;Z&#39;)
                    digit = s[i] - &#39;A&#39; + 10;
                else if (s[i] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;z&#39;)
                    digit = s[i] - &#39;a&#39; + 10;
                v = v * base + digit;
            }
            return *this = v;
        }
        BigIntSimple m(base), h;
        size_t len = 1;
        //计算分割点
        for (; len * 3 &amp;lt; s.size(); len *= 2) {
            m = m * m;
        }
        h._from_str(s.substr(0, s.size() - len), base);
        _from_str(s.substr(s.size() - len), base);
        *this = *this + m * h;
        return *this;
    }
    //任意进制字符串输入（2~36进制）
    BigIntSimple &amp;amp;from_str(const char *s, int base = 10) {
        //特殊情况直接用原来的读入函数速度快
        if (base == 10) {
            set(s);
            return *this;
        }
        int vsign = 1, i = 0;
        while (s[i] == &#39;-&#39;) {
            ++i;
            vsign = -vsign;
        }
        _from_str(std::string(s + i), base);
        sign = vsign;
        return *this;
    }
    //字符串输出
    std::string to_dec() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }
    //递归分治进制转换输出
    std::string _to_str(int base, int pack) const {
        std::string s;
        //长度只剩下2时可以直接算
        if (v.size() &amp;lt;= 2) {
            int d = v[0] + (v.size() &amp;gt; 1 ? v[1] : 0) * BIGINT_BASE;
            do {
                int g = d % base;
                if (g &amp;lt; 10) {
                    s += char(g + &#39;0&#39;);
                } else {
                    s += char(g + &#39;a&#39; - 10);
                }
                d /= base;
            } while (d);
            //填充前导0
            while (s.size() &amp;lt; pack)
                s += &#39;0&#39;;
            std::reverse(s.begin(), s.end());
            return s;
        }
        BigIntSimple m(base), h, l;
        size_t len = 1; //计算余数部分要补的前导0
        //计算分割点
        for (; m.v.size() * 3 &amp;lt; v.size(); len *= 2) {
            m = m * m;
        }
        h = div_mod(m, l); //算出分割后的高位h和低位l
        s = h._to_str(base, std::max(pack - (int)len, 0));
        return s + l._to_str(base, len);
    }
    //任意进制（2~36进制）字符串输出
    std::string to_str(int base = 10) const {
        if (base == 10) {
            return to_dec();
        }
        std::string s;
        BigIntSimple m(*this);
        m.sign = 1;
        s = m._to_str(base, 0);
        return sign &amp;gt;= 0 ? s : &amp;quot;-&amp;quot; + s;
    }

    bool operator&amp;lt;(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return sign &amp;gt; 0 ? absless(b) : b.absless(*this);
        } else {
            return sign &amp;lt; 0;
        }
    }

    bool operator==(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return !absless(b) &amp;amp;&amp;amp; !b.absless(*this);
        }
        return false;
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty()) v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign) return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size()) r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }

    BigIntSimple &amp;amp;offset_add(const BigIntSimple &amp;amp;b, int offset) {
        //填充高位
        if (v.size() &amp;lt; b.v.size() + offset) v.resize(b.v.size() + offset);
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += v[i + offset] + b.v[i] - BIGINT_BASE;
            v[i + offset] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size() + offset; carry &amp;amp;&amp;amp; i &amp;lt; v.size(); ++i) {
            carry += v[i] - BIGINT_BASE;
            v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) v.push_back(carry);
        return *this;
    }

    BigIntSimple mul(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        return r;
    }

    BigIntSimple &amp;amp;fastmul(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b) {
        //小于某个阈值就直接用暴力乘法
        if (std::min(a.v.size(), b.v.size()) &amp;lt;= 300) {
            return *this = a.mul(b);
        }
        BigIntSimple ah, al, bh, bl, h, m;
        //计算分割点
        size_t split = std::max(                            //
            std::min((a.v.size() + 1) / 2, b.v.size() - 1), //
            std::min((b.v.size() + 1) / 2, a.v.size() - 1));
        //按分割点拆成4个数
        al.v.assign(a.v.begin(), a.v.begin() + split);
        ah.v.assign(a.v.begin() + split, a.v.end());
        bl.v.assign(b.v.begin(), b.v.begin() + split);
        bh.v.assign(b.v.begin() + split, b.v.end());
        //按公式递归计算
        fastmul(al, bl);
        h.fastmul(ah, bh);
        m.fastmul(al + ah, bl + bh);
        m.subtract(*this + h);
        v.resize(a.v.size() + b.v.size());

        offset_add(m, split);
        offset_add(h, split * 2);
        trim();
        return *this;
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        r.fastmul(*this, b);
        r.sign = sign * b.sign;
        return r;
    }

    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0) return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }

    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                   (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const { return *this - *this / b * b; }
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算——有趣的实现</title>
      <link>/post/20210305-bigint_fun/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210305-bigint_fun/</guid>
      <description>&lt;p&gt;这里收录一些有意思的实现，不过我都有进行改编以更方便使用，不过千万不要指望这性能有多高。收录的条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持四则运算，必须包含除法及求余&lt;/li&gt;
&lt;li&gt;支持字符串输入输出&lt;/li&gt;
&lt;li&gt;代码不长&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;small-biginteger-library-for-contest&#34;&gt;small biginteger library for contest&lt;/h2&gt;

&lt;p&gt;代码原作者Jane Alam Jan，你可以在Google上直接搜索&lt;code&gt;small_biginteger_library_for_contest.pdf&lt;/code&gt;并下载到原始说明文档及代码，这里提供一份代码，改动不多，增加了int的构造函数和其它不等号的重载，乘法效率有优化，且增加输出到string而不直接输出终端，以便在其它场合使用更方便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Bigint {
    // representations and structures
    std::string a; // to store the digits
    int sign;      // sign = -1 for negative numbers, sign = 1 otherwise
    // constructors
    Bigint() {}                            // default constructor
    Bigint(std::string b) { (*this) = b; } // constructor for string
    Bigint(int v) {
        char buf[30];
        sprintf(buf, &amp;quot;%d&amp;quot;, v);
        (*this) = buf;
    }
    // some helpful methods
    int size() { return a.size(); } // returns number of digits
    Bigint inverseSign() {
        sign *= -1;
        return (*this);
    }
    Bigint normalize(int newSign) { // removes leading 0, fixes sign
        for (int i = a.size() - 1; i &amp;gt; 0 &amp;amp;&amp;amp; a[i] == &#39;0&#39;; i--)
            a.erase(a.begin() + i);
        sign = (a.size() == 1 &amp;amp;&amp;amp; a[0] == &#39;0&#39;) ? 1 : newSign;
        return (*this);
    }
    // assignment operator
    void operator=(std::string b) { // assigns a string to Bigint
        a = b[0] == &#39;-&#39; ? b.substr(1) : b;
        reverse(a.begin(), a.end());
        this-&amp;gt;normalize(b[0] == &#39;-&#39; ? -1 : 1);
    }
    // conditional operators
    bool operator&amp;lt;(const Bigint &amp;amp;b) const { // less than operator
        if (sign != b.sign) return sign &amp;lt; b.sign;
        if (a.size() != b.a.size()) return sign == 1 ? a.size() &amp;lt; b.a.size() : a.size() &amp;gt; b.a.size();
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            if (a[i] != b.a[i]) return sign == 1 ? a[i] &amp;lt; b.a[i] : a[i] &amp;gt; b.a[i];
        return false;
    }
    bool operator==(const Bigint &amp;amp;b) const { return a == b.a &amp;amp;&amp;amp; sign == b.sign; }
    // mathematical operators
    Bigint operator+(Bigint b) { // addition operator overloading
        if (sign != b.sign) return (*this) - b.inverseSign();
        Bigint c;
        for (int i = 0, carry = 0; i &amp;lt; a.size() || i &amp;lt; b.size() || carry; i++) {
            carry += (i &amp;lt; a.size() ? a[i] - 48 : 0) + (i &amp;lt; b.a.size() ? b.a[i] - 48 : 0);
            c.a += (carry % 10 + 48);
            carry /= 10;
        }
        return c.normalize(sign);
    }
    Bigint operator-(Bigint b) { // subtraction operator overloading
        if (sign != b.sign) return (*this) + b.inverseSign();
        int s = sign;
        sign = b.sign = 1;
        if ((*this) &amp;lt; b) return ((b - (*this)).inverseSign()).normalize(-s);
        Bigint c;
        for (int i = 0, borrow = 0; i &amp;lt; a.size(); i++) {
            borrow = a[i] - borrow - (i &amp;lt; b.size() ? b.a[i] : 48);
            c.a += borrow &amp;gt;= 0 ? borrow + 48 : borrow + 58;
            borrow = borrow &amp;gt;= 0 ? 0 : 1;
        }
        return c.normalize(s);
    }
    Bigint operator*(Bigint b) { // multiplication operator overloading
        if (b &amp;lt; *this) return b * *this;
        Bigint c(&amp;quot;0&amp;quot;);
        for (int i = 0, k = a[i] - 48; i &amp;lt; a.size(); i++, k = a[i] - 48) {
            while (k--)
                c = c + b;                // ith digit is k, so, we add k times
            b.a.insert(b.a.begin(), &#39;0&#39;); // multiplied by 10
        }
        return c.normalize(sign * b.sign);
    }
    Bigint operator/(Bigint b) { // division operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;), d;
        for (int j = 0; j &amp;lt; a.size(); j++)
            d.a += &amp;quot;0&amp;quot;;
        int dSign = sign * b.sign;
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b, d.a[i]++;
        }
        return d.normalize(dSign);
    }
    Bigint operator%(Bigint b) { // modulo operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;);
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b;
        }
        return c.normalize(sign);
    }
    std::string to_str() const {
        std::string s;
        if (sign == -1) s += &#39;-&#39;;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            s += a[i];
        return s;
    }
    bool operator&amp;gt;(const Bigint &amp;amp;b) const { return b &amp;lt; *this; }
    bool operator&amp;lt;=(const Bigint &amp;amp;b) const { return !(b &amp;lt; *this); }
    bool operator&amp;gt;=(const Bigint &amp;amp;b) const { return !(*this &amp;lt; b); }
    bool operator!=(const Bigint &amp;amp;b) const { return !(*this == b); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现使用string来实现大整数，于是缺点就非常明显了，就是性能低下，求个2000阶乘用时0.7秒，2000位的除法平均用时0.2秒（在mingw下开O2），但对于商全是9的情况下用时0.5秒。不过，这代码里有不少写法是牺牲性能换代码长度，有的思路确实也不错。在同样代码长度级别下，我实现的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger/blob/main/bigint_tiny.h&#34; target=&#34;_blank&#34;&gt;BigIntTiny&lt;/a&gt;有着好得多的性能（2000阶乘用时0.03秒，2000位的除法0.02秒）。&lt;/p&gt;

&lt;h2 id=&#34;一份70行不到的大整数实现&#34;&gt;一份70行不到的大整数实现&lt;/h2&gt;

&lt;p&gt;改编自&lt;a href=&#34;https://wu-kan.cn/_posts/2019-01-26-%E9%AB%98%E7%B2%BE%E5%BA%A6/&#34; target=&#34;_blank&#34;&gt;wu-kan&lt;/a&gt;以及&lt;a href=&#34;https://zhuanlan.zhihu.com/p/72730434&#34; target=&#34;_blank&#34;&gt;hqztrue&lt;/a&gt;的基于bitset实现的定长大整数（对定长长度除以3.322就可得到对应的最大10进制位数），支持10进制输入输出，四则运算及位运算均支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;string&amp;gt;

#define BINT_MAXSIZE (1&amp;lt;&amp;lt;15)
typedef typename std::bitset&amp;lt;BINT_MAXSIZE&amp;gt; Bint;
bool operator&amp;lt;(const Bint &amp;amp;a, const Bint &amp;amp;b) {
    for (int i = a.size() - 1; i &amp;gt;= 0; --i)
        if (a[i] != b[i]) return a[i] &amp;lt; b[i];
    return false;
}
bool operator&amp;gt;(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b &amp;lt; a; }
bool operator&amp;lt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(b &amp;lt; a); }
bool operator&amp;gt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(a &amp;lt; b); }
Bint operator+(Bint a, Bint b) {
    while (b.any()) {
        Bint c = (a &amp;amp; b) &amp;lt;&amp;lt; 1;
        a ^= b, b = c;
    }
    return a;
}
Bint operator-(const Bint &amp;amp;a) { return Bint(1) + ~a; }
Bint operator-(Bint a, Bint b) {
    while (b.any()) {
        Bint c = (~a &amp;amp; b) &amp;lt;&amp;lt; 1;
        a ^= b, b = c;
    }
    return a;
}
Bint operator*(Bint a, Bint b) {
    if (a &amp;lt; b) return b * a;
    Bint r(0);
    for (; b.any(); b &amp;gt;&amp;gt;= 1, a &amp;lt;&amp;lt;= 1) if (b[0]) r = r + a;
    return r;
}
std::pair&amp;lt;Bint, Bint&amp;gt; divide(Bint a, const Bint &amp;amp;b) {
    Bint c = 0;
    int i = 0;
    while (b &amp;lt;&amp;lt; (i + 1) &amp;lt;= a) ++i;
    for (; i &amp;gt;= 0; --i)
        if (a &amp;gt;= (b &amp;lt;&amp;lt; i)) a = a - (b &amp;lt;&amp;lt; i), c.set(i, 1);
    return std::make_pair(c, a);
}
Bint operator/(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).first; }
Bint operator%(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).second; }
Bint BintFromStr(const char *p) {
    Bint x = 0;
    int sign = 1;
    for (; *p == &#39;-&#39;; ++p) sign = -sign;
    for (; *p &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; *p &amp;lt;= &#39;9&#39;; ++p) x = (x &amp;lt;&amp;lt; 3) + (x &amp;lt;&amp;lt; 1) + (*p - &#39;0&#39;);
    return sign &amp;gt; 0 ? x : -x;
}
Bint BintFromInt(int i) {
    char buf[20];
    sprintf(buf, &amp;quot;%d&amp;quot;, i);
    return BintFromStr(buf);
}
std::string BintToStr(Bint x) {
    std::string out = x == 0 ? &amp;quot;0&amp;quot; : &amp;quot;&amp;quot;;
    std::vector&amp;lt;Bint&amp;gt; v;
    if (x[x.size() - 1]) out += &#39;-&#39;, x = -x;
    for (Bint y = 1; y &amp;lt;= x; y = (y &amp;lt;&amp;lt; 3) + (y &amp;lt;&amp;lt; 1)) v.push_back(y);
    for (int i = v.size() - 1; i &amp;gt;= 0; --i) {
        int t = 0;
        for (int l = 3; l &amp;gt;= 0; --l)
            if (x &amp;gt;= (v[i] &amp;lt;&amp;lt; l)) x = x - (v[i] &amp;lt;&amp;lt; l), t += 1 &amp;lt;&amp;lt; l;
        out += t + &#39;0&#39;;
    }
    return out;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现的代码就短到极致了（原始代码更短，但为了解决较长长度时的递归溢出只好多写几行），但性能同样也挺糟糕的，而且负数支持不佳（做除法会出错，需要自己转为正数做除法，或者可以自己写个类封装一下来解决这个问题），还有一个缺点是受bitset所限只能定长，但部分运算性能上比上一份略好，例如说设置长度为&lt;code&gt;1&amp;lt;&amp;lt;15&lt;/code&gt;，求2000阶乘用时0.4秒，但2000位除法用时0.7秒。但对于长度较短的时候不失为一个简易实现。所以这个适用于临时用用的大整数，对于只有加法和乘法运算时会更优于前一个。&lt;/p&gt;

&lt;h2 id=&#34;其它的github库实现&#34;&gt;其它的Github库实现&lt;/h2&gt;

&lt;p&gt;以下是我在Github找到的平均性能表现较好的一些小型实现，已经按平均性能进行排序（优先按1万位以内的乘法和除法运算性能进行排序&lt;del&gt;，才没有打广告&lt;/del&gt;）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;Baobaobear/MiniBigInteger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kedixa/klibcpp&#34; target=&#34;_blank&#34;&gt;kedixa/klibcpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ron4fun/BigIntegerCPP&#34; target=&#34;_blank&#34;&gt;ron4fun/BigIntegerCPP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square1001/bigint-library&#34; target=&#34;_blank&#34;&gt;square1001/bigint-library&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个只能在x64平台且只能用支持AT&amp;amp;T内联汇编编译器(如GCC/clang)的实现 &lt;a href=&#34;https://github.com/calebsander/bigint&#34; target=&#34;_blank&#34;&gt;calebsander/bigint&lt;/a&gt;，它的加减法和小规模乘法速度确实飞快，比前面列举到的都快，但受编译环境限制较大。&lt;/p&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;p&gt;以上两份代码于2021/06/22有修改，优化了乘法效率，解决递归溢出，同时更新测试结果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算1——基础算法</title>
      <link>/post/20210228-bigint1/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210228-bigint1/</guid>
      <description>&lt;p&gt;最近在编写大整数库的过程中，踩到不少的坑，于是把一些有用的细节准备写成文章做整理。如果你只是想直接查找并使用一个大整数库，那直接上GMP即可，如果是用在比赛，那直接用我的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger项目&lt;/a&gt;，如果你是想学习个中细节，那你可以坐下来细品。&lt;/p&gt;

&lt;p&gt;所谓大整数，又叫高精度运算，就是运算对象是上千位甚至到百万位，总之远远超过内置数据类型的表示范围，这类数字都叫大整数。而C/C++的标准库里目前并没有大整数库，于是这个轮子被反复制造了无数个，不过在github上比较有质量的轮子并没有很多。本文除了介绍基础实现，主要还是介绍优化方法。&lt;/p&gt;

&lt;h2 id=&#34;大整数的表示&#34;&gt;大整数的表示&lt;/h2&gt;

&lt;p&gt;大整数的表示方法最常见的有4种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接使用string&lt;/li&gt;
&lt;li&gt;使用定长数组(仅适用于竞赛)&lt;/li&gt;
&lt;li&gt;使用链表&lt;/li&gt;
&lt;li&gt;使用变长线性表例如vector&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;直接用string的方式适合初学者，输入输出直观，但缺点也非常明显，因为计算时需要在字符与数值之间来回转换，浪费太多不必要的时间，效率会非常差。不过如果你是初学者，先用string表示法来写未尝不是个好主意。但有个细节就是，如果想要效率高，最好把string前后倒置调整为低位在前再做运算，这样速度和实现难度都会低一些。&lt;/p&gt;

&lt;p&gt;至于使用链表，好处是变长容易，变短也不难，但性能比用string的更差还更难写，这里就不谈了，以下介绍使用数组的表示法&lt;/p&gt;

&lt;p&gt;为了在数组里表示一个大整数，如果我们采用10进制，表示&lt;code&gt;123456789&lt;/code&gt;，那很简单，例如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int a[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即&lt;code&gt;a[0]&lt;/code&gt;表示个位，&lt;code&gt;a[1]&lt;/code&gt;表示十位，如此类推。之所以这样做，是希望同一个位置的元素的含义是固定的，这样能简化后面的算法编写。&lt;/p&gt;

&lt;p&gt;但是，对于计算机来说，这样表示实在是太浪费空间和时间，我们还可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int a[] = {6789, 2345, 1};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，采用10000进制，那么这个10000叫做&lt;code&gt;基数&lt;/code&gt;或&lt;code&gt;base&lt;/code&gt;。我们还可以视情况使用其它的基数，例如使用$2^{16}$或$2^{32}$等等。对于这种我们原始进制是b的情况，但通过更大的基数$b^n$来表示的方法，叫做&lt;code&gt;压位高精度&lt;/code&gt;，n就是压的位数。压位高精度的运算效率远超非压位。&lt;/p&gt;

&lt;p&gt;以下我们用万进制来做一步步的演示，首先定义出这个类，在这里我用vector来保存（没有必要采用定长数组，因为效率没啥区别，除非你的OJ就不给加&lt;code&gt;O2&lt;/code&gt;优化例如某谷或参加某些信息竞赛）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; //1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是这里有一个问题，0怎么表示？在这里规定0的sign为1，且v的长度为1，这种约定可以在后期简化一些代码。当然你也可以规定v的长度为0，你怎么约定就怎么写代码即可。&lt;/p&gt;

&lt;h2 id=&#34;大整数的基本运算&#34;&gt;大整数的基本运算&lt;/h2&gt;

&lt;p&gt;实现一个功能还算得上完整的大整数，需要的基本运算有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;比较运算&lt;/li&gt;
&lt;li&gt;字符串输入&lt;/li&gt;
&lt;li&gt;字符串输出&lt;/li&gt;
&lt;li&gt;加法&lt;/li&gt;
&lt;li&gt;减法&lt;/li&gt;
&lt;li&gt;乘法&lt;/li&gt;
&lt;li&gt;除法及求余&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-比较运算&#34;&gt;1. 比较运算&lt;/h3&gt;

&lt;p&gt;大整数的比较很简单，先判断符号，符号不同再看位数，位数不同再从最高位一位一位比就行。但是我们其实更需要一个按绝对值比较的函数（后面的运算会需要它），那么先写一个无视符号的比较版本，再在运算符重载处判断符号即可。&lt;/p&gt;

&lt;h3 id=&#34;2-字符串输入输出&#34;&gt;2. 字符串输入输出&lt;/h3&gt;

&lt;p&gt;对于输入输出的字符串进制与该大整数的基相同时，输入输出直接映射转换即可，对于不同进制的输入输出在后面再做介绍，以下是实现了输入输出及一些基础功能的版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; //1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) {
        *this = n;
    }
    //判断是否为0
    bool iszero() const {
        return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0;
    }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero())
            sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size())
            return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i])
                    return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //字符串输出
    std::string to_str() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0)
            s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty())
            v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下文的介绍为了不重复，就不带上以上的代码了&lt;/p&gt;

&lt;h3 id=&#34;3-加法和减法&#34;&gt;3. 加法和减法&lt;/h3&gt;

&lt;p&gt;加法和减法都挺简单，核心思想就是模拟手工竖式，手工怎么算它就怎么算。要注意的点就是符号的处理。&lt;/p&gt;

&lt;p&gt;另外，还有一些小优化，加法进位的时候，这个if是可以简单省略掉的，用求模和除法运算即可。即当前位是&lt;code&gt;sum % base&lt;/code&gt;，进位是&lt;code&gt;sum / base&lt;/code&gt;。示例代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i];
            r.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但减法就没这么简单了，这时候还可以利用位运算来区分正负，比如，我们用当前位是&lt;code&gt;sum - (sum &amp;gt;&amp;gt; 31) * base&lt;/code&gt;，因为如果sum是负数，那么&lt;code&gt;sum &amp;gt;&amp;gt; 31&lt;/code&gt;在sum是int时就等于-1，相当于&lt;code&gt;sum + base&lt;/code&gt;；而如果sum是非负数，那么&lt;code&gt;sum &amp;gt;&amp;gt; 31&lt;/code&gt;就是0，结果就相当于&lt;code&gt;sum&lt;/code&gt;，这样就成功实现了&lt;code&gt;sum&amp;lt;0 ? sum+base : sum&lt;/code&gt;的逻辑。而这种方法同样可以用在加法上。另外，在较新的CPU上除法的性能比较高的时候，加法这种改进写法就会被淘汰。&lt;/p&gt;

&lt;p&gt;其它的细节在以下代码的注释中有标注&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign)
            return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size())
            r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry)
            r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign)
            return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-乘法&#34;&gt;4. 乘法&lt;/h3&gt;

&lt;p&gt;本文不区分高精度乘以低精度，和高精度乘以高精度，下文的除法也一样，因为实在没有这个必要分开写，以下直接介绍的是高精度乘以高精度。&lt;/p&gt;

&lt;p&gt;乘法可以看成在加法外面再套一层循环，内循环相比加法多了一个偏移和一个乘法。但是由于进位的值不会只是1，所以那个位运算方法在这里不能使用，只能用求模了。以下直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        //r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; //m用来缓存乘数
            //carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        r.sign = sign * b.sign;
        return r;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-除法和求余&#34;&gt;5. 除法和求余&lt;/h3&gt;

&lt;p&gt;除法是高精度的基础算法里面变化最多的，也是基础算法里面最难的，网上也有很多不同的写法，顺带说一说一些误区，同时这里提供一个我自己的写法，不过此法有限制条件，但在限制条件内应该是模拟手工的方法里面速度较快的。&lt;/p&gt;

&lt;p&gt;第一种就是暴力整体二分，然后做乘法验证（或者利用二进制一位一位来确定，但却不使用移位减法，而使用整体相乘），这时候，设是2n位除以n位，那么二分的次数就是n，然后一次乘法是n^2，所以整体复杂度是$O(n^3)$，这是一个非常糟糕的方法，虽然写起来似乎更简单，但时间上还不如直接模拟，千万不要做整体二分。类似地还有二分开方，也是$O(n^3)$。&lt;/p&gt;

&lt;p&gt;在模拟手工除法时，最关键的就是试商的部分，试商方法有很多，最简单的方式是用减法，先判断余数是不是大于等于除数，如果是，就做一次减法。这个写法确实容易，但问题是效率低下，除非你用的基数特别小，比如不压位10进制，这样速度还能看，甚至乎你用的是$2^n$进制，直接每个位枚举。&lt;/p&gt;

&lt;p&gt;那我们来个二分呢？如果在每一位上分别二分，那在基数较大的时候比做减法好一些，但还是不够好，我们还需要更快的方案，进一步减少试商次数。&lt;/p&gt;

&lt;p&gt;假设被除数有4个位，是$a_4,a_3,a_2,a_1$，除数有3个位，是$b_3,b_2,b_1$，那么我们只要试一位的商（多个位就是一位的写法加个循环），假如我们用$\dfrac{a_4 base+a_3}{b_3}$来试商，结果一定大于等于实际的商，但同时这会有一个问题，就是假如b2等于&lt;code&gt;base-1&lt;/code&gt;，那会导致试商与实际的商误差非常大，例如&lt;code&gt;9999,0000&lt;/code&gt;除以&lt;code&gt;1,9999&lt;/code&gt;，直接用高位除得到9999，但这远超过实际商了，修正商的代价也不小。于是，我们想到，在&lt;code&gt;base&lt;/code&gt;不太大的情况下，我们可以通过增加位数来估商，这样误差就会小得多。比如说我们用$\dfrac{a_4 base^2 + a_3 base + a_2}{b_3 base + b_2}$来试商，精度确实会大为提高，而且商的误差最多只有1，但缺点是，$a_4 base^2$的结果超出int的范围了，不过我们还可以用double。注意到，上式中a2对结果并没有任何影响，所以可以变形为$\dfrac{a_4 base + a_3}{b_3 + b_2/base}$。另外，我不希望这个估商总比实际商大，我们希望是小于等于实际商，这样在试后一位的时候，这个结果能自然得到修正，就增加了试商的效率，于是可以把式子改为$\dfrac{a_4 base + a_3}{b_3 + (b_2+1)base^{-1}}$，但这个+1导致误差增大，与实际商的误差最大达到2，那解决方法很简单，我们再增加1位的精度，得到式子$\dfrac{a_4 base + a_3}{b_3 + b_2 base^{-1} + (b_1+1)base^{-2}}$，于是便得到接下来在代码中所使用的算法。由于误差不超过1，如果估小了，那在下一位的估商时候就会产生补回去的效果，于是不必重复试商。这个方法要求&lt;code&gt;base&amp;lt;=32768&lt;/code&gt;以避免各种溢出，在满足此条件下，因为每个位均只需要估一次，那么其时间常数与乘法相比，和减法与加法常数比是几乎相同的。&lt;/p&gt;

&lt;p&gt;但是，有一个非常极端的情况，既然商最大误差是1，那么相当于余数的最大误差就等于除数，那如果除数特别大呢？举个例子，求&lt;code&gt;9999,9999,9999,9999/9999,9999,9999&lt;/code&gt;，用上面的方法，高一位的试商结果是0，次一位的试商是9999（实际商是10000），相减得到余数&lt;code&gt;1,0000,0000,9998&lt;/code&gt;，结果最高位并没有减到0，于是不能继续移位，需要在同一位再一次试商。但虽然在同一位试商两次，但后一位就不用做减法了，均摊还是n次。&lt;/p&gt;

&lt;p&gt;算法有了，该处理细节了，除法需要一个减法函数，不过这个函数对借位的处理和之前的减法可不一样，因为可能一次借n个，那就产生了一个问题：对负数求模。负数求模的结果和正数很不一样，所以如果还是要避免if做判断处理，那就要再换个方法，我承认我很菜，花了很久时间才想到这个法子，实现如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0)
            return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码关键点就是这两行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;核心思想是通过减去base统一在负数段求模后，再加上base回来，这样也达到避免if，避免if的写法比带if的写法时间上可以节省一半，不清楚有没有性能更好的做法。以下为除法及求余的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                    (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        div_mod(b, r);
        return r;
        //return *this - *this / b * b;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;求余就不说了，有求商之后代码仅一行&lt;code&gt;return *this - *this / b * b&lt;/code&gt;，而且这样写与C语言规则一致，模与被除数符号相同。当然以上代码实现的&lt;code&gt;div_mod&lt;/code&gt;函数本身就把商和余数同时求出，就可以直接调用而少了乘法和减法。&lt;/p&gt;

&lt;p&gt;但是，现在系统几乎都是64位的，于是在64位下我们就应该考虑更大的base，例如说使用亿进制，最大限度利用64位带来的性能提升。但是，如果我们使用大的base，那么考虑到double的精度，前面的试商法就失效了，甚至于连base的平方都超出double能精确表示的范围，那这时候应该怎么办呢？为了方便描述，这里我们假设用的是$2^{n}$进制，且n&amp;gt;=18，而double的尾数是53位，于是$log_2base^3=3n=54&amp;gt;53$，这就是令原问题失效的边界。但是，我们真的需要3n长度的尾数吗？确实并不需要，我们的base的精度是n位，只需要再增加k位，只要n+k到53还有一些距离就行，把这个数看成是浮点数，同样地，把被除数和除数都看成浮点数，那我们的除数如何进行+1操作呢？比如说除数表示为$b_3b_2b_1$，那我们让$b_3$右移n+k位加上去，不就相当于+1了。这个方法需要考虑到下一个数估商超过base大小的情况，所以要注意base不能超过$2^{30}$，如果你要使用$2^{32}$，那又得换一个办法了。在实际操作中，我令k=n/2，这样操作起来更为方便，具体请参阅我的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger&lt;/a&gt;项目。&lt;/p&gt;

&lt;h2 id=&#34;完整模板&#34;&gt;完整模板&lt;/h2&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; // 1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) { *this = n; }
    //判断是否为0
    bool iszero() const { return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0; }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero()) sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size()) return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i]) return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //字符串输出
    std::string to_str() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }

    bool operator&amp;lt;(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return sign &amp;gt; 0 ? absless(b) : b.absless(*this);
        } else {
            return sign &amp;lt; 0;
        }
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty()) v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign) return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size()) r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        r.sign = sign * b.sign;
        return r;
    }

    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0) return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }

    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                   (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const {
        return *this - *this / b * b;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;经测试，这个实现在1秒内可以计算出30000阶乘，而计算10000阶乘不到0.1秒，附上求阶乘的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BigIntSimple fac(int start, int n) {
    if (n &amp;lt; 16) {
        BigIntSimple s = 1;
        for (int i = start; i &amp;lt; start + n; ++i)
            s = BigIntSimple(i) * s;
        return s;
    }
    int m = (n + 1) / 2;
    return fac(start, m) * fac(start + m, n - m);
}

int main() {
    int n;
    while (cin &amp;gt;&amp;gt; n) {
        cout &amp;lt;&amp;lt; fac(1, n).to_str() &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在hdu oj 1042上，&lt;a href=&#34;https://vjudge.net/solution/29867142&#34; target=&#34;_blank&#34;&gt;以171ms通过&lt;/a&gt;，在提交记录里面，超过了大部分其它提交。当然这还不是极限。&lt;/p&gt;

&lt;p&gt;对于除法，2n/n所需要时间与n*n所需时间比大约是1.5（n是位数），不同编译器这个比值稍有不同。&lt;/p&gt;

&lt;p&gt;本基础篇就介绍到这里，后文将介绍乘法和除法的优化。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>很头疼拼图</title>
      <link>/post/20210118-htt/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210118-htt/</guid>
      <description>&lt;p&gt;本拼图难度较高，是给程序解答专用的题目（手工解我觉得没多少可能，但不排除有运气极佳的人），是检验你的程序效率有多高用的。&lt;/p&gt;

&lt;p&gt;它的名字是很头疼拼图，因为放入的块有H和两种T形状，而HTT就是很头疼。一共有21个块，放入一个12x12的框里，具体形状如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/htt.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是12x12。全部21块放入即成功解出，每一块均可以任意平移、旋转、翻转。你需要确定本题有多少个本质不同的解及相应具体答案。答案就不在这公开了，祝玩得开心。&lt;/p&gt;

&lt;p&gt;其实还没完，以下还有一题加强版&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/1149.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;名字叫1149，取自每种形状的块数，全部共15块，都放入12x12的框内即可。同样的，你需要确定本题有多少个本质不同的解及相应具体答案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dancing Links 跳舞链</title>
      <link>/post/20210111-dlx/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210111-dlx/</guid>
      <description>&lt;p&gt;Dancing Links缩写为DLX，其实在竞赛中并不常见，这次会讲这个是因为前一阵子搞拼图写了这个数据结构就顺便写(&lt;del&gt;水&lt;/del&gt;)博客。&lt;/p&gt;

&lt;p&gt;DLX的发明者是高德纳（Donald Knuth），就是那个传说中的《计算机程序设计艺术》（TAOCP）系列书的作者，这里对这个算法做一些比较直观的解释。&lt;/p&gt;

&lt;h2 id=&#34;dlx面向的问题&#34;&gt;DLX面向的问题&lt;/h2&gt;

&lt;p&gt;DLX面向的问题是精确覆盖问题。何谓精确覆盖呢，来看以下这个表格，每一行是一个数组，数组有4个元素，每行的第一列是这个数组的名字&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们的目标是，在这些集合里，挑出几个，例如我们挑a,b,c，那对应位置上的元素相加，于是得到 &lt;code&gt;2 1 0 2&lt;/code&gt;。而我们的目标是，找到一个挑选的方法，使得相加得到 &lt;code&gt;1 1 1 1&lt;/code&gt; 全是1。&lt;/p&gt;

&lt;p&gt;例如说，选 d和g，那么相加正好得到 &lt;code&gt;1 1 1 1&lt;/code&gt; ，这就是其中一个解，这就是精确覆盖问题的直观感知。&lt;/p&gt;

&lt;h2 id=&#34;朴素算法的构思&#34;&gt;朴素算法的构思&lt;/h2&gt;

&lt;p&gt;我们来一把朴素DFS，例如说，先选择了集合a，而集合a在第4列是个1，那么，其它在第4列同样是1的集合之后就不用再看了，把这些行统统删除，在剩下的行中再选取一行，如此递归进行。我们会发现，怎么选取那一行，以及怎么样高效删除和恢复列，对这个搜索过程的效率有着关键性的影响。&lt;/p&gt;

&lt;h2 id=&#34;dlx的数据结构&#34;&gt;DLX的数据结构&lt;/h2&gt;

&lt;p&gt;在学习稀疏矩阵的时候，我们有一个表示稀疏矩阵的数据结构，就是十字链表，十字链表的优点是可以快速删除一行或一列。DLX就是使用十字链表表示这个矩阵。然后就是行的选取方式上，随便选一行目标性不佳。你如果玩过数独，那你可能会感觉这有点像数独，如果某一列，只有一个1，那么对应的含1的行，就确定一定是它了。而如果没有这种情况，我们就去找某一列只有两个1的。换句话来说，我们会从某一列中，含有最少的1的个数的列，来选择含有1的行。&lt;/p&gt;

&lt;p&gt;为了能快速知道某一列的1的数量，那必须增加一个头部记录这个信息。再者，某些列删除后，我们也需要快速找到还没有删除的列，所以之前的表格可以换成以下的表示：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;head&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中，head那一行包含在十字链表内，但不参与覆盖计算，仅用于索引还没有删除的列。而size是一个数组，不在十字链表内。所以列有表头，但行没有，head行是双向链表不循环，末尾元素的right指向空，其它的每一行是一个双向循环链表，而列是双向链表不循环，最底下的元素的down指向空。当然以上你也可以全做成循环的链表，稍微调整一下循环的结束条件即可。&lt;/p&gt;

&lt;h2 id=&#34;dlx的删除与恢复&#34;&gt;DLX的删除与恢复&lt;/h2&gt;

&lt;p&gt;通常，在链表里如果删除一个元素，那么被删的元素的指针要改为指向空。但是，在DLX里面不需要改，不改的好处就是能够用这个指针进行恢复操作。我们用双向链表来模拟一下删除和恢复的过程，以下是5个元素的初始状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0--&amp;gt;1
1--&amp;gt;0
1--&amp;gt;2
2--&amp;gt;3
3--&amp;gt;4
4--&amp;gt;5
2--&amp;gt;1
3--&amp;gt;2
4--&amp;gt;3
5--&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除节点2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
subgraph main
0--&amp;gt;1
1--&amp;gt;0
1--&amp;gt;3
3--&amp;gt;4
4--&amp;gt;5
3--&amp;gt;1
4--&amp;gt;3
5--&amp;gt;4
end
subgraph deleted
2--&amp;gt;3
2--&amp;gt;1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除节点3&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
subgraph main
0--&amp;gt;1
1--&amp;gt;0
1--&amp;gt;4
4--&amp;gt;5
4--&amp;gt;1
5--&amp;gt;4
end
subgraph deleted
2--&amp;gt;3
2--&amp;gt;1
3--&amp;gt;4
3--&amp;gt;1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除节点4&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
subgraph main
0--&amp;gt;1
1--&amp;gt;0
1--&amp;gt;5
5--&amp;gt;1
end
subgraph deleted
2--&amp;gt;3
2--&amp;gt;1
3--&amp;gt;4
3--&amp;gt;1
4--&amp;gt;5
4--&amp;gt;1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，要恢复的时候，如果先恢复节点4，再恢复3，最后2，那么就正好得到上图的逆序，就不重复展示了。但是如果，我们先恢复2，再是4，最后3，那会发生什么呢？来看看如果先恢复2，恢复就是让这个节点原本两端指针指向的元素重新指向自己，于是得到下图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
subgraph main
0--&amp;gt;1
1--&amp;gt;0
1--&amp;gt;2
5--&amp;gt;1
end
subgraph deleted
2--&amp;gt;3
2--&amp;gt;1

3--&amp;gt;4
3--&amp;gt;2
4--&amp;gt;5
4--&amp;gt;1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有点怪怪的，先不管，再恢复4&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
subgraph main
0--&amp;gt;1
1--&amp;gt;0
1--&amp;gt;4
5--&amp;gt;4
2--&amp;gt;1
end
subgraph deleted
2--&amp;gt;3

3--&amp;gt;4
3--&amp;gt;2
4--&amp;gt;5
4--&amp;gt;1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后恢复3&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
subgraph main
0--&amp;gt;1
1--&amp;gt;0
5--&amp;gt;4
2--&amp;gt;1
end
subgraph z
2-.-&amp;gt;3

3--&amp;gt;4
3--&amp;gt;2
4--&amp;gt;5
4--&amp;gt;3
1--&amp;gt;4
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果2到3这条边多赋值了一次，这里用虚线表示。但这不重要，重要的是链表数据结构已经错了，从1指向4这条边没有恢复成1指向2。所以，这里有个很简单的原则，恢复的时候要完全逆序，千万不能打乱顺序。&lt;/p&gt;

&lt;h2 id=&#34;dlx具体应用之拼图&#34;&gt;DLX具体应用之拼图&lt;/h2&gt;

&lt;p&gt;所谓的精确覆盖其实是一类问题，具体问题有像8皇后问题，伤脑筋13块，智慧珠游戏，数独游戏都是典型的精确覆盖问题。为了方便说明，我们简化成以下问题：&lt;/p&gt;

&lt;p&gt;有一块1x2和2x2的方块，怎么拼成一个3x2的矩形&lt;/p&gt;

&lt;p&gt;这个怎么用DLX来解呢，首先我们要先对这个3x2的矩形编号：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后，给1x2这个方块编号7，2x2这个方块编号8，所以我们有8列。然后穷举每个块可以摆放的位置，每一种情况就作为一行，那位置覆盖的矩形编号就对应十字链表中的列：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;sz&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;前7行就是1x2这个块的所有情况，8和9行就是2x2这个块的所有情况。&lt;/p&gt;

&lt;p&gt;表格做出来了，解法也很简单，看，第8列1的个数最少，那先选第8行，然后删除第8行上是1的所有列，然后只剩下第7行，于是找到第一个解{7,8}。然后第8列如果选另一行，即第9行，然后删除第9行上是1的所有列，然后只剩下第5行，于是找到第二个解{5,9}。于是所有解就都找到了。&lt;/p&gt;

&lt;h2 id=&#34;dlx应用之n皇后问题&#34;&gt;DLX应用之n皇后问题&lt;/h2&gt;

&lt;p&gt;在棋盘上任意位置放一个皇后，相当于同时覆盖了棋盘这一行、这一列、相应的/斜线、相应的\斜线。而n*n的棋盘，有n行n列和2n-1条斜线，所以做成表格将有6n-2列，n^2行，每行恰有4个1。具体表示这里不写了，因为页面宽度不够。&lt;/p&gt;

&lt;h2 id=&#34;dlx应用之数独问题&#34;&gt;DLX应用之数独问题&lt;/h2&gt;

&lt;p&gt;和n皇后问题类似，考虑在某个格子写了一个数k，那么相当于同时覆盖了这一行的数字k，列数字k，这个3x3区域的数字k，所以表格列数是&lt;code&gt;9*9*3&lt;/code&gt;，表格行数是&lt;code&gt;9*9*9&lt;/code&gt;，每一行都恰有3个1。初始化这个表格后，数独问题本身有一些初始数字，我们就根据这些数字，找到它所属的行，把这些行有1的列统统删掉，再执行搜索即可。&lt;/p&gt;

&lt;h2 id=&#34;dlx的剪枝&#34;&gt;DLX的剪枝&lt;/h2&gt;

&lt;p&gt;剪枝有两类，一种是看实际问题需求产生的剪枝，另一类是与具体问题无关可以在DLX上通用的剪枝。&lt;/p&gt;

&lt;h3 id=&#34;通用剪枝&#34;&gt;通用剪枝&lt;/h3&gt;

&lt;p&gt;假如不存在某一行全是1（99.9%的问题都不应该有吧），那这个剪枝就可以使用。在开始DFS搜索之前，我们如果先选定一行，然后把它有1的列删除，然后看有没有列的1的数量为0，如果有，那么这一行一定不可能在解里面，那么就可以把这一行从链表里直接删除干净，这样直到没有这样的无效行再去启动搜索即可。这个剪枝对于规模更大的问题求所有解时，加速效果明显。&lt;/p&gt;

&lt;h3 id=&#34;特定问题的剪枝&#34;&gt;特定问题的剪枝&lt;/h3&gt;

&lt;p&gt;对于正方形拼图，有个很明显的点，就是当你随便发现一个解时，那它翻转、旋转便会得到另外7个解，我们希望可以去掉这些镜像解，只保留本质不同的解。那么，我们可以记录四角的编号，例如矩形是3*3时，它的编号就是1,3,7,9，另外再增加一个字段，记录覆盖这一列的时候是选取的哪一行。这样当我们在搜索的过程中覆盖到这些列的时候，就可以启动单调性剪枝，我们定义1号用的行最小，3号比7号要小，如果与定义的不同，那就可以直接return，这样不但搜索时间减少不少，而且得到本质解的数量，一举两得。对于非正方形的矩形，或其它对称形状也有类似方法，可以去掉至少一半的重复解。&lt;/p&gt;

&lt;h2 id=&#34;原始dlx算法的局限&#34;&gt;原始DLX算法的局限&lt;/h2&gt;

&lt;p&gt;原始DLX算法最害怕的东西有两个，一是有大量的行极相似，二是有大量的行上面1的数量太少（&amp;lt;=2），这对应于具体问题是什么情况呢，例如说我之前博文的Orz14拼图，它不是精确覆盖，但可以转为精确覆盖问题，只需要补上17个1x1方块即可，但是这样的话，DLX的搜索时间是完全不可接受的，这个拼图同时满足了前面的两个条件，因为有大量的块形状完全一样，那么生成的行每行都有另外13行与之极相似，会导致相同的覆盖方式重复搜索，重复量级约 $14!$ ，好像不是特别多，其实要这么想，如果去重复后计算时间要1秒，那不去重复就需要 $14! = 87178291200$ 秒或者说2700多年。另外由于要补上的1x1方块非常多，而这些1x1方块在每一行只有2个1，同样也产生了 $17!$ 的重复，所以原始算法不适合解决这种问题，必须对其进行改进，或更换其它搜索方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小恐龙拼图</title>
      <link>/post/20210101-dino/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210101-dino/</guid>
      <description>&lt;p&gt;本拼图难度较高，同时作为2021新年的起点！&lt;/p&gt;

&lt;p&gt;它的名字是小恐龙拼图，因为需要连同右边小恐龙形状的拼图块一起放入，一共有11个块，放入一个12x12的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/dino.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是12x12。全部11块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>101010拼图</title>
      <link>/post/20201231-101010/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201231-101010/</guid>
      <description>&lt;p&gt;前两个拼图最多算热个身，难度不高，真正有点挑战的是以下这个，作为2020的纪念&lt;/p&gt;

&lt;p&gt;它的名字是101010，因为需要把10个块放入一个10x10的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/101010.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是10x10。右边的块每一块都写了x2，表示有两块完全一样的形状，全部10块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10个问号拼图</title>
      <link>/post/20201214-10question/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201214-10question/</guid>
      <description>&lt;p&gt;刷题经常搞得自己一脸问号，就想到弄一个由问号组成的拼图，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/10question.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由10块一样的形似问号组合而成，所以我命名为&lt;code&gt;10个问号&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是10x10。要求把右边的“十”无重叠放入到10个问号里，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orz14拼图</title>
      <link>/post/20201123-orz14puzzle/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201123-orz14puzzle/</guid>
      <description>&lt;p&gt;为了表达对大佬的膜拜，特设计一款拼图，由14个近似Orz形状的小块组合而成，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/orz14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由14块一样的小块组合而成，所以我命名为&lt;code&gt;Orz14&lt;/code&gt;，同时也有Orz一直到4的含义。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是11x11。要求把右边的绿色小块也一并无重叠放入，这一块就代表大佬，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解迷建模</title>
      <link>/post/20201023-puzzle/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201023-puzzle/</guid>
      <description>&lt;p&gt;这次来聊点简单的，也许你偶尔有机会在地摊上看到有人摆了一堆解锁玩具，这回我们通过建模来解决当中属于迷宫类型的玩具。&lt;/p&gt;

&lt;h2 id=&#34;魔金-円&#34;&gt;魔金·円&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk - Solved.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一图是初始状态，第二图是解开后各自的形状。为了更能理解接下来我说的，最好当然是你手上有一个一样的。&lt;/p&gt;

&lt;p&gt;但是，事实上可以存在两种不同的初始状态，其路线也略不相同，以下会做说明。&lt;/p&gt;

&lt;h3 id=&#34;编码&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;稍微操作几下，我们就会发现，它的操作很简单，它的边缘有一上一下，在中间的孔也有一左一右，即边缘的宽度小于等于中间的孔时，就可穿过一格。我们把它如下图摆放(俯视图)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这两个disks都有一个特点，有一个孔特别长，这两个孔交错时为初始位置。我们把这个特殊的孔编号为0，然后这个孔中间一左一右大小不同，我们按小的为主方向，于是上图左边的disk从0号孔开始顺时针编码1到6，右边的disk从0号孔开始也是顺时针编码1到6。由于都是顺时针，我称它为同向的初始状态（还有一种是反向的）。&lt;/p&gt;

&lt;p&gt;再来看，左边的disk从0孔到1孔顺时针方向的边是粗的（如下图红色圈），但右边的disk从0孔到1孔顺时针方向的边是细的（如下图蓝色圈），这也决定这两个disk是不同的，在这规定顺时针方向下粗的是disk a，细的是disk b，且a总是放左边，b放右边，如图的交错方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;观察完毕后，为了方便写成代码，我们开始对disk a进行状态描述，如下图，对孔1为例子，取它的顺时针方向的边与它作为一组，按图上次序编码，窄的为0，宽的取1&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后按定义好的方向，进行编码，得到如下的编码表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int disk_shape[2][7][4] = {
    {
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 0},
        {1, 0, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
    },
    {
        {1, 0, 0, 1},
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 1, 0},
    },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了编码，接下来的事情就是判断哪些位置能做操作了。对于每一个位置，我们都有对&lt;code&gt;disk a&lt;/code&gt;顺时针和逆时针，对&lt;code&gt;disk b&lt;/code&gt;顺时针和逆时针共4种操作，那直接写成代码并打印，看看哪些可以即可。&lt;/p&gt;

&lt;h3 id=&#34;具体代码&#34;&gt;具体代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int st_map[7][7][4];

void genmap()
{
    int disk_shape[2][7][4] = {
        {
            {1, 0, 1, 0},
            {0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 1},
        },
        {
            {1, 0, 0, 1},
            {0, 1, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 0, 0},
            {0, 0, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 1, 0},
        },
    };
    for (int dl = 0; dl &amp;lt; 7; ++dl)
    {
        for (int dr = 0; dr &amp;lt; 7; ++dr)
        {
            char s[5] = &amp;quot;    &amp;quot;;
            // 反向
            /*
            if (disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][2])
               s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][2])
               s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            // 同向
            //*
            if (disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][3])
                s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][3])
                s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            printf(&amp;quot;%4s,&amp;quot;, s);
        }
        puts(&amp;quot;&amp;quot;);
    }
}

int main()
{
    genmap();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是UD对应&lt;code&gt;disk a&lt;/code&gt;的操作，LR对应&lt;code&gt;disk b&lt;/code&gt;的操作&lt;/p&gt;

&lt;h3 id=&#34;结果&#34;&gt;结果&lt;/h3&gt;

&lt;p&gt;我把运行结果导入到表格并对可移动的路径进行染色，结果如下（黄色的是起点和终点状态，深绿色是最短路径）&lt;/p&gt;

&lt;h4 id=&#34;同向&#34;&gt;同向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;反向&#34;&gt;反向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来的事情就简单了，路径明显不唯一，只要按定义操作，怎么走都可以，两种方向均最短15步。&lt;/p&gt;

&lt;h2 id=&#34;魔金-磁&#34;&gt;魔金·磁&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它也是个迷宫，它有两个小环，开口处有一边有个小齿，这导致了这两个小环的路线是不一样的。&lt;/p&gt;

&lt;h3 id=&#34;编码-1&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;首先，小环横跨两个区域，那么我们对区域进行编号，且规定图上可见的面为正面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后，两个小环规定，齿在正面时，开口所占区域为十位，另一区域为个位，于是，初始状态分别是09和90（十位的0不能省略）&lt;/p&gt;

&lt;p&gt;但是这个由于比较复杂，编码的时间可能比手动列出状态还麻烦，所以我直接手动把所有的状态做成表格&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet_s.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表格中前两行，表示该状态可以跳转到哪些状态，第三行表示该状态距离解出还需要的步数。每一格的红色数字表示向此数字走能最快到达出口。蓝色表示向还原的方向，没有蓝色时按红色数字的方向。&lt;/p&gt;

&lt;p&gt;特殊情况是30这个状态，即第三行第0列，它移动到20或36，分别能移动到两种不同的初始状态。&lt;/p&gt;

&lt;p&gt;蓝色和橙色格子表示两条不同状态的路线，而绿色表示这两条路线的公共部分。&lt;/p&gt;

&lt;p&gt;但是，记忆这个表太难，且操作起来不是太舒服，唯一好处就是任意情况都能处理。为了快速解开或复原，我加了一个方便操作的数字串：&lt;/p&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;p&gt;90：6-3-52-0-3- 25-2-4-587-0-0&lt;br /&gt;
09：-8-7-5-8-6-523-0 25-2-4-587-0-0&lt;/p&gt;

&lt;p&gt;还原：&lt;/p&gt;

&lt;p&gt;90：7-4-852-5-3-20 -2-3-56-0-9&lt;br /&gt;
09：7-4-852-5-3-20 6-258-5-7-8-0-9&lt;/p&gt;

&lt;p&gt;规定初始状态是小环开口小齿在正面，减号表示小环自身转90度，数字表示移动小环其中一则到此区域。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;这种方法只能对比较规范的puzzle进行建模，我看到网上似乎没有针对这两而做的解法视频，所以我就做了一个建模版本，把路线图形化，这样比起单纯一个正解视频，你可以知道任意情况下怎么解，这个是优点。不过缺点是你得花点时间去理解它是怎么编码的。好久没更新了，所以来写点特别的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>回文树</title>
      <link>/post/20200416-pam/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0800</pubDate>
      <guid>/post/20200416-pam/</guid>
      <description>&lt;p&gt;回文树（EER Tree，Palindromic Tree），有点类似Trie，但它并不是匹配字符串的，很多人称之为回文自动机，但它一点也不像自动机，不过我还是按习惯的来，使用PAM为简称。为了表示一个回文，我们只表示一边的一个单链即可，这时就类似Trie。但不同之处是，回文区分奇数长度和偶数长度，所以这里我们使用两个根，分别来表示奇数长度和偶数长度。所以，在奇数根里，链ba表示aba，而在偶数根里的ba表示abba。&lt;/p&gt;

&lt;p&gt;首先我们来直观地看看PAM的图形化，以下是字符串&lt;code&gt;abcbbc&lt;/code&gt;的PAM&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node0
0--&amp;gt;6((bb))
6--&amp;gt;7((cbbc))
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
4--&amp;gt;5((bcb))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
6-.-&amp;gt;3
5-.-&amp;gt;3
7-.-&amp;gt;4
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实线方向就是子节点方向，虚线是fail指针，指向这个节点最长的回文后缀节点。图有点乱，但又不希望画得过于简单导致说不清楚，将就一下吧。&lt;/p&gt;

&lt;p&gt;为了能顺利构造，每个节点上面要存储以下必要数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;next: 类似Trie，表示子结点的指针，即图上实线&lt;/li&gt;
&lt;li&gt;fail: fail指针，即图上虚线&lt;/li&gt;
&lt;li&gt;len: 这个节点所表示的回文串的长度&lt;/li&gt;
&lt;li&gt;cnt: 这个节点所表示的回文串在原串中出现的次数&lt;/li&gt;
&lt;li&gt;num: 这个节点所表示的回文串中，有多少个后缀也是回文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;构造方法有点类似AC自动机或SAM，它用增量式构造，假设前k个字符已经构造好，最后构造的节点假设是&lt;code&gt;aba&lt;/code&gt;，新加的字符是&lt;code&gt;c&lt;/code&gt;，那么我们通过那个节点，获取长度是3，于是判断一下原字符串在&lt;code&gt;aba&lt;/code&gt;的前面的字符看是不是和新字符一样，如果是，就在它下面新加入节点，否则，就跳到它的fail节点再做相同的判断，其实这个比SAM简单多了。&lt;/p&gt;

&lt;h2 id=&#34;pam构造过程模拟&#34;&gt;PAM构造过程模拟&lt;/h2&gt;

&lt;p&gt;我们使用字符串&lt;code&gt;abcbbc&lt;/code&gt;作为开始，首先先把abc都插入&lt;/p&gt;

&lt;h3 id=&#34;1-插入abc&#34;&gt;1 插入abc&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-再插入b&#34;&gt;2 再插入b&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
4--&amp;gt;5((bcb))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
5-.-&amp;gt;3
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新增加的b构成bcb回文，于是加在c后面，而fail指针的查找，就是从c的fail节点开始，判断那个节点对称的位置是不是新增加的字符b，是的话连上，不是的话再向上一层的fail节点继续找。&lt;/p&gt;

&lt;h3 id=&#34;3-再插入b&#34;&gt;3 再插入b&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node0
0--&amp;gt;6((bb))
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
4--&amp;gt;5((bcb))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
6-.-&amp;gt;3
5-.-&amp;gt;3
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而最后插入a后的结果和开头的图是相同的，这里不重复了&lt;/p&gt;

&lt;h2 id=&#34;关于节点计数&#34;&gt;关于节点计数&lt;/h2&gt;

&lt;p&gt;这个节点计数，就是前面所说的cnt，即此节点所表示的回文在整个串中出现次数，但这个并不是一次性统计好的，要分两步。首先，在创建回文树过程中的节点计数，然后就是从叶子开始，把自己的cnt数值加到它的fail节点上，为什么是做加法呢，例如节点&lt;code&gt;ababa&lt;/code&gt;，它的fail节点表示的必然是&lt;code&gt;aba&lt;/code&gt;，那么在构建的过程中，每次遇到&lt;code&gt;ababa&lt;/code&gt;的左侧三个字母的时候，就会把cnt加到&lt;code&gt;aba&lt;/code&gt;节点上，而缺少的另一半，正是节点&lt;code&gt;ababa&lt;/code&gt;的出现次数。另外有的博客说cnt是本质不同的回文字符串数量，这是不正确的。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct PAM
{
    struct node
    {
        map&amp;lt;char, int&amp;gt; next;
        int fail, len, cnt, num;
        node(int l = 0) : len(l), fail(0), cnt(0), num(0) {}
    };
    vector&amp;lt;char&amp;gt; s;
    vector&amp;lt;node&amp;gt; nodes;
    int match_p;
    void init(int size)
    {
        s.clear();
        s.reserve(size + 1);
        s.push_back(&#39;\200&#39;);
        nodes.push_back(node());
        nodes.push_back(node(-1));
        nodes[0].fail = 1;
        match_p = 0;
    }
    int getfail(int x)
    {
        while (s[s.size() - nodes[x].len - 2] != s.back())
            x = nodes[x].fail;
        return x;
    }
    void extend(char c)
    {
        s.push_back(c);
        int p = getfail(match_p);
        if (!nodes[p].next.count(c))
        {
            int ch = nodes.size();
            nodes.push_back(node(nodes[p].len + 2));
            nodes[ch].fail = nodes[getfail(nodes[p].fail)].next[c];
            nodes[p].next[c] = ch;
            nodes[ch].num = nodes[nodes[ch].fail].num + 1;
        }
        match_p = nodes[p].next[c];
        nodes[match_p].cnt++;
    }
    void done()
    {
        for (int i = nodes.size() - 1; i &amp;gt; 0; i--)
            nodes[nodes[i].fail].cnt += nodes[i].cnt;
    }
    void build(const char* s)
    {
        init(strlen(s));
        for (;*s;++s) extend(*s);
        done();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接调用build即可，得到的nodes就是回文树&lt;/p&gt;

&lt;h2 id=&#34;pam应用&#34;&gt;PAM应用&lt;/h2&gt;

&lt;h3 id=&#34;1-求字符串中所有本质不同的回文子串的数量&#34;&gt;1 求字符串中所有本质不同的回文子串的数量&lt;/h3&gt;

&lt;p&gt;生成PAM统计非根的节点数量即可&lt;/p&gt;

&lt;h3 id=&#34;2-求字符串中所有回文子串的数量&#34;&gt;2 求字符串中所有回文子串的数量&lt;/h3&gt;

&lt;p&gt;生成PAM后，对除了根外的所有节点的cnt累加就行了&lt;/p&gt;

&lt;h3 id=&#34;3-求公共回文子串数量&#34;&gt;3 求公共回文子串数量&lt;/h3&gt;

&lt;p&gt;对两个字符串都生成PAM后，同时dfs遍历其相同的节点，累加两边节点的cnt的乘积即可&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>后缀自动机SAM</title>
      <link>/post/20200220-sam/</link>
      <pubDate>Thu, 20 Feb 2020 20:00:00 +0800</pubDate>
      <guid>/post/20200220-sam/</guid>
      <description>&lt;p&gt;后缀自动机（SAM），可以结合前文的AC自动机一起理解，所谓后缀自动机，就是把一个字符串的所有后缀构造AC自动机，即只匹配其后缀的自动机。但是作为一个字符串的所有后缀，与一般的AC自动机有些不一样的性质，直接构造AC自动机，节点数是 $O(n^2)$，而SAM则对重复的节点合并了，可以让节点数大幅下降到 $O(n)$。&lt;/p&gt;

&lt;p&gt;首先我们来直观地看看SAM的图形化，以下是字符串&lt;code&gt;abcac&lt;/code&gt;的SAM&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4
4--c--&amp;gt;5((5))
0--c--&amp;gt;6(1)

0--b--&amp;gt;2
1--c--&amp;gt;5
6--a--&amp;gt;4

4-.-&amp;gt;1
5-.-&amp;gt;6
3-.-&amp;gt;6

1-.-&amp;gt;0
2-.-&amp;gt;0
6-.-&amp;gt;0
style 0 fill:#f9f
style 5 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实线方向就是匹配方向，虚线与AC自动机中的失败指针非常像，在SAM里称为link指针。&lt;/p&gt;

&lt;p&gt;咱们这里就不从理论上做解释，把构造过程简单模拟一遍，如果你需要证明，那么可以在oiwiki上找到。&lt;/p&gt;

&lt;h2 id=&#34;sam构造过程模拟&#34;&gt;SAM构造过程模拟&lt;/h2&gt;

&lt;p&gt;我们使用字符串&lt;code&gt;abcac&lt;/code&gt;作为开始，SAM的构造是一个在线算法，可以一个个字符添加构造。另一点说明，节点编号等于与从根开始出发到该节点的最大深度。&lt;/p&gt;

&lt;h3 id=&#34;1-插入a&#34;&gt;1 插入a&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1((1))

1-.-&amp;gt;0
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-插入b&#34;&gt;2 插入b&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2((2))

0--b--&amp;gt;2

1-.-&amp;gt;0
2-.-&amp;gt;0
style 0 fill:#f9f
style 2 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在b添加到主链后，要找2的父节点1的link指针指的节点，命名为p，1. 如果它的下一个不存在字符&lt;code&gt;b&lt;/code&gt;，那么再令&lt;code&gt;p = p-&amp;gt;link&lt;/code&gt;，并再次判断本情况，2. 如果某个p的next存在当前的字符，那就让节点2的link指向&lt;code&gt;p-&amp;gt;next[char]&lt;/code&gt;节点，3. 如果p已经到达根，那么从根连接一条实边到节点2，同时节点2的link指向根。这里就属于情况3。&lt;/p&gt;

&lt;h3 id=&#34;3-插入c&#34;&gt;3 插入c&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3

0--b--&amp;gt;2
0--c--&amp;gt;3((3))

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
style 0 fill:#f9f
style 3 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-插入a&#34;&gt;4 插入a&lt;/h3&gt;

&lt;p&gt;这个步骤稍微多一点，先添加到主链，即在&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;上，得到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4((4))

0--b--&amp;gt;2
0--c--&amp;gt;3

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
style 0 fill:#f9f
style 4 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后找4的父节点3的link指针指的节点，它的下一个存在字符&lt;code&gt;a&lt;/code&gt;，那么指向它，属于前面说的情况2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4((4))

0--b--&amp;gt;2
0--c--&amp;gt;3

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;1
style 0 fill:#f9f
style 4 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-插入c&#34;&gt;5 插入c&lt;/h3&gt;

&lt;p&gt;此步更为复杂 ，首先还是先加入主链&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4
4--c--&amp;gt;5((5))

0--b--&amp;gt;2
0--c--&amp;gt;3

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;1
style 0 fill:#f9f
style 5 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从节点4开始找到节点1，它的next没有当前字符，再找到节点0，节点0的next存在当前字符，即找到节点3，但我们不能直接让节点5的link连接到节点3，因为连接到3的父节点0，它们的的深度不是连续的关系，这时候我们需要做拆点，把原来的节点3复制一个，即next是一样的，link也是一样，然后再让节点0直接连向它（如果不是节点0，那除了它之外，还有它的link节点的next有包含当前字符的，都要指向复制节点），节点3和新插入的节点5的link都指向这个复制节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4
4--c--&amp;gt;5((5))
0--c--&amp;gt;6(1)

0--b--&amp;gt;2
1--c--&amp;gt;5
6--a--&amp;gt;4

4-.-&amp;gt;1
5-.-&amp;gt;6
3-.-&amp;gt;6

1-.-&amp;gt;0
2-.-&amp;gt;0
6-.-&amp;gt;0
style 0 fill:#f9f
style 5 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;构造步骤总结&#34;&gt;构造步骤总结&lt;/h2&gt;

&lt;p&gt;一些说明，节点p有数据&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;link&lt;/code&gt;、&lt;code&gt;maxlen&lt;/code&gt;，&lt;code&gt;next&lt;/code&gt;就是匹配的转移表，&lt;code&gt;link&lt;/code&gt;连接到p所表示的字符串的最长后缀，可以当成fail指针理解，而&lt;code&gt;maxlen&lt;/code&gt;表示从根到节点p的最大深度&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;上一次插入主链的节点命名为&lt;code&gt;last&lt;/code&gt;，新插入节点到主链，命名为&lt;code&gt;cur&lt;/code&gt;，当前要插入的字符命名为&lt;code&gt;c&lt;/code&gt;，进入步骤2&lt;/li&gt;
&lt;li&gt;令&lt;code&gt;p = last&lt;/code&gt;看看&lt;code&gt;p-&amp;gt;link-&amp;gt;next&lt;/code&gt;有没有&lt;code&gt;c&lt;/code&gt;，没有的话再令&lt;code&gt;p = p-&amp;gt;link&lt;/code&gt;直到&lt;code&gt;p-&amp;gt;link-&amp;gt;next&lt;/code&gt;有&lt;code&gt;c&lt;/code&gt;跳到步骤3。如果p到根仍然找不到，那么令&lt;code&gt;cur-&amp;gt;link = root&lt;/code&gt;结束&lt;/li&gt;
&lt;li&gt;令节点&lt;code&gt;p-&amp;gt;next[c]&lt;/code&gt;为&lt;code&gt;ch&lt;/code&gt;，判断&lt;code&gt;ch-&amp;gt;maxlen&lt;/code&gt;和&lt;code&gt;p-&amp;gt;maxlen+1&lt;/code&gt;是不是相等，如果是，令&lt;code&gt;cur-&amp;gt;link = p-&amp;gt;next[c]&lt;/code&gt;，结束。如果不是，到第4步&lt;/li&gt;
&lt;li&gt;对节点&lt;code&gt;ch&lt;/code&gt;进行分拆操作，先复制，复制节点命名为&lt;code&gt;p2&lt;/code&gt;，更新&lt;code&gt;p2&lt;/code&gt;的最大深度，再判断如果满足&lt;code&gt;p-&amp;gt;next[c] == ch&lt;/code&gt;，则令&lt;code&gt;p-&amp;gt;next[c] = p2&lt;/code&gt;，再令&lt;code&gt;p = p-&amp;gt;link&lt;/code&gt;重复前一步&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于节点p的&lt;code&gt;minlen&lt;/code&gt;，可以通过 &lt;code&gt;p-&amp;gt;link-&amp;gt;maxlen + 1&lt;/code&gt; 得到&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SAM
{
    struct node
    {
        map&amp;lt;char, int&amp;gt; next;
        int link;
        int len_max;
        node() : link(0), len_max(0) { }
    };
    vector&amp;lt;node&amp;gt; nodes;
    int last;
    void init(int size = 1024)
    {
        nodes.clear();
        nodes.reserve(size);
        nodes.push_back(node());
        last = 0;
        nodes[0].link = -1;
    }
    int size() const
    {
        return (int)nodes.size();
    }
    int len_max(int p)
    {
        return nodes[p].len_max;
    }
    int len_min(int p)
    {
        if (p == 0) return 0;
        return nodes[nodes[p].link].len_max + 1;
    }
    void extend(char c)
    {
        int cur = (int)nodes.size();
        nodes.push_back(node());
        nodes[cur].len_max = nodes[last].len_max + 1;
        int p = last; last = cur;

        while (p != -1 &amp;amp;&amp;amp; !nodes[p].next.count(c))
        {
            nodes[p].next[c] = cur;
            p = nodes[p].link;
        }

        if (p == -1)
        {
            nodes[cur].link = 0;
        }
        else
        {
            int ch = nodes[p].next[c];
            if (nodes[p].len_max + 1 == nodes[ch].len_max)
            {
                nodes[cur].link = ch;
            }
            else // split ch
            {
                int p2 = (int)nodes.size();
                nodes.push_back(nodes[ch]);
                nodes[p2].len_max = nodes[p].len_max + 1;
                while (p != -1 &amp;amp;&amp;amp; nodes[p].next[c] == ch)
                {
                    nodes[p].next[c] = p2;
                    p = nodes[p].link;
                }
                nodes[ch].link = nodes[cur].link = p2;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sam应用&#34;&gt;SAM应用&lt;/h2&gt;

&lt;h3 id=&#34;1-多模式匹配&#34;&gt;1 多模式匹配&lt;/h3&gt;

&lt;p&gt;给你一个字符串集S以及字符串T，判断T有哪些子串属于S&lt;/p&gt;

&lt;p&gt;先对T求SAM，然后对S的每一个字符串走一遍，如果能走到底，那么这个串在T中出现了&lt;/p&gt;

&lt;h3 id=&#34;2-不同的子串数量&#34;&gt;2 不同的子串数量&lt;/h3&gt;

&lt;p&gt;因为对于SAM任何一个节点u，从根到这个节点的路线有 $maxlen(u) - minlen(u) + 1$ 条，而这条路线则表示原字符串的一个子串，且各不相同，所以对所有的节点求和，即 $\sum{(maxlen(u) - minlen(u) + 1)}$&lt;/p&gt;

&lt;h3 id=&#34;3-字符串的最小表示&#34;&gt;3 字符串的最小表示&lt;/h3&gt;

&lt;p&gt;这个很简单，对于原串s，长度为k，生成关于&lt;code&gt;s+s&lt;/code&gt;串的SAM后，找最小的next节点走k步即可&lt;/p&gt;

&lt;h3 id=&#34;4-最长公共子串&#34;&gt;4 最长公共子串&lt;/h3&gt;

&lt;p&gt;给出串A和B，对B求SAM，然后把这个SAM仿照KMP给A做匹配，令&lt;code&gt;l&lt;/code&gt;表示最大匹配长度，如果next有对应字符就转移，且&lt;code&gt;l++&lt;/code&gt;，如果没有则跳转到link所指的节点u，令&lt;code&gt;l = maxlen(u)&lt;/code&gt;并再次匹配，l的最大值就是答案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AC自动机</title>
      <link>/post/20200210-ac/</link>
      <pubDate>Mon, 10 Feb 2020 22:00:00 +0800</pubDate>
      <guid>/post/20200210-ac/</guid>
      <description>&lt;p&gt;听到AC自动机很多人第一次听到的反应往往是很兴奋的。但其实并不是你们想的那种东西。它的全称是Aho-Corasick algorithm，另外，自动机的英文是Automaton，所以AC自动机即 AC Automaton。为了解释这个算法，首先我们来回顾KMP，你需要很理解KMP的原理，不然看后面的内容就会变得&lt;del&gt;妙不可读&lt;/del&gt;。&lt;/p&gt;

&lt;h2 id=&#34;kmp自动机&#34;&gt;KMP自动机&lt;/h2&gt;

&lt;p&gt;本质上KMP其实就是一种自动机。这次我们改用自动机的形式来理解。所谓自动机，一般指的是确定有限状态自动机，你可以看作一个黑箱，每次输入一个数据，它就会改变它的内部状态，并有相应的输出。如果你知道Trie，那么它其实就是一个典型的自动机。我们还是拿字符串&lt;code&gt;abacabab&lt;/code&gt;作为例子，如果是生成next数组，结果如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;next&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;为了方便变成自动机的方式理解，我们把这个改成有向图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
1--a--&amp;gt;2[3]
2--c--&amp;gt;3[4]
3--a--&amp;gt;4[5]
4--b--&amp;gt;5[6]
5--a--&amp;gt;6[7]
6--b--&amp;gt;7[8]
00-.-&amp;gt;0
1-.-&amp;gt;0
2-.-&amp;gt;00
3-.-&amp;gt;0
4-.-&amp;gt;00
5-.-&amp;gt;1
6-.-&amp;gt;2
%%7[b]-.-&amp;gt;3[c]
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上图中，实箭头表示匹配，虚箭头表示不匹配要返回的前面的节点，紫色节点表示起止节点。首先我们的状态只要一个指针，先指向start，在匹配的时候，如果与它的下一个字符匹配，那么指针就沿实箭头移动；如果与下一个字符不匹配，在有虚线的情况下，那就沿虚线走一步，然后再尝试一次匹配。以下我们模拟一下匹配&amp;rdquo;ababa&amp;rdquo;的过程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化指向start，start的下一个是&lt;code&gt;a&lt;/code&gt;，匹配第1个字符，指针移动到节点1&lt;/li&gt;
&lt;li&gt;节点1的下一个是&lt;code&gt;b&lt;/code&gt;，匹配第2个字符，指针移动到节点2&lt;/li&gt;
&lt;li&gt;节点2的下一个是&lt;code&gt;a&lt;/code&gt;，匹配第3个字符，指针移动到节点3&lt;/li&gt;
&lt;li&gt;节点3的下一个是&lt;code&gt;c&lt;/code&gt;，不匹配第4个字符，回退到节点1，这时候匹配，指针移动到节点2&lt;/li&gt;
&lt;li&gt;节点2的下一个是&lt;code&gt;a&lt;/code&gt;，匹配第5个字符，指针移动到节点3&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上的虚线箭头就是fail指针的指向&lt;/p&gt;

&lt;h2 id=&#34;kmp自动机的生成&#34;&gt;KMP自动机的生成&lt;/h2&gt;

&lt;p&gt;这个的生成规则其实非常简单，首先建立start，然后向右添加字符，用实箭头连接，第一个节点就虚箭头直接指回start&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00-.-&amp;gt;0
style 0 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后插入第二个字符，第二个字符的虚箭头看它的父节点的虚箭头所指向的节点的子节点是不是与第二个字符相等，这个描述有点绕，假设当前节点是c，父节点是p，其虚箭头所指节点是&lt;code&gt;fail[x]&lt;/code&gt;，那么看的是&lt;code&gt;fail[p]&lt;/code&gt;的子节点是否等于c的值，如果等于，那么&lt;code&gt;fail[c] = fail[p]-&amp;gt;next&lt;/code&gt;，如果不等于，那么令&lt;code&gt;p=fail[p]&lt;/code&gt;再次判断其子节点，直到&lt;code&gt;p=start&lt;/code&gt;，于是加入第二节点时，它的fail指针指向start&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
00-.-&amp;gt;0
1-.-&amp;gt;0
style 0 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到第3个字符a的时候，它的父节点的fail指向start，而start的子节点也是a，所以它的a就指向第1个字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
1--a--&amp;gt;2[3]
00-.-&amp;gt;0
1-.-&amp;gt;0
2-.-&amp;gt;00
style 0 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后讲一下插入最后的字符b的时候，首先它的父节点的fail指向第3个节点a，但那个节点的下一个字符并不是b，所以用它的父节点的fail替代，然后再看第3个节点的fail，指向第1个节点，而第1个节点的下一个字符是b，所以要指向第2个节点，得到下图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
1--a--&amp;gt;2[3]
2--c--&amp;gt;3[4]
3--a--&amp;gt;4[5]
4--b--&amp;gt;5[6]
5--a--&amp;gt;6[7]
6--b--&amp;gt;7[8]
00-.-&amp;gt;0
1-.-&amp;gt;0
2-.-&amp;gt;00
3-.-&amp;gt;0
4-.-&amp;gt;00
5-.-&amp;gt;1
6-.-&amp;gt;2
7-.-&amp;gt;1
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在弄懂以上过程后，我们来正式介绍AC自动机&lt;/p&gt;

&lt;h2 id=&#34;ac自动机与trie&#34;&gt;AC自动机与Trie&lt;/h2&gt;

&lt;p&gt;AC自动机的本质，就是在Trie上套KMP，就这一句话。我们怎么理解呢，其实Trie能匹配字符串的前缀，但如果我们需要匹配任意位置，又不希望回溯，那就依照KMP的方法，在匹配失败的时候，跳转到&lt;strong&gt;假如回溯能匹配到的Trie的位置&lt;/strong&gt;。为了更好说明，这里我们使用&lt;code&gt;he&lt;/code&gt;,&lt;code&gt;she&lt;/code&gt;,&lt;code&gt;the&lt;/code&gt;,&lt;code&gt;there&lt;/code&gt;,&lt;code&gt;here&lt;/code&gt;来演示生成过程。&lt;/p&gt;

&lt;p&gt;先生成Trie&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
0--s--&amp;gt;5
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
0--t--&amp;gt;8
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后做BFS，第一层的fail都指向0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
0--s--&amp;gt;5
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
0--t--&amp;gt;8
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
1-.-&amp;gt;0
5-.-&amp;gt;0
8-.-&amp;gt;0
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，第二层，与KMP自动机的建立规则相同，另外为了让图形上的线不那么乱，虚线指向start的省略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
subgraph here
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
end
0--s--&amp;gt;5
subgraph she
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
end
0--t--&amp;gt;8
subgraph there
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
end
6-.-&amp;gt;1
9-.-&amp;gt;1
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，第三层&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
subgraph here
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
end
0--s--&amp;gt;5
subgraph she
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
end
0--t--&amp;gt;8
subgraph there
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
end
6-.-&amp;gt;1
9-.-&amp;gt;1
7-.-&amp;gt;2
10-.-&amp;gt;2

style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建完毕的图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
subgraph here
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
end
0--s--&amp;gt;5
subgraph she
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
end
0--t--&amp;gt;8
subgraph there
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
end
6-.-&amp;gt;1
9-.-&amp;gt;1
7-.-&amp;gt;2
10-.-&amp;gt;2
11-.-&amp;gt;3
12-.-&amp;gt;4

style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是一个最简单的AC自动机，由于只能通过fail指针在失配时做转移，所以遇到匹配失败的时候不能一步到位，需要一个循环来找下一个位置，但在不少场合已足够使用。习题：&lt;a href=&#34;https://vjudge.net/problem/HDU-2896&#34; target=&#34;_blank&#34;&gt;HDU-2896&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;字典图&#34;&gt;字典图&lt;/h2&gt;

&lt;p&gt;前面刚说过，由于fail指针只有一个，所以遇到匹配失败的时候不能一步到位，那我们如果想一步到位呢？那事实上就成为了一个有向图，我们在跳转时不使用fail指针，而直接用next指针替代，每遇到一个字符就按next来跳转，这样状态转移时间非常稳定且速度更快，而且成为有向图有一个额外的好处，就是能变成图论问题来解，这个后面再来讨论。&lt;/p&gt;

&lt;p&gt;要实现字典图，fail指针还是需要的，但在构建的时候代码写起来反而更简单，因为fail的指向不再需要写循环，可以利用前面的结果一步到位，假设当前节点是c，要更新的字符是i，那分两种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果c的&lt;code&gt;next[i]&lt;/code&gt;非空，那么c的&lt;code&gt;next[i]&lt;/code&gt;节点的fail指针就指向 c的fail指针节点的&lt;code&gt;next[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果c的&lt;code&gt;next[i]&lt;/code&gt;为空，那么c的&lt;code&gt;next[i]&lt;/code&gt;节点就指向 c的fail指针节点的&lt;code&gt;next[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说，不管哪种，都是指向c的fail的&lt;code&gt;next[i]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;应用以下模板时，你很可能需要做的调整包括&lt;code&gt;charset&lt;/code&gt;的大小，以及&lt;code&gt;getindex&lt;/code&gt;函数的实现，这两部分你也可以通过template改写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const int charset = 26;
struct TrieGraph
{
    struct trie_node
    {
        int next[charset];
        int fail;
        int cnt;
        int end;
        trie_node() : end(0), fail(0), cnt(0) {}
        void init() { memset(next, 0, sizeof(next)); }
    };
    vector&amp;lt;trie_node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; bfs_q;
    vector&amp;lt;int&amp;gt; match_cnt;
    map&amp;lt;int, int&amp;gt; id2node;
    map&amp;lt;int, int&amp;gt; str_size;
    int match_p;
    void init(int size)
    {
        nodes.clear();
        nodes.reserve(size);
        nodes.push_back(trie_node());
        nodes.back().init();
        match_p = 0;
    }
    static inline int getindex(char c) { return c - &#39;a&#39;; }
    void insert(const char* s, int id)
    {
        const char* s0 = s;
        int p = 0;
        for (;*s; ++s)
        {
            if (nodes[p].next[getindex(*s)])
            {
                p = nodes[p].next[getindex(*s)];
            }
            else
            {
                int np = nodes.size();
                nodes[p].next[getindex(*s)] = np;
                nodes.push_back(trie_node());
                nodes.back().init();
                p = np;
            }
        }
        ++nodes[p].cnt;
        id2node[id] = p;
        str_size[id] = s - s0;
    }
    void build()
    {
        bfs_q.clear();
        bfs_q.reserve(nodes.size());
        queue&amp;lt;int&amp;gt; q;
        for (int i = 0; i &amp;lt; charset; ++i)
            if (nodes[0].next[i]) q.push(nodes[0].next[i]);
        while (!q.empty())
        {
            int p = q.front();
            q.pop();
            bfs_q.push_back(p);
            for (int i = 0; i &amp;lt; charset; ++i)
            {
                if (nodes[p].next[i])
                {
                    nodes[nodes[p].next[i]].fail = nodes[nodes[p].fail].next[i];
                    q.push(nodes[p].next[i]);
                }
                else nodes[p].next[i] = nodes[nodes[p].fail].next[i];
            }
        }
    }
    int match(char c)
    {
        match_p = nodes[match_p].next[getindex(c)];
        return match_p;
    }
    int query(const char* s) // 有多少个出现
    {
        int ret = 0;
        match_cnt.resize(nodes.size());
        for (int i = match_cnt.size() - 1; i &amp;gt;= 0; --i)
        {
            match_cnt[i] = nodes[i].cnt;
        }
        for (const char* ps = s; *ps; ps++)
        {
            for (int p = match(*ps); p &amp;amp;&amp;amp; ~match_cnt[p]; p = nodes[p].fail)
                ret += match_cnt[p], match_cnt[p] = -1;
        }
        return ret;
    }
    ll query_sum(const char* s, int wc[]) // 每个分别出现多少
    {
        vector&amp;lt;int&amp;gt; sum;
        sum.resize(nodes.size());
        match_p = 0;
        for (const char* ps = s; *ps; ps++)
        {
            for (int p = match(*ps); p; p = nodes[p].fail)
            {
                sum[p] += nodes[p].cnt;
            }
        }
        ll ret = 0;
        for (map&amp;lt;int, int&amp;gt;::iterator it = id2node.begin(); it != id2node.end(); ++it)
        {
            wc[it-&amp;gt;first] = sum[it-&amp;gt;second];
            ret += sum[it-&amp;gt;second];
        }
        return ret;
    }
    const char* find(const char* s, int&amp;amp; match_id)
    {
        match_p = 0;
        for (const char* ps = s; *ps; ps++)
        {
            for (int p = match(*ps); p; p = nodes[p].fail)
            {
                if (nodes[p].cnt == 0) continue;
                for (map&amp;lt;int, int&amp;gt;::iterator it = id2node.begin(); it != id2node.end(); ++it)
                {
                    if (it-&amp;gt;second == p)
                    {
                        match_id = it-&amp;gt;first;
                        break;
                    }
                }
                return ps - str_size[match_id] + 1;
            }
        }
        return 0;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方式，先调用&lt;code&gt;init&lt;/code&gt;预分配空间，然后调用&lt;code&gt;insert&lt;/code&gt;插入所有用到的字符串，注意字符串的id必须从1开始，再调用&lt;code&gt;build&lt;/code&gt;生成字典树，最后调用&lt;code&gt;query&lt;/code&gt;匹配目标字符串，如果只需要知道有多少个串在目标中出现，那么调用单个参数的，如果需要知道每个分别出现多少次，那么使用有wc参数的版本，通过参数wc返回的是原始字符串每一个的匹配数量，而如果只需要找最初匹配的位置，那用find函数。习题 &lt;a href=&#34;https://vjudge.net/problem/HYSBZ-3172&#34; target=&#34;_blank&#34;&gt;HYSBZ-3172&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;扩展-字符串生成的可能数量&#34;&gt;扩展：字符串生成的可能数量&lt;/h2&gt;

&lt;p&gt;典型题目为&lt;a href=&#34;https://vjudge.net/problem/POJ-2778&#34; target=&#34;_blank&#34;&gt;POJ-2778&lt;/a&gt;，即生成长度为n的字符串，且不包含给定的m个子串。这时候就要用上前面所构造的字典图，我们要先转成邻接矩阵，例如&lt;code&gt;m[i][j][c]&lt;/code&gt;如果为1，表示节点i能通过字符c连接到节点j，为0则不通。不过实际计算的时候，我们并不关心i和j之间通过什么连接，只关心连接数量，那累加&lt;code&gt;m[i][j][c]&lt;/code&gt;，c取字符集的范围，累加值写到矩阵&lt;code&gt;M = matrix[i][j]&lt;/code&gt;，然后我们只要计算$M&amp;rsquo; = M ^ n$，在矩阵&lt;code&gt;M&#39;&lt;/code&gt;中，&lt;code&gt;M&#39;[i][j]&lt;/code&gt;的值就表示从i到j恰好n步共有多少种走法。回到上面的题目，因为部分节点不能走，所以我们只要在生成矩阵的时候删除那些不能走的节点，求出&lt;code&gt;M&#39;&lt;/code&gt;后，累加&lt;code&gt;M&#39;[0][j]&lt;/code&gt;的结果就是答案，所以算法复杂度是 $O(Mlogn)$ ，其中M是一次矩阵乘法的时间复杂度，这个也是有向图里面求k步到达指定节点的路线数量所用的算法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>伪随机数生成算法</title>
      <link>/post/20200104-xoshiro/</link>
      <pubDate>Sat, 04 Jan 2020 08:26:00 +0800</pubDate>
      <guid>/post/20200104-xoshiro/</guid>
      <description>&lt;p&gt;这次主要介绍伪随机数生成算法，顺便介绍一个在2018-2019年的伪随机数研究成果，就是 xoshiro/xoroshiro 随机数生成算法。&lt;/p&gt;

&lt;h2 id=&#34;历史&#34;&gt;历史&lt;/h2&gt;

&lt;p&gt;在较早的时候，甚至到现在，伪随机数的生成元老级别算法“线性同余伪随机数生成算法”可谓无处不在，像现在的C/C++的rand函数就是使用线性同余实现的伪随机数生成。所谓的线性同余法，就是这个迭代方程 $S_n = (aS_{n-1} + c)\mod m$，其中，$S_0$ 称为这个随机序列的种子，a,c,m是三个常数，不过这三个数不能随意选，m的大小决定随机数的周期，最大周期等于m，为了便于在计算机里实现，通常m选取$2^{32}$或$2^{64}$。在m已经确定为这两的时候，为了让周期尽可能大，常数a,c还至少要满足以下条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;若 c 非 0，那么 c 与 m 互质；若 c 为 0，那么 a 与 m 互质&lt;/li&gt;
&lt;li&gt;m 所有的素因子均能整除 a-1&lt;/li&gt;
&lt;li&gt;若 m 是4的倍数，那么 a-1 也是 4 的倍数&lt;/li&gt;
&lt;li&gt;a 和 c 都是正整数且小于 m&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一些典型的常数取值可以参见wiki上的&lt;a href=&#34;https://en.wikipedia.org/wiki/Linear_congruential_generator&#34; target=&#34;_blank&#34;&gt;线性同余&lt;/a&gt;条目。&lt;/p&gt;

&lt;h2 id=&#34;更高的需求&#34;&gt;更高的需求&lt;/h2&gt;

&lt;p&gt;我们之所以使用线性同余，就是因为它实现简单，在对随机数质量要求较低的时候，例如用来作为treap的随机数，那么线性同余完全够用，但建议不要使用rand，因为在windows下不少编译器的最大值太小了，导致效果下降，自己写一个用参数&lt;code&gt;a=69069,c=1,m=2^32&lt;/code&gt;比rand好，我在那篇关于treap的文章就是用了这组参数。线性同余法最大的缺陷是低位随机性特别差，如果使用类似&lt;code&gt;next() % k&lt;/code&gt;的方式来获得区间在$[0,k-1]$的随机数，那么当线性同余迭代方程的m是2的幂且k也是2的幂的时候，灾难就发生了，特别地当k是2的时候，你将得到一个0101的循环序列。为了避免这种情况，通常会取线性同余结果的高位，而且低位去掉得越多，&lt;code&gt;%2&lt;/code&gt;的周期就越长。例如结果是64位，取高32位作为最终结果，那么&lt;code&gt;%2&lt;/code&gt;的周期就是 $2^{33}$ ，但这样会导致有效位减少，而且问题也没有根本地解决。另一种解决办法是选取一个素数作为m，例如2147483647正是一个素数，但如此一来，线性同余的计算速度就会慢不少，周期也没有前一个的长。两种基本实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct LCG32 : public RNG_base&amp;lt;uint32_t&amp;gt;
{
    uint32_t s;
    static inline uint16_t rotl(const uint16_t x, int k) {
        return (x &amp;lt;&amp;lt; k) | (x &amp;gt;&amp;gt; (16 - k));
    }
    LCG32() { seed(); }
    LCG32(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
    }
    result_type operator()() {
        s = s * 214013UL + 2531011UL;
        return s;
    }
};

struct MCG : public RNG_base&amp;lt;uint32_t, 0x7FFFFFFEULL&amp;gt;
{
    uint64_t s;
    MCG() { seed(); }
    MCG(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
    }
    result_type operator()() {
        s = s * 48271 % 0x7FFFFFFF;
        return (result_type)s;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中基类&lt;code&gt;RNG_base&lt;/code&gt;的定义在下文代码中有。第一个是32位的实现，所以叫做LCG32，如果是64位里面取高32位，那么就叫做&lt;code&gt;LCG64/32&lt;/code&gt;。第二个实现没有加法操作，即c=0，这种特例叫做MCG。&lt;/p&gt;

&lt;h2 id=&#34;随机数的质量和周期&#34;&gt;随机数的质量和周期&lt;/h2&gt;

&lt;p&gt;如果对生成的随机数质量要求高，例如写一个扑克游戏，如果是52张牌，所有的排列就是 $52!$ （约为$2^{225.5}$），那么我们需要周期比排列数多得多的随机数生成算法以期望所有可能的排列都有机会出现，那到底需要多大呢？这里我们假设平均每16位生成一个8位有效的随机数，我们需要d个随机数得到的排列，即16d个位的所有可能性，都要有可能出现，若满周期的随机数生成器的周期是 $2^{n}$，输出长度为m位，那么我们只要知道$n/m$个输出就能唯一确定生成器的状态，同时这$n/m$个输出的所有可能都会一一出现，即长度为$n$的二进制必定在序列中出现。所以在这种情况下只要$n\geq16d$就能保证所需排列必定会出现。而在前面提到的扑克游戏里，d=52，那么需要的最小周期就是$2^{832}$，总之，只要生成器的周期的$2^{n}$中的n，比你需要生成的排列所需要的二进制流长度要大，那就保证能得到任意一个排列。这时候就最佳选择之一就是&lt;a href=&#34;https://en.wikipedia.org/wiki/Mersenne_Twister&#34; target=&#34;_blank&#34;&gt;梅森旋转&lt;/a&gt;，在C++11里的随机数实现默认就是使用它，而且我们一般特指MT19937，即它的周期是 $2^{19937}-1$，如果输出为64位，那么任意长度小于19904位的数据都会在其生成序列中出现（之所以不是19937只是因为它不是输出长度的整数倍），但你要是用这个算法大量生成随机数那是会稍慢一些的，而且这个算法也并没有通过BigCrush的所有测试。我们还存在一种情况，就是需要大量生成随机数，同时质量也有一定要求，速度如果比线性同余还快就更好。&lt;/p&gt;

&lt;h2 id=&#34;线性同余的改进&#34;&gt;线性同余的改进&lt;/h2&gt;

&lt;h3 id=&#34;输出质量&#34;&gt;输出质量&lt;/h3&gt;

&lt;p&gt;线性同余法的均匀性非常好，算法也简单，可惜分布性差，有多差呢，咱们用LCG16(0x43FD,0x9EC3)的输出画黑底白点图，相邻两次输出的高9位作为左半图的坐标，低9位作为右半图的坐标，连续采样524288个点，同一坐标出现次数越多亮度越高，于是得到下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;左边与右边的都有明显的斜线模式。与以下专业的PCG32生成器做个比较，关注点是亮度比较平均，基本没有特别亮的点，也没有比较多暗点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/pcg32.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;于是也就有不少人想方设法去改进。首先的改进，便是前面所提及的截取高位作为输出，那么内部数据为64位，输出是32位的，就叫做&lt;code&gt;LCG64/32&lt;/code&gt;，同理内部数据为32位，输出是16位的，就叫做&lt;code&gt;LCG32/16&lt;/code&gt;，这样一来，随机数质量大幅度提升。基于此实现的版本如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct LCG32_16 : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    uint32_t s;
    LCG32_16() { seed(); }
    LCG32_16(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        s = s * 214013UL + 2531011UL;
        return s &amp;gt;&amp;gt; 16;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码得到的图形如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg32_16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样生成的随机数质量就有了一个很大的飞跃。另外，LCG结果的低位，周期性特别短，而LCG结果的高位，对下一个数的影响又特别小，那能不能对这个特性加以利用呢？既然高位对下一个数的影响特别小，我们就创造影响，让高位单独参与计算；既然低位的结果差，那就直接舍弃，同时当高位作为下一个数的位旋转参数，这样避免了最低位的固定 $2^{16}$ 周期的问题。所以可以改写如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct LCG32_16ro : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    uint32_t s;
    LCG32_16ro() { seed(); }
    LCG32_16ro(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint32_t x = s;
        s = s * 214013UL + 2531011UL;
        return rotl16((uint16_t)(x &amp;gt;&amp;gt; 16u), x &amp;gt;&amp;gt; 28u);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg32_16ro.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;结果反而明显变差了，原因是作为参数的高4位也是输出的一部分，导致那高4位在最终出现的位置是固定的16种情况，解决方法1是不取那4位，取4到11位，方法2是把高16位与低16位做异或运算后再做旋转，两种方案均可解决这个问题，后面的测试使用的是第二种方案，具体代码就不重复了。&lt;/p&gt;

&lt;h3 id=&#34;输出周期&#34;&gt;输出周期&lt;/h3&gt;

&lt;p&gt;然后再来看周期，单独一个LCG周期只有 $2^{32}$ 或 $2^{64}$ ，那我们有没有可能通过两个或以上的随机数生成器构造出周期是它们周期之积的的生成器呢？也许一时半会不容易想出来，我们先考虑怎么让一个LCG生成器周期变长。&lt;/p&gt;

&lt;p&gt;要注意的是我们不能瞎改，必须是一个满周期的生成器，乱改的话在绝大多数情况下都达不到满周期从而导致返回值的分布不均匀。假如我们手上有一个LCG，周期是p，如果单纯只要周期变长，那我们有一个足够简单的方法，我们增加一个参数x，在原本的LCG输出的结果基础上 xor x 再输出，然后当原来的LCG生成了p次，就让参数x自增1，于是又能生成p个整体与原来不重叠的数，如此循环，于是x的自增周期是p2的话，总周期便是 $p\times{p_2}$ 。可是这明显能感觉到质量可能很糟糕，那解决办法就是，那个x改成另一个LCG来生成即可。这样我们便得到把两个LCG合并得到更大周期的办法。不过，问题是我们为了记录生成次数，似乎还要多定义一个变量来记录生成的次数，这个变量是会影响生成器的状态的，为了避免增加新的变量，在这里我们换个办法，不必生成p次，只要生成结果是某个设定值例如0，就更新第二个LCG，这样就节省了一个变量，于是可以写出以下的代码，为了方便说明，使用的是&lt;code&gt;LCG16&lt;/code&gt;，周期是65536。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct LCG16_1 : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    uint16_t s, a;
    LCG16_1() { seed(); }
    LCG16_1(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &amp;gt;&amp;gt; 16);
    }
    result_type operator()() {
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ s;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样把两个 $2^{16}$ 周期的LCG组合起来，确实得到了 $2^{32}$ 周期的LCG，不过之所以用周期这么小的，是为了能发现问题，我们能穷举这个LCG的生成序列，我们能轻易找出多处大段大段的随机数完全相同，有多大段呢，1千到3万个不等，即之前生成的数千个随机数，后面某处又重现了这个序列，而且在 $2^{32}$ 周期内发生。这说明单纯这样组合，结果是糟糕的。具体图形如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg16_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以我们加上前面的位旋转，以期望减少这种情况的出现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct LCG16_2 : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    uint16_t s, a;
    LCG16_2() { seed(); }
    LCG16_2(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &amp;gt;&amp;gt; 16);
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ rotl16(x, x &amp;gt;&amp;gt; 12);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg16_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;出现这个情况的原因前面有解释，正是高4位导致的。对此，为了把高4位的模式抹除，改为&lt;code&gt;rotl16(x ^ (x &amp;lt;&amp;lt; k), x &amp;gt;&amp;gt; 12)&lt;/code&gt;，只要k大于等于4，这个模式就迅速消失。取k为7得到代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct LCG16_3 : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    uint16_t s, a;
    LCG16_3() { seed(); }
    LCG16_3(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &amp;gt;&amp;gt; 16);
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ rotl16(x ^ (x &amp;lt;&amp;lt; 7), x &amp;gt;&amp;gt; 12);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg16_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们还可以再考虑一个问题，之前都是用高位的旋转参数对自己旋转，那可不可以错开，改为旋转下一个数呢？答案是可以的，生成的结果仍然是满周期的，也不存在高4位位置固定的问题，得到的代码和图形是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct LCG16_4 : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    uint16_t s, a;
    LCG16_4() { seed(); }
    LCG16_4(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &amp;gt;&amp;gt; 16);
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ rotl16(s, x &amp;gt;&amp;gt; 12);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg16_4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;于是我们确实得到了一个看起来更随机的生成器，但3和4的图仔细观察仍然能发现左边的图有规律的线条模式，和专业算法比较还是能看出差距，不过这个问题之后再去解决。那如果我们需要任意加大周期要怎么做呢，如果单纯按这个思路，那么增加了n级，就会导致输出要异或n次，代码也难写。这里要换一个思路，我们把扩展状态做成一个数组，每次只与数组中其中一个元素来异或运算，而选择的方法利用LCG的低位是循环的特性，具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;uint16_t ext_bit = 2&amp;gt;
struct LCG16s : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    static const uint16_t ext_size = 1 &amp;lt;&amp;lt; ext_bit, ext_mask = ext_size - 1;
    uint16_t s, a[ext_size];
    LCG16s() { seed(); }
    LCG16s(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a[0] = (uint16_t)(seed1 &amp;gt;&amp;gt; 16);
        if (ext_size &amp;gt; 1) a[1] = (uint16_t)(seed1 &amp;gt;&amp;gt; 32);
        if (ext_size &amp;gt; 2) a[2] = (uint16_t)(seed1 &amp;gt;&amp;gt; 48);
        for (uint16_t i = 3; i &amp;lt; ext_size; ++i) {
            a[i] = rotl16(a[i - 1] * (uint16_t)0x43FD + (uint16_t)0x9EC3, a[i-3] &amp;amp; 15) ^ a[i - 2];
        }
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) {
            for (uint16_t i = 0; i &amp;lt; ext_size; ++i) {
                a[i] = (a[i] * (uint16_t)0x101 + (uint16_t)0x9527);
                if (a[i]) break;
            }
        }
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return rotl16(s, x &amp;gt;&amp;gt; 12) ^ a[x &amp;amp; ext_mask];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg16s.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图上就能直观看出这东西有问题，问题在哪呢？以上这个生成器的周期在模板参数假设是n，那么其周期为 $ 2^{16 \times (2^n + 1)}$，可以任意加大周期。可是就在这个时候就出现问题了，我们假设参数是8，那么数组大小为256，那当s为0的时候，大多数情况下只有&lt;code&gt;a[0]&lt;/code&gt;发生改变，那导致的结果就是在下一个短周期里，每256个数有255个与前一个短周期完全一样，所以我们要做修改，每次s为0的时候，a数组每一个数都得至少更新一次，且如果&lt;code&gt;a[i]&lt;/code&gt;为0，那&lt;code&gt;a[i+1]&lt;/code&gt;就更新两遍，这样可以改写如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;uint16_t ext_bit = 2&amp;gt;
struct LCG16_ext : public RNG_base&amp;lt;uint16_t&amp;gt;
{
    static const uint16_t ext_size = 1 &amp;lt;&amp;lt; ext_bit, ext_mask = ext_size - 1;
    uint16_t s, a[ext_size];
    LCG16_ext() { seed(); }
    LCG16_ext(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a[0] = (uint16_t)(seed1 &amp;gt;&amp;gt; 16);
        if (ext_size &amp;gt; 1) a[1] = (uint16_t)(seed1 &amp;gt;&amp;gt; 32);
        if (ext_size &amp;gt; 2) a[2] = (uint16_t)(seed1 &amp;gt;&amp;gt; 48);
        for (uint16_t i = 3; i &amp;lt; ext_size; ++i) {
            a[i] = rotl16(a[i - 1] * (uint16_t)0x43FD + (uint16_t)0x9EC3, a[i-3] &amp;amp; 15) ^ a[i - 2];
        }
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) {
            for (uint16_t i = 0, carry = 0; i &amp;lt; ext_size; ++i) {
                if (carry) carry = (a[i] = (a[i] * (uint16_t)0x101 + (uint16_t)0x9527)) == 0;
                carry |= (a[i] = (a[i] * (uint16_t)0x101 + (uint16_t)0x9527)) == 0;
            }
        }
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return rotl16(s, x &amp;gt;&amp;gt; 12) ^ a[x &amp;amp; ext_mask];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg16_ext.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上这个版本经过一些简单的测试，符合满周期且概率均等。当然这个uint16有点太小，于是仍然能从图里看出分布有点问题，左边的图存在明暗间隔的竖条和横条，即问题存在于高位。所以本节的最后提供一个&lt;code&gt;LCG64_32_ext&lt;/code&gt;的完整实现，参数ext_bit为n，那么其周期为 $ 2^{32 \times (2^n + 2)}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;uint16_t ext_bit = 2&amp;gt;
struct LCG64_32_ext : public RNG_base&amp;lt;uint32_t&amp;gt;
{
    static const uint64_t ext_size = 1ULL &amp;lt;&amp;lt; ext_bit, ext_mask = ext_size - 1;
    const int init_iter = 256 * 256;
    uint64_t s;
    uint32_t a[ext_size];
    LCG64_32_ext() { seed(); }
    LCG64_32_ext(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s = seed1;
        a[0] = (uint32_t)(seed1 &amp;gt;&amp;gt; 32);
        if (ext_size &amp;gt; 1) a[1] = (uint32_t)seed2;
        if (ext_size &amp;gt; 2) a[2] = (uint32_t)(seed2 &amp;gt;&amp;gt; 32);
        for (uint32_t i = 3; i &amp;lt; ext_size; ++i) {
            a[i] = rotl32((uint32_t)(a[i - 1] * seed_mul + 1), a[i - 2] &amp;amp; 15) ^ a[i - 2];
        }
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint64_t x = s;
        if (s == 0) {
            for (uint64_t i = 0, carry = 0; i &amp;lt; ext_size; ++i) {
                if (carry) carry = (a[i] = (a[i] * 2891336453u + 887987685u)) == 0;
                carry |= (a[i] = (a[i] * 2891336453u + 887987685u)) == 0;
            }
        }
        s = s * 3935559000370003845ULL + 1442695040888963407ULL;
        return rotr32((uint32_t)(s &amp;gt;&amp;gt; 32), x &amp;gt;&amp;gt; 59) ^ a[x &amp;amp; ext_mask];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/rnd/lcg64_32_ext.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个图已经能与PCG的图看不出明显的差异，而且能通过BigCrash测试。当然，这样的实现还没有经过严格的随机性测试，这里只是给大家思路，以上代码建议不要用于实际使用场景。另外，以上思路参考自&lt;a href=&#34;http://www.pcg-random.org/&#34; target=&#34;_blank&#34;&gt;PCG&lt;/a&gt;算法。&lt;/p&gt;

&lt;h2 id=&#34;lua的修改&#34;&gt;lua的修改&lt;/h2&gt;

&lt;p&gt;通过参阅lua的源代码，最早的时候，它还是直接使用的C语言内置的rand，后来被诟病随机数范围太小、生成的质量太差。所以后来做了一番改进，在2018年之前，使用的是TausWorthe的一个随机数算法，周期为 $2^{223}-1$ ，所以又叫做 TausWorthe 223 或 TW223，代码参见后文的&lt;code&gt;taus_worthe223&lt;/code&gt;。这里要介绍的是lua在2018年之后更换的新随机数算法。&lt;/p&gt;

&lt;h2 id=&#34;xoshiro-xoroshiro&#34;&gt;xoshiro/xoroshiro&lt;/h2&gt;

&lt;p&gt;而在2018年，新出现的&lt;a href=&#34;http://prng.di.unimi.it/&#34; target=&#34;_blank&#34;&gt;xoshiro/xoroshiro&lt;/a&gt;算法以其周期更大、质量更高、速度更快的特性，很快lua的&lt;a href=&#34;http://lua-users.org/lists/lua-l/2018-05/msg00109.html&#34; target=&#34;_blank&#34;&gt;实现&lt;/a&gt;便改用它，而且官方还提供了不同的实现，你可以自行在周期长度、随机数质量、运行速度间自行取舍，这个算法改进自Xorshift，同样属于&lt;a href=&#34;https://en.wikipedia.org/wiki/Linear-feedback_shift_register&#34; target=&#34;_blank&#34;&gt;LFSR&lt;/a&gt;。不过xoshiro/xoroshiro提供的版本实在是太多了，怎么取舍呢？我通过阅读paper，选出了三个建议的版本，分别是&lt;code&gt;xoroshiro128++&lt;/code&gt;，&lt;code&gt;xoshiro256**&lt;/code&gt;，&lt;code&gt;xoroshiro1024**&lt;/code&gt;，名字后面的数字表示周期，例如&lt;code&gt;xoshiro256**&lt;/code&gt;的周期是 $2^{256}-1$，而后面的加号和乘号表示生成时所用的运算符，所对应的类名分别是&lt;code&gt;xoroshiro128pp&lt;/code&gt;，&lt;code&gt;xoshiro256ss&lt;/code&gt;，&lt;code&gt;xoroshiro1024ss&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其生成速度之快超越线性同余法（限64位平台）。而&lt;code&gt;xoshiro256**&lt;/code&gt;大多数场合足够使用，且lua&lt;a href=&#34;https://github.com/lua/lua/blob/d7bb8df8414f71a290c8a4b1c9f7c6fe839a94df/lmathlib.c#L307&#34; target=&#34;_blank&#34;&gt;所选择的实现&lt;/a&gt;也是它，除非你特别看它不爽非要特别大的周期，那就上&lt;code&gt;xoroshiro1024**&lt;/code&gt;吧。而在需要快速产生大量浮点数的场合，官方建议使用&lt;code&gt;xoroshiro128+&lt;/code&gt;或&lt;code&gt;xoroshiro256+&lt;/code&gt;，但如果生成整数，那请不要选择只有一个&lt;code&gt;+&lt;/code&gt;的版本，要选择&lt;code&gt;++&lt;/code&gt;或&lt;code&gt;**&lt;/code&gt;的版本。&lt;/p&gt;

&lt;p&gt;xoshiro/xoroshiro还有一个非常特别的功能，它有个jump和long jump功能，例如对于&lt;code&gt;xoshiro256**&lt;/code&gt;，一次jump调用相当于迭代了 $2^{128}$ 次，这样生成的新状态与原来的状态距离非常大，然后用于两个线程，这样就能保证生成的序列不产生重叠，而long jump则相当于迭代 $2^{192}$ 次，这样能生成出4个状态用于4线程，这个特色功能是其它随机数生成器所不具备的。不过以下模板并不包含这部分，有需要的话自己上官网那把代码复制过来用就行。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;这里的实现除了以上所提及的，还包括常见的&lt;code&gt;rand48&lt;/code&gt;，&lt;code&gt;taus88&lt;/code&gt;，&lt;code&gt;PCG32&lt;/code&gt;，&lt;code&gt;well512&lt;/code&gt;等等。编译以下代码需要C++11支持，如果要在不支持的编译器上编译就稍微改改就行。&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename _res_type, uint64_t ret_max = 0xFFFFFFFFFFFFFFFFULL&amp;gt;
struct RNG_base
{
    typedef _res_type result_type;
    static constexpr result_type min() { return 0; }
    static constexpr result_type max() { return (result_type)ret_max; }
    const uint64_t seed_mul = 6364136223846793005ULL;
    const int init_iter = 16;
    uint64_t new_seed() {
        std::random_device rd;
        return ((uint64_t)rd() &amp;lt;&amp;lt; 32) | rd();
    }
    uint64_t def_seed() {
        static uint64_t seed = new_seed();
        seed *= 3935559000370003845ULL;
        return ++seed;
    }
    static inline uint64_t rotl64(const uint64_t x, int k) {
        return (x &amp;lt;&amp;lt; k) | (x &amp;gt;&amp;gt; (64 - k));
    }
    static inline uint64_t rotr64(const uint64_t x, int k) {
        return (x &amp;gt;&amp;gt; k) | (x &amp;lt;&amp;lt; (64 - k));
    }
    static inline uint32_t rotl32(const uint32_t x, int k) {
        return (x &amp;lt;&amp;lt; k) | (x &amp;gt;&amp;gt; (32 - k));
    }
    static inline uint32_t rotr32(const uint32_t x, int k) {
        return (x &amp;gt;&amp;gt; k) | (x &amp;lt;&amp;lt; (32 - k));
    }
    static inline uint16_t rotl16(const uint16_t x, int k) {
        return (x &amp;lt;&amp;lt; k) | (x &amp;gt;&amp;gt; (16 - k));
    }
    static inline uint16_t rotr16(const uint16_t x, int k) {
        return (x &amp;gt;&amp;gt; k) | (x &amp;lt;&amp;lt; (16 - k));
    }
};

struct PCG32 : public RNG_base&amp;lt;uint32_t&amp;gt; // XSH RR
{
    const int init_iter = 1; // min 1
    uint64_t s;
    PCG32() { seed(); }
    PCG32(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint64_t x = s;
        s = s * 6364136223846793005ULL + 1442695040888963407ULL;
        return rotr32((uint32_t)((x ^ (x &amp;gt;&amp;gt; 18)) &amp;gt;&amp;gt; 27), x &amp;gt;&amp;gt; 59);
    }
};

struct rand48 : public RNG_base&amp;lt;uint32_t&amp;gt;
{
    uint16_t s[3];
    static const uint16_t RAND48_A0 = 0xE66D;
    static const uint16_t RAND48_A1 = 0xDEEC;
    static const uint16_t RAND48_A2 = 0x0005;
    static const uint16_t RAND48_C0 = 0x000B;
    rand48() { seed(); }
    rand48(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s[0] = (uint16_t)seed1;
        s[1] = (uint16_t)(seed1 &amp;gt;&amp;gt; 16);
        s[2] = (uint16_t)(seed1 &amp;gt;&amp;gt; 32);
    }
    inline void do_rand48() {
        const uint32_t x0 = s[0];
        const uint32_t x1 = s[1];
        const uint32_t x2 = s[2];

        uint32_t a = RAND48_A0 * x0 + RAND48_C0;
        s[0] = static_cast&amp;lt;uint16_t&amp;gt;(a &amp;amp; 0xFFFF);

        a &amp;gt;&amp;gt;= 16;

        a += RAND48_A0 * x1 + RAND48_A1 * x0;
        s[1] = static_cast&amp;lt;uint16_t&amp;gt;(a &amp;amp; 0xFFFF);

        a &amp;gt;&amp;gt;= 16;
        a += RAND48_A0 * x2 + RAND48_A1 * x1 + RAND48_A2 * x0;
        s[2] = static_cast&amp;lt;uint16_t&amp;gt;(a &amp;amp; 0xFFFF);
    }
    result_type operator()() {
        do_rand48();
        return ((uint32_t)s[2] &amp;lt;&amp;lt; 16) + s[1];
    }
};

struct taus88 : public RNG_base&amp;lt;uint32_t&amp;gt;
{
    uint32_t s[3];
    const int init_iter = 0;
    taus88() { seed(); }
    taus88(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = (uint32_t)seed1;
        s[1] = (uint32_t)(seed1 &amp;gt;&amp;gt; 32);
        s[2] = (uint32_t)(seed2 &amp;gt;&amp;gt; 32);
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    inline uint32_t tausworthe(uint32_t arg, uint32_t stage1, uint32_t stage2, uint32_t stage3, uint32_t limit) {
        return ((arg &amp;amp; limit) &amp;lt;&amp;lt; stage1) ^ (((arg &amp;lt;&amp;lt; stage2) ^ arg) &amp;gt;&amp;gt; stage3);
    }
    result_type operator()() {
        s[0] = tausworthe(s[0], 12, 13, 19, 4294967294UL);
        s[1] = tausworthe(s[1], 4, 2, 25, 4294967288UL);
        s[2] = tausworthe(s[2], 17, 3, 11, 4294967280UL);
        return (s[0] ^ s[1] ^ s[2]);
    }
};

struct taus_worthe223 : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 1; // min 1
    uint64_t gen[4];
    taus_worthe223() { seed(); }
    taus_worthe223(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        gen[0] = seed1;
        gen[1] = seed2;
        gen[2] = seed3;
        gen[3] = seed4;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
#define taus_worthe(i,k,q,s) z = gen[i]; \
    z = (((z &amp;lt;&amp;lt; q) ^ z) &amp;gt;&amp;gt; (k - s)) ^ ((z&amp;amp;((uint64_t)(int64_t)-1 &amp;lt;&amp;lt; (64 - k))) &amp;lt;&amp;lt; s); \
    r ^= z; gen[i] = z
    result_type operator()() {
        uint64_t r = 0, z;
        taus_worthe(0, 63, 31, 18);
        taus_worthe(1, 58, 19, 28);
        taus_worthe(2, 55, 24, 7);
        taus_worthe(3, 47, 21, 8);
        return r;
    }
#undef taus_worthe
};

struct well512 : public RNG_base&amp;lt;uint32_t&amp;gt;
{
    // http://lomont.org/papers/2008/Lomont_PRNG_2008.pdf
    // const int init_iter = 0; // min 0
    const uint64_t seed_mul = 134775813;
    uint32_t s[16];
    uint32_t index;
    well512() { seed(); }
    well512(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = (uint32_t)(seed1);
        s[1] = (uint32_t)(seed1 &amp;gt;&amp;gt; 32);
        s[2] = (uint32_t)(seed2);
        s[3] = (uint32_t)(seed2 &amp;gt;&amp;gt; 32);
        s[4] = (uint32_t)(seed3);
        s[5] = (uint32_t)(seed3 &amp;gt;&amp;gt; 32);
        s[6] = (uint32_t)(seed4);
        s[7] = (uint32_t)(seed4 &amp;gt;&amp;gt; 32);
        uint8_t* t = (uint8_t*)s;
        for (int i = 32, j = 0; i &amp;lt; 64; ++i, ++j) {
            if (i % 4 == 0) {
                for (int k = i / 8; k &amp;lt; 16; ++k)
                    s[k] = s[k - 1] * (uint32_t)seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        index = 0;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint32_t a, b, c, d;
        a = s[index];
        c = s[(index + 13) &amp;amp; 15];
        b = a ^ c ^ (a &amp;lt;&amp;lt; 16) ^ (c &amp;lt;&amp;lt; 15);
        c = s[(index + 9) &amp;amp; 15];
        c ^= (c &amp;gt;&amp;gt; 11);
        a = s[index] = b ^ c;
        d = a ^ ((a &amp;lt;&amp;lt; 5) &amp;amp; 0xDA442D24);
        index = (index + 15) &amp;amp; 15;
        a = s[index];
        s[index] = a ^ b ^ d ^ (a &amp;lt;&amp;lt; 2) ^ (b &amp;lt;&amp;lt; 18) ^ (c &amp;lt;&amp;lt; 28);
        return s[index];
    }
};

struct splitmix64 : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s;
    splitmix64() { seed(); }
    splitmix64(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
    }
    result_type operator()() {
        uint64_t z = (s += 0x9e3779b97f4a7c15);
        z = (z ^ (z &amp;gt;&amp;gt; 30)) * 0xbf58476d1ce4e5b9;
        z = (z ^ (z &amp;gt;&amp;gt; 27)) * 0x94d049bb133111eb;
        return z ^ (z &amp;gt;&amp;gt; 31);
    }
};

struct xoshiro64ss : public RNG_base&amp;lt;uint32_t&amp;gt;
{
    //const int init_iter = 1; // min 1
    uint32_t s[2];
    xoshiro64ss() { seed(); }
    xoshiro64ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s[0] = (uint32_t)seed1;
        s[1] = (uint32_t)(seed1 &amp;gt;&amp;gt; 32);
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint32_t s0 = s[0];
        uint32_t s1 = s[1];
        const uint32_t result = rotl32(s0 * 0x9E3779BB, 5) * 5;
        s1 ^= s0;
        s[0] = rotl32(s0, 26) ^ s1 ^ (s1 &amp;lt;&amp;lt; 9);
        s[1] = rotl32(s1, 13);
        return result;
    }
};

struct xoroshiro128p : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s[2];
    xoroshiro128p() { seed(); }
    xoroshiro128p(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = seed1;
        s[1] = seed2;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t s0 = s[0];
        uint64_t s1 = s[1];
        const uint64_t result = s0 + s1;
        s1 ^= s0;
        s[0] = rotl64(s0, 24) ^ s1 ^ (s1 &amp;lt;&amp;lt; 16);
        s[1] = rotl64(s1, 37);
        return result;
    }
};

struct xoroshiro128pp : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s[2];
    xoroshiro128pp() { seed(); }
    xoroshiro128pp(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = seed1;
        s[1] = seed2;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t s0 = s[0];
        uint64_t s1 = s[1];
        const uint64_t result = rotl64(s0 + s1, 17) + s0;
        s1 ^= s0;
        s[0] = rotl64(s0, 49) ^ s1 ^ (s1 &amp;lt;&amp;lt; 21);
        s[1] = rotl64(s1, 28);
        return result;
    }
};

struct xoroshiro128ss : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s[2];
    xoroshiro128ss() { seed(); }
    xoroshiro128ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = seed1;
        s[1] = seed2;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t s0 = s[0];
        uint64_t s1 = s[1];
        const uint64_t result = rotl64(s0 * 5, 7) * 9;
        s1 ^= s0;
        s[0] = rotl64(s0, 24) ^ s1 ^ (s1 &amp;lt;&amp;lt; 16);
        s[1] = rotl64(s1, 37);
        return result;
    }
};

struct xoshiro256p : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[4];
    xoshiro256p() { seed(); }
    xoshiro256p(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t result = s[0] + s[3];
        const uint64_t t = s[1] &amp;lt;&amp;lt; 17;
        s[2] ^= s[0];
        s[3] ^= s[1];
        s[1] ^= s[2];
        s[0] ^= s[3];
        s[2] ^= t;
        s[3] = rotl64(s[3], 45);
        return result;
    }
};

struct xoshiro256pp : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[4];
    xoshiro256pp() { seed(); }
    xoshiro256pp(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t result = rotl64(s[0] + s[3], 23) + s[0];
        const uint64_t t = s[1] &amp;lt;&amp;lt; 17;
        s[2] ^= s[0];
        s[3] ^= s[1];
        s[1] ^= s[2];
        s[0] ^= s[3];
        s[2] ^= t;
        s[3] = rotl64(s[3], 45);
        return result;
    }
};

struct xoshiro256ss : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[4];
    xoshiro256ss() { seed(); }
    xoshiro256ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t result = rotl64(s[1] * 5, 7) * 9;
        const uint64_t t = s[1] &amp;lt;&amp;lt; 17;
        s[2] ^= s[0];
        s[3] ^= s[1];
        s[1] ^= s[2];
        s[0] ^= s[3];
        s[2] ^= t;
        s[3] = rotl64(s[3], 45);
        return result;
    }
};

struct xoshiro1024ss : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[16];
    int p;
    xoshiro1024ss() { seed(); }
    xoshiro1024ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        uint8_t* t = (uint8_t*)s;
        for (int i = 32, j = 0; i &amp;lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &amp;lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    void seed(uint8_t seed[], int size) {
        uint8_t* t = (uint8_t*)s;
        if (size &amp;gt; 128) size = 128;
        for (int i = 0; i &amp;lt; size; ++i) {
            t[i] = ((uint8_t*)seed)[i];
        }
        if (size == 0) {
            size = 8; s[0] = 0x931197d8e3177f17ULL;
        }
        for (int i = size, j = 0; i &amp;lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &amp;lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const int q = p;
        const uint64_t s0 = s[p = (p + 1) &amp;amp; 15];
        uint64_t s15 = s[q];
        const uint64_t result = rotl64(s0 * 5, 7) * 9;

        s15 ^= s0;
        s[q] = rotl64(s0, 25) ^ s15 ^ (s15 &amp;lt;&amp;lt; 27);
        s[p] = rotl64(s15, 36);

        return result;
    }
};

struct xoshiro1024pp : public RNG_base&amp;lt;uint64_t&amp;gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[16];
    int p;
    xoshiro1024pp() { seed(); }
    xoshiro1024pp(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        uint8_t* t = (uint8_t*)s;
        for (int i = 32, j = 0; i &amp;lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &amp;lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    void seed(uint8_t seed[], int size) {
        uint8_t* t = (uint8_t*)s;
        if (size &amp;gt; 128) size = 128;
        for (int i = 0; i &amp;lt; size; ++i) {
            t[i] = ((uint8_t*)seed)[i];
        }
        if (size == 0) {
            size = 8; s[0] = 0x931197d8e3177f17ULL;
        }
        for (int i = size, j = 0; i &amp;lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &amp;lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &amp;lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const int q = p;
        const uint64_t s0 = s[p = (p + 1) &amp;amp; 15];
        uint64_t s15 = s[q];
        const uint64_t result = rotl64(s0 + s15, 23) + s15;

        s15 ^= s0;
        s[q] = rotl64(s0, 25) ^ s15 ^ (s15 &amp;lt;&amp;lt; 27);
        s[p] = rotl64(s15, 36);

        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h2 id=&#34;效率测试&#34;&gt;效率测试&lt;/h2&gt;

&lt;p&gt;我们当然不能全信官方的数据，具体表现不同机器不同编译器也可能不相同，所以我们就来测试一下。测试所用的实现均为我个人实现的版本，不代表官方版本的运行效率，PCG32使用的是XSH-RR，PCG64使用的是XSL-RR&lt;/p&gt;

&lt;p&gt;在x86下测试标准是生成2亿个64位随机数的运行时间，如生成器生成的是32位，那么生成4亿个32位整数，即以相同输出位数的时间来做比较&lt;/p&gt;

&lt;h3 id=&#34;x86&#34;&gt;x86&lt;/h3&gt;

&lt;p&gt;在VS2015上以x86编译的运行时间&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法实现&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;毫秒&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;394&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1502&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG32_16_ext,4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2034&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2579&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1819&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6705&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2581&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rand48&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2221&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1232&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus_worthe223&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1844&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;well512&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1794&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;splitmix64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2118&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;605&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;882&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro64ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;534&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1181&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1194&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1382&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1279&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1856&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1513&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1472&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1585&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::mt19937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1651&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在mingw32 gcc5.1.0 以&lt;code&gt;-O2&lt;/code&gt;参数编译的结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法实现&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;毫秒&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;398&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1219&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG32_16_ext,4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1008&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;877&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1384&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3141&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1439&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rand48&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1084&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;705&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus_worthe223&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1757&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;well512&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1173&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;splitmix64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1267&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;663&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;919&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro64ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;462&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;821&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;951&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1036&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;845&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1094&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1205&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1067&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1074&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::mt19937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1033&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;x64&#34;&gt;x64&lt;/h3&gt;

&lt;p&gt;在VS2015上以x64编译的运行时间&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法实现&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;毫秒&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;396&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;399&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG32_16_ext,4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1207&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;609&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;407&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;670&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;988&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rand48&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1033&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1147&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus_worthe223&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;759&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;well512&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1821&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;splitmix64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;212&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;516&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;328&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro64ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;515&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;215&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;267&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;232&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;151&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;182&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;193&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;492&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;462&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::mt19937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1580&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在centos7x64 gcc8.3.1 以&lt;code&gt;-O2&lt;/code&gt;参数编译的结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法实现&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;毫秒&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;426&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;413&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG32_16_ext,4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1115&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;505&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;434&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;392&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32_ext,2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;511&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rand48&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;839&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;707&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus_worthe223&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;448&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;well512&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1009&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;splitmix64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;186&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;525&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;229&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro64ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;476&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;168&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;217&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;237&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256p&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;181&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;191&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;182&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024pp&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;292&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024ss&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;314&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::mt19937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2112&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从以上数据来看，首先要区分架构，如果是32位的，&lt;code&gt;++&lt;/code&gt;的更快，而在64位上则大多&lt;code&gt;**&lt;/code&gt;稍快，而现在大多数系统都支持64位的情况下，优先考虑&lt;code&gt;**&lt;/code&gt;的版本。而256与128的差距很小，不建议使用128，除非你确实要省这么点内存。综合最佳的是&lt;code&gt;xoshiro256**&lt;/code&gt;，即表格里的xoshiro256ss，64位架构下比线性同余快，而且质量好得多，推荐使用它。而如果你需要同时考虑32位和64位，那选择&lt;code&gt;xoshiro256++&lt;/code&gt;也是不错的。再者，如果你只需要生成浮点随机数，那么xoroshiro128p是速度最快的。不过老实说，大多数场合都没有必要对这么点差别纠结，选择一个合适的就行了，而且VS测试结果很迷，优化得让人猜不透，我认为以gcc的结果优先作为参考。以上数据仅供参考。&lt;/p&gt;

&lt;h2 id=&#34;随机性测试&#34;&gt;随机性测试&lt;/h2&gt;

&lt;p&gt;使用 TestU01 1.2.3 版的 SmallCrash, Crash 和 BigCrash 进行测试（如SmallCrash未通过则不测试Crash，Crash未通过则不测试BigCrash），横线&lt;code&gt;-&lt;/code&gt;表示通过测试，&lt;code&gt;/&lt;/code&gt;表示不进行测试，&lt;code&gt;?&lt;/code&gt;表示未测试&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法实现&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;状态空间(bits)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;状态周期&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;SmallCrash&lt;br/&gt;未通过项&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Crash&lt;br/&gt;未通过项&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;BigCrash&lt;br/&gt;未通过项&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LCG32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{32}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MaxOft&lt;br/&gt;&amp;hellip;.&lt;sup&gt;[1]&lt;/sup&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{32}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CollisionOver&lt;br/&gt;BirthdaySpacings&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG32_16ro&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{32}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MaxOft&lt;br/&gt;&amp;hellip;.&lt;sup&gt;[2]&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG32_16_ext,0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{48}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SerialOver&lt;br/&gt;&amp;hellip;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG32_16_ext,4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;288&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{288}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LCG64_32_ext,0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;96&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{96}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG16&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{32}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SerialOver&lt;br/&gt;MaxOft&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{64}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{128}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PCG32_ext,0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;96&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{96}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rand48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{48}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SimpPoker&lt;br/&gt;&amp;hellip;.&lt;sup&gt;[4]&lt;/sup&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus88&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;96&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{88}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MatrixRank&lt;br/&gt;LinearComp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;taus_worthe223&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;256&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{223}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MaxOft&lt;br/&gt;MatrixRank&lt;br/&gt;LinearComp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;well512&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;512&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{512}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MatrixRank&lt;br/&gt;LinearComp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;splitmix64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{64}$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift64s&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{64}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MatrixRank&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{128}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MaxOft&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xorshift128p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{128}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;sup&gt;[5]&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro64ss&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{64}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;A.S.&lt;sup&gt;[6]&lt;/sup&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{128}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128pp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{128}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoroshiro128ss&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{128}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256p&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;256&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{256}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256pp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;256&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{256}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro256ss&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;256&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{256}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024pp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1056&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{1024}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;xoshiro1024ss&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1056&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{1024}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::mt19937&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;20032&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;$2^{19937}-1$&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;LinearComp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LCG32未通过的项：BirthdaySpacings, Collision, Gap, SimpPoker, CouponCollector, MaxOft, WeightDistrib, MatrixRank, HammingIndep, RandomWalk1&lt;/li&gt;
&lt;li&gt;LCG32_16ro的实现代码并不是本文中描述的有问题的版本，它是列表里唯一一个32位能通过SmallCrash和Crash测试的实现。BigCrash未通过的项：CouponCollector, Gap, MaxOft, WeightDistrib, SumCollector, LongestHeadRun, PeriodsInStrings&lt;/li&gt;
&lt;li&gt;LCG32_16ext,0在BigCrash未通过的项：SerialOver, CouponCollector, WeightDistrib, PeriodsInStrings&lt;/li&gt;
&lt;li&gt;rand48未通过的项：BirthdaySpacings, Gap, SimpPoker, WeightDistrib, CouponCollector&lt;/li&gt;
&lt;li&gt;据wiki，xorshift128p输出reversed的情况下不能通过BigCrash测试&lt;/li&gt;
&lt;li&gt;xoshiro64ss未通过的项：AppearanceSpacings&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;随机性测试的部分结果也会带有一定的随机性，多次测试的结果可能不同，测试结果仅供参考&lt;/p&gt;

&lt;h2 id=&#34;生成-0-1-0-范围的均匀分布浮点数&#34;&gt;生成 $[0, 1.0)$ 范围的均匀分布浮点数&lt;/h2&gt;

&lt;p&gt;以上模板生成的都是无符号整数，如果要生成浮点数的话，以上的模板里除了&lt;code&gt;MCG&lt;/code&gt;不能直接用以下函数外，其它的都可以直接使用（速度快），用来把生成的整数转换成对应的浮点数。又或者，你可以直接用STL的&lt;code&gt;uniform_real_distribution&lt;/code&gt;（通用性好），以上全部模板支持STL的distribution系列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;float rand_float(uint32_t rnd)
{
    union {
        float f;
        uint32_t u;
    }x;
    x.u = ((rnd &amp;gt;&amp;gt; 9) | 0x3F800000UL);
    return x.f - 1.0f;
}

double rand_float(uint64_t rnd)
{
    union {
        double d;
        uint64_t u;
    } x;
    x.u = ((rnd &amp;gt;&amp;gt; 12) | 0x3FF0000000000000UL);
    return x.d - 1.0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;生成-0-n-范围的均匀分布随机整数&#34;&gt;生成 $[0, n]$ 范围的均匀分布随机整数&lt;/h2&gt;

&lt;p&gt;很多人第一个方案就是 &lt;code&gt;rnd % (n + 1)&lt;/code&gt; ，其实这是错误的，在你对随机数分布要求不高的时候可以这么用，否则只要n+1不是2的整数次幂，获得的随机数就不是均匀分布的，除了直接使用STL的&lt;code&gt;uniform_int_distribution&lt;/code&gt;，自己写的话，除了&lt;code&gt;MCG&lt;/code&gt;不能直接用以下函数外，其它的大多可以直接使用（条件是参数eg的随机引擎生成的随机数最大值必须大于等于n）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class _Eg&amp;gt;
static uint64_t i64_distribution(_Eg&amp;amp; eg, uint64_t n)
{
    ++n;
    if ((n &amp;amp; -n) == n)
        return (int64_t)eg() &amp;amp; (n-1);
    uint64_t m = n;
    while (m &amp;amp; (m - 1)) m += m &amp;amp; -m;
    --m;
    for (;;)
    {
        uint64_t r = (uint64_t)eg() &amp;amp; m;
        if (r &amp;lt; n)
            return r;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过这样的缺点是如果n比较小，那随机数据的大部分都浪费了，为了能更大地利用随机数据，可以做如下的改进，按n的大小分为1，2，4，8字节，每次从随机数据里取1，2，4，8个字节，多余的部分留下次使用，这样既照顾了速度也照顾了数据利用率。如果你需要能生成任意大小，那么你需要把随机数引擎作为二进制流数据生成，然后再从二进制流读取 $log_2n$ 个bit来做以上操作，这样代码较为复杂，但在n较小的时候能最大限度的利用生成的数据，这里就不具体展开了，有这个需求的话直接使用 &lt;code&gt;uniform_int_distribution&lt;/code&gt; 就足够了。以上全部模板支持直接调用。&lt;/p&gt;

&lt;p&gt;网上还有很多其它的错误生成方法，以下给大家带来一个视频，我觉得讲解得不错&lt;/p&gt;

&lt;iframe width=&#34;960&#34; height=&#34;540&#34; src=&#34;https://www.youtube.com/embed/LDPMpc-ENqY&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;随机数生成是一个大坑，以上只是做个简单得不能再简单的介绍，我只是碰巧看到lua更新了这个顺便更新一波，写个普及文，要是自己去创造一个随机数算法，我觉得比写别的算法还困难不少，绝大多数的实现都经不起数学推敲。之后有时间再收集收集资料再做介绍。&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Linear_congruential_generator&#34; target=&#34;_blank&#34;&gt;线性同余&lt;/a&gt; LCG&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Lehmer_random_number_generator&#34; target=&#34;_blank&#34;&gt;MCG&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Mersenne_Twister&#34; target=&#34;_blank&#34;&gt;梅森旋转&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Linear-feedback_shift_register&#34; target=&#34;_blank&#34;&gt;LFSR&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://prng.di.unimi.it/&#34; target=&#34;_blank&#34;&gt;xoshiro/xoroshiro&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pcg-random.org/&#34; target=&#34;_blank&#34;&gt;PCG&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf&#34; target=&#34;_blank&#34;&gt;PCG pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sprng.org/Version5.0/parameters.html&#34; target=&#34;_blank&#34;&gt;LCG Generator Parameters&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_random_number_generators&#34; target=&#34;_blank&#34;&gt;List of random number generators&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>可持久化线段树</title>
      <link>/post/20191231-persistent_segtree/</link>
      <pubDate>Tue, 31 Dec 2019 08:26:00 +0800</pubDate>
      <guid>/post/20191231-persistent_segtree/</guid>
      <description>&lt;p&gt;可持久化权值线段树，wiki上指出引入者名字叫黃嘉泰，名字缩写正好是某位主席名字，所以又叫做主席树。而本篇先介绍可持久化线段树，阅读本篇前你需要先了解&lt;a href=&#34;/post/20191208-segtree/&#34;&gt;线段树&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;p&gt;所谓的可持久化，意思是你能得到所有的历史版本，为了达到这个效果，当然可以每次修改的时候，先整体复制再修改，结果自然就是会爆内存。而事实上，由于每次修改最多改一条链，而其它分支可以重用。我们先拿链表做例子，如果有个链表内容是 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 ，现在我们把3修改成6，得到 1-&amp;gt;2-&amp;gt;6-&amp;gt;4-&amp;gt;5 ，但是后面的元素没有改动，所以我们可以把后面的元素直接重叠在一起使用，如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
1--&amp;gt;2
2--&amp;gt;3
3--&amp;gt;4
4--&amp;gt;5
1&#39;--&amp;gt;2&#39;
2&#39;--&amp;gt;6
6--&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，完全可以当成两条不同的链表使用，同时节省空间。而可持久化线段树做法与这一样，就是没变的部分还使用原来节点，所以这个实现不能使用之前介绍的堆式储存，要和平衡树一样动态开节点。&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;p&gt;假设我们的数据是以下这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;构建线段树后结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冒号前面的两个数表示一条线段，冒号后表示的是数据，这个数据表示的是这个区间的和。&lt;/p&gt;

&lt;p&gt;然后我们要把第3个元素从5改为1，构造第二棵线段树，首先复制一个root，包括儿子的指向也复制，得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
1,4&#39;:8--&amp;gt;1,2:1
1,4&#39;:8--&amp;gt;3,4:7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，要更新的节点在右儿子那，所以把右儿子复制出来，得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
1,4&#39;:8--&amp;gt;1,2:1
1,4&#39;:8--&amp;gt;3,4&#39;:7
3,4&#39;:7--&amp;gt;3,3:5
3,4&#39;:7--&amp;gt;4,4:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在区间$[3,4]$要更新的节点在左儿子那，所以把左儿子复制出来，同时由于这是最后的节点，再从底向上更新sum，得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
1,4&#39;:4--&amp;gt;1,2:1
1,4&#39;:4--&amp;gt;3,4&#39;:3
3,4&#39;:3--&amp;gt;L3,3&#39;:1
3,4&#39;:3--&amp;gt;4,4:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上图中&lt;code&gt;L3,3&#39;:1&lt;/code&gt;是&lt;code&gt;3,4&#39;:3&lt;/code&gt;的左儿子。这样就是可持久化线段树的构造过程&lt;/p&gt;

&lt;h2 id=&#34;静态区间范围查询&#34;&gt;静态区间范围查询&lt;/h2&gt;

&lt;p&gt;现在给出区间$[L,R]$和范围$[a,b]$，求数组中在区间$[L,R]$里有多少个元素在范围$[a,b]$里。这种查询普通的线段树并不好办，那可持久化线段树有什么方法来解呢，首先我们先构造一棵空线段树，然后对数组元素做离散化，按大小映射到$[0,n-1]$，然后对离散化后的数组，按下标次序，一个一个加入到可持久化线段树里，例如数字2，那么我们就要在线段树里对2号元素+1，所以这就是可持久化权值线段树，即主席树。如此这般加入后，由于我们是按下标次序加入的，所以我们非常容易地得到表示区间$[0,R]$的线段树，那么在范围$[a,b]$里的元素数量，正好就是$[a,b]$区间和。但如果要求的是区间$[L,R]$里有多少个元素在范围$[a,b]$里，那我们除了要求出区间$[0,R]$，还要求出区间$[0,L-1]$，然后两者的$[a,b]$区间和的差，就是我们所要的答案&lt;/p&gt;

&lt;h2 id=&#34;基础模板&#34;&gt;基础模板&lt;/h2&gt;

&lt;p&gt;以下基础模板只支持区间求和，即求区间$[0,R]$里有多少个元素在范围$[a,b]$里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct persistent_seg_tree
{
    struct data
    {
        int sum;
        data() :sum(0) {}
    };
    struct node
    {
        int l, r;
        data d;
        node() :l(0), r(0) {}
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; roots;
    int sz;

    void up(int id)
    {
        nodes[id].d.sum = nodes[nodes[id].l].d.sum + nodes[nodes[id].r].d.sum;
    }
    int newnode(int cpy)
    {
        int id = (int)nodes.size();
        node tmp = nodes[cpy];
        nodes.push_back(tmp);
        return id;
    }
    int add(int tp, int tl, int tr, int i, int v)
    {
        int id = newnode(tp);
        if (tl + 1 &amp;gt;= tr)
        {
            nodes[id].d.sum += v;
            return id;
        }
        int tmid = (tl + tr) / 2;
        if (i &amp;lt; tmid)
        {
            int nid = add(nodes[id].l, tl, tmid, i, v);
            nodes[id].l = nid;
        }
        else
        {
            int nid = add(nodes[id].r, tmid, tr, i, v);
            nodes[id].r = nid;
        }
        up(id);
        return id;
    }
    int getsum(int tp, int tl, int tr, int l, int r)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return nodes[tp].d.sum;
        }
        int tmid = (tl + tr) / 2;
        int sum = 0;
        if (l &amp;lt; tmid)
        {
            sum += getsum(nodes[tp].l, tl, tmid, l, r);
        }
        if (r &amp;gt; tmid)
        {
            sum += getsum(nodes[tp].r, tmid, tr, l, r);
        }
        return sum;
    }
    // interface
    void init(int range, int root_size) // 数组大小[0, range)，操作次数
    {
        sz = range;
        nodes.clear();
        roots.clear();
        nodes.reserve(root_size * (int)(log(sz * 2.0) / log(2.0) + 1.01));
        nodes.push_back(node());
        roots.reserve(root_size + 1);
        roots.push_back(0);
    }
    void add(int pos, int v)
    {
        int last = roots.back();
        roots.push_back(add(last, 0, sz, pos, v));
    }
    int getsum(int t, int l, int r)
    {
        if (t &amp;lt;= 0) return 0;
        if (r &amp;lt; l) return 0;
        if (t &amp;gt;= (int)roots.size()) t = (int)roots.size() - 1;
        return getsum(roots[t], 0, sz, l, r + 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用说明，先调用init，参数分别是离散化后的值域大小，和数组大小（对应的就是操作完后根的个数，所以名字是&lt;code&gt;root_size&lt;/code&gt;），然后循环 &lt;code&gt;add(pos, 1)&lt;/code&gt;，最后查询时，调用&lt;code&gt;getsum(R, a, b) - getsum(L - 1, a, b)&lt;/code&gt;，LR就是区间，ab就是值域范围。&lt;/p&gt;

&lt;h2 id=&#34;静态区间第k大&#34;&gt;静态区间第k大&lt;/h2&gt;

&lt;p&gt;此问题解法较多，本篇主要介绍使用主席树的解法，同样也是先建立一棵可持久化权值线段树，对于查询区间为$[0,R]$的第k大，这个问题很简单，就是找出前缀和大于等于k的区间$[0,m]$所对应的最小的m值，所以只要对$[0,R]$所对应的线段树做查找，如果左子树的sum小于等于k，那么进入左子树查询k，否则进入右子树查询k-sum即可。但对于查询区间$[L,R]$，我们需要找出$[0,R]$和$[0,L-1]$这两棵线段树，它们的$[a,b]$区间和表示在$[L,R]$里有多少个数的值域在$[a,b]$之间，所以我们就同时对这两棵线段树做查找，设 $[0,R]$左子树的sum 减去 $[0,L-1]$左子树的sum 为S，那么如果S小于等于k，那么进入左子树查询k，否则进入右子树查询k-S，实现代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int kth(int tpl, int tpr, int tl, int tr, int k)
{
    if (tl + 1 &amp;gt;= tr) return tl;
    int tmid = (tl + tr) / 2;
    int num = nodes[nodes[tpr].l].d.sum - nodes[nodes[tpl].l].d.sum;
    if (k &amp;lt;= num) return kth(nodes[tpl].l, nodes[tpr].l, tl, tmid, k);
    else return kth(nodes[tpl].r, nodes[tpr].r, tmid, tr, k - num);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;区间第k大模板&#34;&gt;区间第k大模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct persistent_seg_tree
{
    struct data
    {
        int sum;
        data() :sum(0) {}
    };
    struct node
    {
        int l, r;
        data d;
        node() :l(0), r(0) {}
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; roots;
    int sz;

    void up(int id)
    {
        nodes[id].d.sum = nodes[nodes[id].l].d.sum + nodes[nodes[id].r].d.sum;
    }
    int newnode(int cpy)
    {
        int id = (int)nodes.size();
        node tmp = nodes[cpy];
        nodes.push_back(tmp);
        return id;
    }
    int add(int tp, int tl, int tr, int i, int v)
    {
        int id = newnode(tp);
        if (tl + 1 &amp;gt;= tr)
        {
            nodes[id].d.sum += v;
            return id;
        }
        int tmid = (tl + tr) / 2;
        if (i &amp;lt; tmid)
        {
            int nid = add(nodes[id].l, tl, tmid, i, v);
            nodes[id].l = nid;
        }
        else
        {
            int nid = add(nodes[id].r, tmid, tr, i, v);
            nodes[id].r = nid;
        }
        up(id);
        return id;
    }
    int kth(int tpl, int tpr, int tl, int tr, int k)
    {
        if (tl + 1 &amp;gt;= tr) return tl;
        int tmid = (tl + tr) / 2;
        int num = nodes[nodes[tpr].l].d.sum - nodes[nodes[tpl].l].d.sum;
        if (k &amp;lt;= num) return kth(nodes[tpl].l, nodes[tpr].l, tl, tmid, k);
        else return kth(nodes[tpl].r, nodes[tpr].r, tmid, tr, k - num);
    }
    // interface
    void init(int range, int root_size) // 数组大小[0, range)，操作次数
    {
        sz = range;
        nodes.clear();
        roots.clear();
        nodes.reserve(root_size * (int)(log(sz * 2.0) / log(2.0) + 1.01));
        nodes.push_back(node());
        roots.reserve(root_size + 1);
        roots.push_back(0);
    }
    void add(int i, int v)
    {
        int last = roots.back();
        roots.push_back(add(last, 0, sz, i, v));
    }
    int kth(int tpl, int tpr, int k)
    {
        return kth(roots[tpl - 1], roots[tpr], 0, sz, k);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它说明&#34;&gt;其它说明&lt;/h2&gt;

&lt;p&gt;其它的可持久化数据结构大同小异，如可持久化的trie，构造方法也是一样的&lt;/p&gt;

&lt;p&gt;以上只介绍了静态区间的范围查询和第k大查询，还不支持动态修改并查询，这个会在之后再做介绍。&lt;/p&gt;

&lt;p&gt;习题：静态区间范围查询&lt;a href=&#34;https://vjudge.net/problem/HDU-4417&#34; target=&#34;_blank&#34;&gt;hdu 4417&lt;/a&gt;，静态区间第k大&lt;a href=&#34;https://vjudge.net/problem/POJ-2104&#34; target=&#34;_blank&#34;&gt;POJ 2104&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>扩展KMP与Manacher</title>
      <link>/post/20191216-kmp-manacher/</link>
      <pubDate>Mon, 16 Dec 2019 18:23:00 +0800</pubDate>
      <guid>/post/20191216-kmp-manacher/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;/post/20191028-kmp/&#34;&gt;KMP&lt;/a&gt;已经介绍过了，这次主要介绍的是Manacher&lt;/p&gt;

&lt;h2 id=&#34;最长回文子串&#34;&gt;最长回文子串&lt;/h2&gt;

&lt;p&gt;Manacher算法要解决的问题就是求最长回文子串，用到的思维和扩展KMP实在是像，不过理解起来比扩展KMP简单。&lt;/p&gt;

&lt;p&gt;先定义数组v，&lt;code&gt;v[i]&lt;/code&gt;表示以第i个字符为中心，到回文串一端的距离，我们以字符串&lt;code&gt;&amp;quot;acabacab&amp;quot;&lt;/code&gt;为例，如下表（index是下标）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;i是当前要计算的指针，m是上次计算的指针，e是下一个要比较的位置的指针&lt;/p&gt;

&lt;p&gt;然后++i，注意这时候，由于以字符b两边是对称的，所以在求&lt;code&gt;v[4]&lt;/code&gt;的值的时候，可以先查&lt;code&gt;v[2]&lt;/code&gt;的值，是1，所以&lt;code&gt;v[4]&lt;/code&gt;也是1&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再继续++i，同样的，在求&lt;code&gt;v[5]&lt;/code&gt;的值的时候，可以先查&lt;code&gt;v[1]&lt;/code&gt;的值，是2，但是，这个长度达到了e指针的位置，即&lt;code&gt;i+2&amp;gt;=e&lt;/code&gt;，这时候就更新指针m，并扩展e的位置，即比较&lt;code&gt;str[7]&lt;/code&gt;与&lt;code&gt;str[3]&lt;/code&gt;，找到以下标5为中心的回文串边界。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后，&lt;code&gt;v[5]&lt;/code&gt;的值就是&lt;code&gt;e-i&lt;/code&gt;，再接着，求&lt;code&gt;v[6]&lt;/code&gt;的值就查&lt;code&gt;v[4]&lt;/code&gt;的&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再接着，求&lt;code&gt;v[7]&lt;/code&gt;的值就查&lt;code&gt;v[3]&lt;/code&gt;的，不过&lt;code&gt;v[3]&lt;/code&gt;的值是4，而&lt;code&gt;i+4&amp;gt;=e&lt;/code&gt;又满足了，就再次更新指针m，并扩展e&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最后得到的v数组最大值乘以2减1就是答案，以上指针在算法里只增不减，所以时间复杂度是 $O(n)$ 。但问题是，这只能求出奇数长度的回文串，所以，这里用到一个技巧，把原来的字符串&lt;code&gt;&amp;quot;acabacab&amp;quot;&lt;/code&gt;转成&lt;code&gt;&amp;quot;a#c#a#b#a#c#a#b&amp;quot;&lt;/code&gt;，其中#号是任意一个在原字符串中不会出现的字符，这样一来，任意原串的回文串都存在中心字符了。&lt;/p&gt;

&lt;p&gt;还有一个细节，如果要计算的串是&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;，那么回文串的长度应该是1，但是，在这个算法里，会产生越界访问，因为要判断字符a后面的&lt;code&gt;&#39;\0&#39;&lt;/code&gt;是不是与a前面的字符相同，如果正好都是&lt;code&gt;&#39;\0&#39;&lt;/code&gt;，就会导致计算错误。所以，计算的时候还要对原来的字符串在最前面添加第二个在原字符串中不会出现的字符，例如转成&lt;code&gt;&amp;quot;$a#c#a#b#a#c#a#b&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;扩展kmp模板和manacher模板对比&#34;&gt;扩展KMP模板和Manacher模板对比&lt;/h2&gt;

&lt;p&gt;代码高度相似，你看看就知道了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void extkmp_z(const char* str, int z[])
{
    int s_len = strlen(str);
    z[0] = s_len;
    for (int i = 1, p = 1, e = 1; i &amp;lt; s_len; ++i)
    {
        if (i + z[i - p] &amp;gt;= e)
        {
            e = std::max(i, e);
            p = i;

            while (e &amp;lt; s_len &amp;amp;&amp;amp; str[e] == str[e - i])
                ++e;

            z[i] = e - i;
        }
        else
            z[i] = z[i - p];
    }
}

void extkmp_ext(const char* str, int ext[], const char* pattern, int z[])
{
    int s_len = strlen(str);
    extkmp_z(pattern, z);
    for (int i = 0, p = 0, e = 0; i &amp;lt; s_len; ++i)
    {
        if (i + z[i - p] &amp;gt;= e)
        {
            e = std::max(i, e);
            p = i;

            while (e &amp;lt; s_len &amp;amp;&amp;amp; str[e] == pattern[e - i])
                ++e;

            ext[i] = e - i;
        }
        else
            ext[i] = z[i - p];
    }
}

void init_str(const char* str, char* t)
{
    int len = strlen(str);
    t[0] = &#39;$&#39;;
    t[1] = &#39;#&#39;;
    for (int i = 0; str[i]; ++i)
    {
        t[(i + 1) &amp;lt;&amp;lt; 1] = str[i];
        t[((i + 1) &amp;lt;&amp;lt; 1) + 1] = &#39;#&#39;;
    }
    t[(len + 1) &amp;lt;&amp;lt; 1] = 0;
}

int manacher(const char* s, int v[])
{
    int len = strlen(s);
    int max_len = 0;
    v[0] = 1;
    v[1] = 1;
    for (int i = 1, m = 1, e = 1; i &amp;lt; len; ++i)
    {
        if (i + v[m - (i - m)] &amp;gt;= e)
        {
            e = std::max(i, e);
            m = i;

            while (e &amp;lt; len &amp;amp;&amp;amp; s[e] == s[i - (e - i)])
                ++e;

            v[i] = e - i;
        }
        else
            v[i] = v[m - (i - m)];
        max_len = std::max(max_len, v[i]);
    }
    return max_len - 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是第一种写法的模板，再对比写法二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
void extkmp_ext(const char* str, int ext[], const char* pattern, int z[])
{
    int s_len = strlen(str);
    extkmp_z(pattern, z);
    for (int i = 0, l = 0, r = 0; i &amp;lt; s_len; ++i)
    {
        if (i &amp;lt; r)
        {
            ext[i] = std::min(r - i, z[i - l]);
        }
        else
        {
            ext[i] = 0;
        }
        while (i + ext[i] &amp;lt; s_len &amp;amp;&amp;amp; str[i + ext[i]] == pattern[ext[i]])
        {
            ++ext[i];
        }
        if (i + ext[i] &amp;gt; r)
        {
            r = i + ext[i];
            l = i;
        }
    }
}

int manacher(const char* s, int v[])
{
    int len = strlen(s);
    int max_len = 0;
    for (int i = 1, m = 1, r = 1; i &amp;lt; len; ++i)
    {
        if (i &amp;lt; r)
        {
            v[i] = std::min(v[m - (i - m)], r - i);
        }
        else
        {
            v[i] = 1;
        }
        while (s[i + v[i]] == s[i - v[i]])
        {
            ++v[i];
        }
        if (i + v[i] &amp;gt; r)
        {
            r = i + v[i];
            m = i;
        }
        max_len = std::max(max_len, v[i]);
    }
    return max_len - 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它解法&#34;&gt;其它解法&lt;/h2&gt;

&lt;p&gt;用后缀数组来解回文串也是可以的，原串是s的话，把s反向，得到s1，然后构造&lt;code&gt;S = s + &#39;#&#39; + s1&lt;/code&gt;，对S求后缀数组后，要注意的是并不是只找height的最大值即可，网上很多文章在这里的算法是错误的，反例是&lt;code&gt;abcdefba&lt;/code&gt;，&lt;strong&gt;单纯枚举相邻的sa是不正确的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;正确做法是枚举i从1到len(s)/2，分别针对奇数长度和偶数长度要分别计算LCP（最长公共前缀），奇数长度时它的对称位置就是&lt;code&gt;j=len-i+1&lt;/code&gt;，偶数长度时对称位置是&lt;code&gt;j=len-i&lt;/code&gt;或&lt;code&gt;j=len-i+2&lt;/code&gt;，然后对height数组求从&lt;code&gt;rank[i]+1&lt;/code&gt;到&lt;code&gt;rank[j]&lt;/code&gt;的最小值。最小值维护用ST表，由于ST表的构造是 $O(nlogn)$ ，而查询是 $O(1)$ ，所以生成后缀数组后的计算的总时间复杂度是 $O(nlogn)$&lt;/p&gt;

&lt;p&gt;示例代码&lt;a href=&#34;https://vjudge.net/problem/URAL-1297&#34; target=&#34;_blank&#34;&gt;URAL 1297&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int st[12][2048];

void init_st(int a[], int n)
{
    for (int i = 0; i &amp;lt; n; i++)
        st[0][i] = a[i];
    for (int k = 1; (1 &amp;lt;&amp;lt; k) &amp;lt; n; k++)
        for (int i = 0, m = 1 &amp;lt;&amp;lt; (k - 1); i &amp;lt; n; i++)
            if (i + m &amp;lt; n) st[k][i] = min(st[k - 1][i], st[k - 1][i + m]);
}

int st_query(int l, int r) // [l, r)
{
    if (l &amp;gt; r)swap(l, r);
    int k = (int)(log(r - l - 0.1) / log(2));
    return min(st[k][l], st[k][r - (1 &amp;lt;&amp;lt; k)]);
}

int main()
{
    int n, t;
    char s[2100], s1[1010];
    scanf(&amp;quot;%s&amp;quot;, s1);
    strcpy(s, s1);
    strcat(s, &amp;quot;#&amp;quot;);
    strcat(s, strrev(s1));
    SA_2_sort sa;
    sa.init(s);
    int len = sa.size();
    int maxh = 0, spos = 0;
    init_st(&amp;amp;*sa.ht.begin(), len + 1);
    for(int i = 1; i &amp;lt;= len / 2; ++i)
    {
        int j = len - i + 1;
        int lcp = st_query(sa.rk[i] + 1, sa.rk[j] + 1);
        if (lcp * 2 - 1 &amp;gt; maxh)
        {
            spos = i - lcp;
            maxh = lcp * 2 - 1;
        }
        if (i &amp;gt; 1)
        {
            j = len - i + 2;
            lcp = st_query(sa.rk[i] + 1, sa.rk[j] + 1);
            if (lcp * 2 &amp;gt; maxh)
            {
                spos = i - lcp - 1;
                maxh = lcp * 2;
            }
        }
    }
    strncpy(s1, s + spos, maxh);
    s1[maxh] = 0;
    puts(s1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：后缀数组模板请从&lt;a href=&#34;/post/20191113-suffixarray/&#34;&gt;之前的文章&lt;/a&gt;里复制；函数st_query是左闭右开区间，即求的是&lt;code&gt;[l, r-1]&lt;/code&gt;的最小值，采用半开半闭区间目的是为了能直接swap&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>FHQ Treap</title>
      <link>/post/20191215-fhq-treap/</link>
      <pubDate>Sun, 15 Dec 2019 13:10:00 +0800</pubDate>
      <guid>/post/20191215-fhq-treap/</guid>
      <description>&lt;p&gt;讲完了&lt;a href=&#34;/post/20191211-treap-sbt/&#34;&gt;treap&lt;/a&gt;和&lt;a href=&#34;/post/20191213-tree-sequence/&#34;&gt;splaytree&lt;/a&gt;，接下来讲把这两的思想混合在一起的 FHQ Treap，据说作者是范浩强。&lt;/p&gt;

&lt;p&gt;splay其实还有两个操作split和merge没有介绍，我打算把这两放在这里一并介绍&lt;/p&gt;

&lt;h2 id=&#34;split和merge&#34;&gt;Split和Merge&lt;/h2&gt;

&lt;p&gt;Split就是把树按某个条件划分成两棵子树，如果是查找树，就按某个值划分为小于它的以及大于等于它的（等于号取哪边怎么好写怎么来就是），如果是序列维护，那就按照rank来划分。而merge操作则正好相反，把两棵子树合并成为一棵。所以，如果我们需要对某个区间做操作，那么我们就把那个区间Split出来，操作好了后（打懒惰标记，或取出结果）再Merge回去就行了，与splay操作的思路是差不多的。不过为了在split再merge后能间接对树的平衡性优化，我们不能简单地merge，要套用Treap的随机数法，我们先来看怎么split。&lt;/p&gt;

&lt;p&gt;先定义好接口&lt;code&gt;void split(int tp, int k, int &amp;amp;x, int &amp;amp;y)&lt;/code&gt;，x是返回的左子树，y是返回的右子树，接着我们需要递归split，如果划分点在左子树，那么y一定是根，反之划分点在右子树，那么x一定是根。确定了其中一个，在递归调用的时候，假如y确定了，于是还没确定的，就是x以及根节点的左子树的指向，所以把这两传参就行了，时间复杂度 $O(logn)$ ，具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 维护序列的实现
void split(int tp, int k, int &amp;amp;x, int &amp;amp;y)
{
    if (!tp) { x = y = 0; return; }
    pushdown(tp);
    if (k &amp;lt;= nodes[ch(tp, 0)].sz)
    {
        y = tp;
        split(ch(tp, 0), k, x, ch(tp, 0));
        update(y);
    }
    else
    {
        x = tp;
        split(ch(tp, 1), k - nodes[ch(tp, 0)].sz - 1, ch(tp, 1), y);
        update(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来讲讲merge，我们不能直接把右子树直接接在左子树的最后一个元素后，这样会导致树高度太大。在Treap里面，引入了一个随机值，来决定谁来做根节点，所以，我们就对比这个值，如果左子树的小，那么就让左子树的右儿子与右子树merge，否则就让右子树的左儿子与左子树merge，递归调用就是了，时间复杂度 $O(logn)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int merge(int tl, int tr)
{
    if (!tl) return tr;
    else if (!tr) return tl;
    if (nodes[tl].k &amp;lt; nodes[tr].k)
    {
        pushdown(tl);
        ch(tl, 1) = merge(ch(tl, 1), tr);
        return update(tl);
    }
    else
    {
        pushdown(tr);
        ch(tr, 0) = merge(tl, ch(tr, 0));
        return update(tr);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基本模板&#34;&gt;基本模板&lt;/h2&gt;

&lt;p&gt;这么快就给模板了？没错，你在理解了Treap以后，再去学习&lt;code&gt;FHQ-Treap&lt;/code&gt;那是相当简单的，最复杂的两个操作已经讲完了，相比Treap，它不需要旋转操作，而通过merge操作来让树平衡，而且这组操作让其它的操作相比Treap都来得简单，最不容易写出BUG，代码也是最短的一个，常数也比splaytree小，所有操作的期望时间复杂度都是 $O(logn)$ 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
struct FHQ_Treap
{
    struct data
    {
        T v;
        data(int _v = 0) :v(_v) {}
        data operator + (const data&amp;amp; d) const
        {
            data r;
            r.v = v + d.v;
            return r;
        }
        data operator * (int t) const
        {
            data r;
            r.v = v * t;
            return r;
        }
        operator bool() const { return v != 0; }
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], sz;
        unsigned k;
        data d, sum, lz_add;
        node(int z = 1) :sz(z), k(rnd()) { ch[0] = ch[1] = 0; }
        static unsigned rnd()
        {
            static unsigned r = 0x123;
            r = r * 69069 + 1;
            return r;
        }
    };
    vector&amp;lt;node&amp;gt; nodes;
    int root;
    int recyc;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    inline int&amp;amp; ch(int tp, int r) { return nodes[tp].ch[r]; }
    int new_node(const data&amp;amp; d)
    {
        int id = (int)nodes.size();
        if (recyc)
        {
            id = recyc;
            if (ch(recyc, 0) &amp;amp;&amp;amp; ch(recyc, 1))
                recyc = merge(ch(recyc, 0), ch(recyc, 1));
            else
                recyc = ch(recyc, 0) ? ch(recyc, 0) : ch(recyc, 1);
            nodes[id] = node();
        }
        else nodes.push_back(node());
        nodes[id].d = d;
        nodes[id].sum = d;
        return id;
    }
    int update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
        n.sum = n.d + nodes[n.ch[0]].sum + nodes[n.ch[1]].sum;
        return tp;
    }
    void add(int tp, const data&amp;amp; d)
    {
        node&amp;amp; n = nodes[tp];
        n.lz_add = n.lz_add + d;
        n.d = n.d + d;
        n.sum = n.sum + d * n.sz;
    }
    void pushdown(int tp)
    {
        node&amp;amp; n = nodes[tp];
        if (n.lz_add)
        {
            add(n.ch[0], n.lz_add); add(n.ch[1], n.lz_add);
            n.lz_add = 0;
        }
    }
    int merge(int tl, int tr)
    {
        if (!tl) return tr;
        else if (!tr) return tl;
        if (nodes[tl].k &amp;lt; nodes[tr].k)
        {
            pushdown(tl);
            ch(tl, 1) = merge(ch(tl, 1), tr);
            return update(tl);
        }
        else
        {
            pushdown(tr);
            ch(tr, 0) = merge(tl, ch(tr, 0));
            return update(tr);
        }
    }
    void split(int tp, int k, int &amp;amp;x, int &amp;amp;y)
    {
        if (!tp) { x = y = 0; return; }
        pushdown(tp);
        if (k &amp;lt;= nodes[ch(tp, 0)].sz)
        {
            y = tp;
            split(ch(tp, 0), k, x, ch(tp, 0));
            update(y);
        }
        else
        {
            x = tp;
            split(ch(tp, 1), k - nodes[ch(tp, 0)].sz - 1, ch(tp, 1), y);
            update(x);
        }
    }
    void remove(int&amp;amp; tp)
    {
        if (recyc == 0) recyc = tp;
        else recyc = merge(recyc, tp);
        tp = 0;
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        nodes.reserve((size = max(size, 15)) + 1);
        nodes.push_back(node(0));
        root = 0;
        recyc = 0; reserve_size = size + 1;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz; }
    int kth(int k)
    {
        int x, y, z;
        split(root, k, y, z); split(y, k - 1, x, y);
        int id = y;
        root = merge(merge(x, y), z);
        return id;
    }
    void insert(int k, data v)
    {
        int l, r;
        split(root, k - 1, l, r);
        int tp = new_node(v);
        root = merge(merge(l, tp), r);
    }
    void erase(int l, int r)
    {
        int x, y, z;
        split(root, r, y, z); split(y, l - 1, x, y);
        remove(y);
        root = merge(x, z);
    }
    void range_add(int l, int r, data v)
    {
        int x, y, z;
        split(root, r, y, z); split(y, l - 1, x, y);
        add(y, v);
        root = merge(merge(x, y), z);
    }
    T getsum(int l, int r)
    {
        int x, y, z;
        split(root, r, y, z); split(y, l - 1, x, y);
        T ret = nodes[y].sum;
        root = merge(merge(x, y), z);
        return ret;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是个支持区间加、区间删和区间求和的模板。除了LCT，都交给这个数据结构解决吧。&lt;/p&gt;

&lt;h2 id=&#34;其它问题&#34;&gt;其它问题&lt;/h2&gt;

&lt;p&gt;如果你要问为什么不一开始就介绍这个，而先解释其它的树结构，那是因为那是基础啊，基础搞好了，那再搞这个就很简单了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>平衡树与序列维护</title>
      <link>/post/20191213-tree-sequence/</link>
      <pubDate>Fri, 13 Dec 2019 13:10:00 +0800</pubDate>
      <guid>/post/20191213-tree-sequence/</guid>
      <description>&lt;p&gt;平衡树除了用来对存在偏序关系的数据进行维护，还能用于对序列维护，相当于一个数组。阅读本文你需要先看完上一篇关于&lt;a href=&#34;/post/20191211-treap-sbt/&#34;&gt;treap&lt;/a&gt;的文章。&lt;/p&gt;

&lt;h2 id=&#34;序列维护&#34;&gt;序列维护&lt;/h2&gt;

&lt;p&gt;在之前的文章，我们介绍过使用树状数组，以及线段树来维护一个序列，可以做区间操作及区间求和，但它们都存在一个缺点，不能动态插入数据。那我们怎么样才能通过平衡树来维护序列呢，之前我们有一个size字段能快速找第k大（或树的中序遍历第k个元素），而旋转操作并不会改变元素之间的相对顺序，那么我们就通过它直接插入到第k个元素的前面，这样我们插入的时候就不再通过要插入的值本身的大小关系，而需要多加一个参数k决定插入的位置。当平衡树用于维护序列的时候，就不用考虑元素相等的问题了。这样我们把元素相等处理的代码删除并修改基本操作的代码就能得到第一个能维护序列的基本模板，以下模板使用Treap修改得来。&lt;/p&gt;

&lt;h2 id=&#34;基本模板&#34;&gt;基本模板&lt;/h2&gt;

&lt;p&gt;以下模板我实现成真·模板，就几乎可以作为数组使用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt;
struct treap_seq
{
    struct data
    {
        T v;
        data(T _v = 0) :v(_v) {}
        operator bool() const { return v != 0; }
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], sz;
        unsigned k;
        data d;
        node(int z = 1) :sz(z), k(rnd()) { d = ch[0] = ch[1] = 0; }
        void clone(const node&amp;amp; n) { d = n.d; }
        static unsigned rnd()
        {
            static unsigned r = 0x123;
            r = r * 69069 + 1;
            return r;
        }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
    }
    int insert(int&amp;amp; tp, int k, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = insert(s, k - sz * r, d);
        update(s);
        if (nodes[s].k &amp;lt; n.k) rotate(tp, r);
        else update(tp);
        return ret;
    }
    void rotate(int&amp;amp; tp, int r)
    {
        node&amp;amp; n = nodes[tp];
        int s = n.ch[r];
        n.ch[r] = nodes[s].ch[r ^ 1];
        nodes[s].ch[r ^ 1] = tp;
        update(tp); update(s);
        tp = s;
    }
    int erasefind(int&amp;amp; tp, int k) // return deleted
    {
        if (tp == 0) return 0;
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        if (sz == k)
        {
            remove(tp);
            return 1;
        }
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = erasefind(s, k - sz * r);
        if (ret)
        {
            update(tp);
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int r = nodes[nodes[tp].ch[0]].k &amp;lt; nodes[nodes[tp].ch[1]].k;
            rotate(tp, r ^ 1);
            remove(nodes[tp].ch[r]);
            update(tp);
        }
    }
    int kth(int tp, int k) // return id
    {
        if (tp == 0) return tp;
        node n = nodes[tp];
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + 1 &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - 1);
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz; }
    int insert(int k, data v) { if (size() &amp;gt;= reserve_size) nodes.reserve((reserve_size *= 2) + 1); return insert(root, k, v); }
    int erase(int k) { return erasefind(root, k); }
    int kth(int k) { return kth(root, k); } // return id
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;动态版本线段树&#34;&gt;动态版本线段树&lt;/h2&gt;

&lt;p&gt;有了这个，我们就可以把它改成动态版本的线段树，就是每个根节点多维护一个sum字段，再加一个懒惰标记，就能实现区间加和区间求和。不过和线段树不同的是，线段树的子树的根只维护区间的结果，而平衡树的根本身就是一个元素，所以代码和线段树略有差别。以下我们实现一个支持区间加和区间求和且能动态增减数据的平衡树，实测与前面讲线段树文章的普通线段树模板，在解决同一问题的执行时间非常接近&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt;
struct treap_seq
{
    struct data
    {
        T v;
        data(T _v = 0) :v(_v) {}
        data operator + (const data&amp;amp; d) const
        {
            data r;
            r.v = v + d.v;
            return r;
        }
        data operator * (int t) const
        {
            data r;
            r.v = v * t;
            return r;
        }
        operator bool() const { return v != 0; }
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], sz;
        unsigned k;
        data d;
        data sum;
        data lz_add;
        node(int z = 1) :sz(z), k(rnd()) { sum = lz_add = d = ch[0] = ch[1] = 0; }
        void clone(const node&amp;amp; n) { d = n.d; sum = n.sum; }
        static unsigned rnd()
        {
            static unsigned r = 0x123;
            r = r * 69069 + 1;
            return r;
        }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void _add(int tp, const data&amp;amp; d)
    {
        node&amp;amp; n = nodes[tp];
        n.lz_add = n.lz_add + d;
        n.d = n.d + d;
        n.sum = n.sum + d * n.sz;
    }
    void pushdown(int tp)
    {
        node&amp;amp; n = nodes[tp];
        if (n.lz_add)
        {
            _add(n.ch[0], n.lz_add);
            _add(n.ch[1], n.lz_add);
            n.lz_add = 0;
        }
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
        n.sum = n.d + nodes[n.ch[0]].sum + nodes[n.ch[1]].sum;
    }
    int insert(int&amp;amp; tp, int k, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            nodes[tp].sum = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        pushdown(tp);
        int sz = nodes[n.ch[0]].sz + 1;
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = insert(s, k - sz * r, d);
        update(s);
        if (nodes[s].k &amp;lt; n.k) rotate(tp, r);
        else update(tp);
        return ret;
    }
    void rotate(int&amp;amp; tp, int r)
    {
        node&amp;amp; n = nodes[tp];
        pushdown(tp);
        int s = n.ch[r];
        pushdown(s);
        n.ch[r] = nodes[s].ch[r ^ 1];
        nodes[s].ch[r ^ 1] = tp;
        update(tp); update(s);
        tp = s;
    }
    int erasefind(int&amp;amp; tp, int k) // return deleted
    {
        if (tp == 0) return 0;
        node&amp;amp; n = nodes[tp];
        pushdown(tp);
        int sz = nodes[n.ch[0]].sz + 1;
        if (sz == k)
        {
            remove(tp);
            return 1;
        }
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = erasefind(s, k - sz * r);
        if (ret)
        {
            update(tp);
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int r = nodes[nodes[tp].ch[0]].k &amp;lt; nodes[nodes[tp].ch[1]].k;
            rotate(tp, r ^ 1);
            remove(nodes[tp].ch[r]);
            update(tp);
        }
    }
    int kth(int tp, int k) // return id
    {
        if (tp == 0) return tp;
        node n = nodes[tp];
        pushdown(tp);
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + 1 &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - 1);
    }
    data getsum(int&amp;amp; tp, int l, int r)
    {
        if (tp == 0 || l &amp;gt;= r) return 0;
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        if (l &amp;lt;= 1 &amp;amp;&amp;amp; r &amp;gt; n.sz)
        {
            return n.sum;
        }
        else
        {
            pushdown(tp);
            data sum = 0;
            if (l &amp;lt;= sz &amp;amp;&amp;amp; sz &amp;lt; r)
            {
                sum = nodes[tp].d;
            }
            sum = sum + getsum(n.ch[0], l, min(sz, r));
            sum = sum + getsum(n.ch[1], max(1, l - sz), r - sz);
            return sum;
        }
    }
    void range_add(int&amp;amp; tp, int l, int r, const data&amp;amp; d)
    {
        if (tp == 0 || l &amp;gt;= r) return;
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        if (l &amp;lt;= 1 &amp;amp;&amp;amp; r &amp;gt; n.sz)
        {
            _add(tp, d);
        }
        else
        {
            //pushdown(tp);
            if (l &amp;lt;= sz &amp;amp;&amp;amp; sz &amp;lt; r)
            {
                nodes[tp].d = nodes[tp].d + d;
            }
            nodes[tp].sum = nodes[tp].sum + d * (r - l);
            range_add(n.ch[0], l, min(sz, r), d);
            range_add(n.ch[1], max(1, l - sz), r - sz, d);
        }
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz; }
    int insert(int k, data v) { reserve(); return insert(root, k, v); }
    int erase(int k) { return erasefind(root, k); }
    int kth(int k) { return kth(root, k); } // return id
    T getsum(int l, int r) { return getsum(root, l, r + 1); }
    void range_add(int l, int r, data v) { range_add(root, l, r + 1, v); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;splay-tree&#34;&gt;Splay tree&lt;/h2&gt;

&lt;p&gt;使用以上这个Treap的自由度还是不够好，有些操作还是不容易做，例如区间翻转，或者区间删除。所以我们需要一个功能更为强大的树，因为那个随机数的限制，不能任意节点都能当树根，而没有那个随机数字段的树，就是伸展树Splay tree，区别主要是三个地方，一是需要父节点字段，维护关系时常数更大，二是旋转，使用双旋，三是splay操作，作用是把节点提升到树根。这个splay操作就是神器，能把很多区间操作写得非常简单，代码也确实是目前介绍的树里面代码最少的。不过伸展树的缺点是编码理解难度稍大。&lt;/p&gt;

&lt;p&gt;和其它树的不同点是，为了保证区间操作代码简短，初始化的时候直接插入两个元素作为序列的一头一尾，于是实际操作区间是2到n+1，这个细节要注意，有了这两个元素可以减少很多特判操作。例如说，要找区间&lt;code&gt;[l,r]&lt;/code&gt;，那么只要让位置r+1的元素splay到根，然后再让位置l-1的元素splay到根的左边，那么l-1位的元素的右子树就是整个操作区间了，而为了让这个总是能做，所以才要预先加两个元素。这个技巧用在了几乎所有操作里面，包括插入，删除，所有的区间操作。splay操作的时间复杂度 $O(logn)$&lt;/p&gt;

&lt;p&gt;以下是序列维护用的基本splaytree模板，要改成支持区间求和什么的就自己改吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
struct splaytree_seq
{
    struct data
    {
        T v;
        data(int _v = 0) :v(_v) {}
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], fa, sz;
        data d;
        node(int z = 1) :sz(z) { ch[0] = ch[1] = fa = 0; }
    };
    vector&amp;lt;node&amp;gt; nodes;
    int root;
    int recyc;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    inline int&amp;amp; ch(int tp, int r) { return nodes[tp].ch[r]; }
    inline int&amp;amp; fa(int tp) { return nodes[tp].fa; }
    inline int rch(int tp) { return ch(fa(tp), 1) == tp; }
    int new_node()
    {
        int id = (int)nodes.size();
        if (recyc)
        {
            id = recyc;
            if (ch(recyc, 0) &amp;amp;&amp;amp; ch(recyc, 1))
                recyc = merge(ch(recyc, 0), ch(recyc, 1));
            else
                recyc = ch(recyc, 0) ? ch(recyc, 0) : ch(recyc, 1);
            fa(recyc) = 0;
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
    }
    void add(int tp, const data&amp;amp; d)
    {
        node&amp;amp; n = nodes[tp];
        n.d = n.d + d;
    }
    void rotate(int s)
    {
        int f1 = fa(s), f2 = fa(f1);
        int d1 = rch(s), d2 = rch(f1);
        ch(f2, d2) = s; fa(s) = f2;
        fa(ch(s, d1 ^ 1)) = f1; ch(f1, d1) = ch(s, d1 ^ 1);
        fa(f1) = s; ch(s, d1 ^ 1) = f1;
        update(f1); update(s);
    }
    void splay(int tp, int goal = 0)
    {
        for (int f; (f = fa(tp)) != goal; rotate(tp))
            if (fa(f) != goal) rotate(rch(tp) == rch(f) ? f : tp);
        if (!goal) root = tp;
    }
    int find_m(int tp, int r)
    {
        int p = tp;
        while (ch(p, r)) p = ch(p, r);
        if (p != tp) splay(p, tp);
        return p;
    }
    int merge(int tl, int tr)
    {
        if (!tl) { fa(tr) = 0; return tr; }
        if (!tr) { fa(tl) = 0; return tl; }
        int p = find_m(tl, 1);
        ch(p, 1) = tr; fa(tr) = p;
        return tl;
    }
    void insert(int k, const data&amp;amp; d)
    {
        int tp = new_node();
        splay(kth(root, k + 1)); splay(kth(root, k), root);
        int c = ch(root, 0);
        nodes[c].ch[1] = tp;
        nodes[tp].fa = c;
        nodes[tp].d = d;
        update(c); update(root);
    }
    void remove(int&amp;amp; tp)
    {
        fa(tp) = 0;
        if (recyc == 0) recyc = tp;
        else recyc = merge(recyc, tp);
        tp = 0;
    }
    int kth(int tp, int k)
    {
        if (tp == 0) return tp;
        node&amp;amp; n = nodes[tp];
        //pushdown(tp);
        int sz = nodes[n.ch[0]].sz + 1;
        if (sz &amp;gt; k) return kth(n.ch[0], k);
        if (sz &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz);
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        nodes.reserve((size = max(size, 15)) + 1);
        nodes.push_back(node(0));
        nodes.push_back(node()); nodes.push_back(node());
        nodes[1].ch[0] = 2; nodes[1].sz = 2; nodes[2].fa = 1;
        root = 1; // be the bound
        recyc = 0; reserve_size = size + 1;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz - 2; }
    int kth(int k) { int id = kth(root, k + 1); splay(id); return id; }
    void erase(int l, int r)
    {
        splay(kth(root, r + 2)); splay(kth(root, l), root);
        remove(ch(ch(root, 0), 1));
        update(ch(root, 0)); update(root);
    }
    void range_add(int l, int r, data v)
    {
        splay(kth(root, r + 2)); splay(kth(root, l), root);
        add(ch(ch(root, 0), 1), v);
        update(ch(root, 0)); update(root);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上已经直接写好了区间删除，对于区间反转等操作，可以模仿线段树加懒惰标记即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Treap与SBT</title>
      <link>/post/20191211-treap-sbt/</link>
      <pubDate>Wed, 11 Dec 2019 13:10:00 +0800</pubDate>
      <guid>/post/20191211-treap-sbt/</guid>
      <description>&lt;p&gt;这里之所以把这两个放在一起讲，是因为它们实在是相似度很高（至少在竞赛领域），都需要求kth和指定元素的rank（Treap的话可有可无，但通常会需要）。不过如果你没有写过树，强烈建议你自己通过理解来写一遍。&lt;/p&gt;

&lt;h2 id=&#34;bst&#34;&gt;BST&lt;/h2&gt;

&lt;p&gt;首先，Treap和SBT都属于BST的一种，BST就是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&#34; target=&#34;_blank&#34;&gt;二叉搜索树&lt;/a&gt;，它满足的特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;二叉树&lt;/li&gt;
&lt;li&gt;没有两个节点的值相等&lt;/li&gt;
&lt;li&gt;任意子树的根节点的值都比左子树所有节点的值要大&lt;/li&gt;
&lt;li&gt;任意子树的根节点的值都比右子树所有节点的值要小&lt;/li&gt;
&lt;li&gt;任意子树均为二叉搜索树&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果我们实在需要支持多个相同值放在树里面，那么有两种情况，如果那些相同值是确实完全没有区别（例如int），那么只需要在每个节点多加一个字段记录这个值出现的次数就可以了，但如果这些值只有偏序关系，可能不是严格相等，存在其它非比较字段，那么我们就再在每个节点增加一个next域做成一个链表即可。&lt;/p&gt;

&lt;p&gt;基本操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;插入(insert)：对比子树的根节点的值r与插入的值v，如果v与r相等，根节点重复数量+1，如果v小于r，插入到左子树，v大于r则插入到右子树&lt;/li&gt;
&lt;li&gt;查找(find)：和插入相似，值相等时返回其id&lt;/li&gt;
&lt;li&gt;删除(erase)：先查找，找到的时候，再查找它的后继（右子树的最小），用后继元素替换后再删除原后继&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;支持简单重复元素的bst模板&#34;&gt;支持简单重复元素的BST模板&lt;/h2&gt;

&lt;p&gt;这个模板还添加了size域，用于求第k小元素和元素排名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct bst
{
    struct data
    {
        int v;
        data(int _v = 0) :v(_v) {}
        bool operator==(const data&amp;amp; d) const
        {
            return v == d.v;
        }
        bool operator&amp;lt;(const data&amp;amp; d) const
        {
            return v &amp;lt; d.v;
        }
    };
    struct node
    {
        int ch[2], sz, dup;
        data d;
        node(int z = 1) :sz(z), dup(z) { ch[0] = ch[1] = 0; }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    int insert(int&amp;amp; tp, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        ++n.sz;
        if (d == n.d)
        {
            ++n.dup;
            return tp;
        }
        int r = d &amp;lt; n.d;
        int&amp;amp; s = n.ch[r ^ 1];
        int ret = insert(s, d);
        return ret;
    }
    int find(int tp, const data&amp;amp; d) // return id
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d) return tp;
        return find(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d);
    }
    int erasefind(int&amp;amp; tp, const data&amp;amp; d) // return deleted
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d)
        {
            --nodes[tp].sz;
            if (--nodes[tp].dup &amp;lt;= 0) remove(tp);
            return 1;
        }
        if (erasefind(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d))
        {
            --nodes[tp].sz;
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int nxt = nodes[tp].ch[1];
            while (nodes[nxt].ch[0])
                nxt = nodes[nxt].ch[0];
            int dup = nodes[nxt].dup;
            nodes[tp].d = nodes[nxt].d;
            nodes[tp].dup = nodes[nxt].dup;
            recycle.push_back(nxt);
            int* tmp = &amp;amp;nodes[tp].ch[1];
            while (nodes[*tmp].ch[0])
            {
                nodes[*tmp].sz -= dup;
                tmp = &amp;amp;nodes[*tmp].ch[0];
            }
            *tmp = nodes[*tmp].ch[1];
        }
    }
    int kth(int tp, int k) // return id
    {
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + n.dup &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - n.dup);
    }
    int rank(int tp, const data&amp;amp; d, int dup)
    {
        if (tp == 0) return 1;
        node&amp;amp; n = nodes[tp];
        if (d == n.d) return nodes[n.ch[0]].sz + 1 + dup * n.dup;
        else if (d &amp;lt; n.d) return rank(n.ch[0], d, dup);
        return rank(n.ch[1], d, dup) + nodes[n.ch[0]].sz + n.dup;
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    int get(int id) { return nodes[id].d.v; }
    int size() { return nodes[root].sz; }
    int insert(data v) { reserve(); return insert(root, v); }
    int erase(data v) { return erasefind(root, v); }
    int find(data v) { return find(root, v); } // return id
    int kth(int k) { return kth(root, k); } // return id
    // upperbound when upper = 1
    int rank(data v, int upper = 0) { return rank(root, v, upper); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一些说明&#34;&gt;一些说明&lt;/h3&gt;

&lt;p&gt;子节点用的节段是ch数组(child的缩写)，不使用left和right的原因是为了节省代码，例如在insert函数里，通过计算&lt;code&gt;d &amp;lt; n.d&lt;/code&gt;的值是0或1决定下一步是递归调用左还是右子节点的时候，就不需要分别针对left和right写代码，后面的find和erase同理。&lt;/p&gt;

&lt;p&gt;rank函数在upper为0的时候，找到的是相同元素里面最小的排名，如果v不存在树里面，那么就是v假如要插入到树里的排名。upper为1的时候，找到的是大于v的最小的元素的排名，即v的后继。&lt;/p&gt;

&lt;p&gt;kth函数的参数如果非法，会导致无限循环，如果你想避免那么你可以在函数里添加检查，例如加一句&lt;code&gt;if (tp == 0) return 0;&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;优化bst&#34;&gt;优化BST&lt;/h2&gt;

&lt;p&gt;单纯的BST最大的问题是，它最坏的情况是可能成为一条链表，例如你按从小到大插入到树里面的时候，缺乏让它缩减树高的机制，所以接下来要讲两个非常重要的操作，就是树的旋转&lt;/p&gt;

&lt;p&gt;图A&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
4--&amp;gt;2
2--&amp;gt;1
2--&amp;gt;3
4--&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图B&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
2--&amp;gt;4
4--&amp;gt;3
2--&amp;gt;1
4--&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两图，从A到B叫做zig，把左儿子旋转到root的位置，也叫右旋，B到A叫做zag，把右儿子旋转到root的位置，也叫左旋，旋转代码也很简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void rotate(int&amp;amp; tp, int r)
{
    node&amp;amp; n = nodes[tp];
    int s = n.ch[r];
    n.ch[r] = nodes[s].ch[r ^ 1];
    nodes[s].ch[r ^ 1] = tp;
    tp = s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上参数r如果是0，就是zig，r是1就是zag。有了旋转操作，我们就可以开始看自平衡树了。&lt;/p&gt;

&lt;h2 id=&#34;treap&#34;&gt;Treap&lt;/h2&gt;

&lt;p&gt;Treap其实炒鸡简单，在BST的基础上多一个随机数生成的字段，这个字段用于决定树要怎么旋转。这个字段就是个优先级，父节点的优先级不大于两个子节点的优先级，这其实就是heap，所以，Treap就是树堆（Tree-heap）。维护Treap，我们只需要在insert的时候，检查是不是满足heap，如果不满足就旋转，相对BST只加了非常少的代码，也就加了rotate函数，rnd函数（直接用rand也行），insert加了维护，以及旋转时需要的update函数维护size字段，也就是说Treap是最经济实惠的平衡树。&lt;/p&gt;

&lt;p&gt;操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更新(update): 累加左右子树的size&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除(erase): 找到要删除的元素后，对比两子树的根的优先级，把较的小旋转到原来要删除的元素的位置，使要删除的元素的深度+1，直到删除的元素没有两个子树为止&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct treap
{
struct data
{
    int v;
    data(int _v = 0) :v(_v) {}
    bool operator==(const data&amp;amp; d) const
    {
        return v == d.v;
    }
    bool operator&amp;lt;(const data&amp;amp; d) const
    {
        return v &amp;lt; d.v;
    }
};
struct node
{
    int ch[2], sz, dup;
    unsigned k;
    data d;
    node(int z = 1) :sz(z), dup(z), k(rnd()) { ch[0] = ch[1] = 0; }
    static unsigned rnd()
    {
        static unsigned r = 0x123;
        r = r * 69069 + 1;
        return r;
    }
};
vector&amp;lt;node&amp;gt; nodes;
vector&amp;lt;int&amp;gt; recycle;
int root;
int reserve_size;
void reserve()
{
    if (size() &amp;gt;= reserve_size)
        nodes.reserve((reserve_size *= 2) + 1);
}
int new_node()
{
    int id = (int)nodes.size();
    if (!recycle.empty())
    {
        id = recycle.back();
        recycle.pop_back();
        nodes[id] = node();
    }
    else nodes.push_back(node());
    return id;
}
void update(int tp)
{
    node&amp;amp; n = nodes[tp];
    n.sz = n.dup + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
}
int insert(int&amp;amp; tp, const data&amp;amp; d)
{
    if (tp == 0)
    {
        tp = new_node();
        nodes[tp].d = d;
        return tp;
    }
    node&amp;amp; n = nodes[tp];
    ++n.sz;
    if (d == n.d)
    {
        ++n.dup;
        return tp;
    }
    int r = d &amp;lt; n.d;
    int&amp;amp; s = n.ch[r ^ 1];
    int ret = insert(s, d);
    if (nodes[s].k &amp;lt; n.k) rotate(tp, r ^ 1), update(tp);
    return ret;
}
void rotate(int&amp;amp; tp, int r)
{
    node&amp;amp; n = nodes[tp];
    int s = n.ch[r];
    n.ch[r] = nodes[s].ch[r ^ 1];
    nodes[s].ch[r ^ 1] = tp;
    update(tp);
    tp = s;
}
int find(int tp, const data&amp;amp; d) // return id
{
    if (tp == 0) return 0;
    if (d == nodes[tp].d) return tp;
    return find(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d);
}
int erasefind(int&amp;amp; tp, const data&amp;amp; d) // return deleted
{
    if (tp == 0) return 0;
    if (d == nodes[tp].d)
    {
        --nodes[tp].sz;
        if (--nodes[tp].dup &amp;lt;= 0) remove(tp);
        return 1;
    }
    if (erasefind(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d))
    {
        --nodes[tp].sz;
        return 1;
    }
    return 0;
}
void remove(int&amp;amp; tp)
{
    if (tp == 0) return;
    if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
    {
        recycle.push_back(tp);
        tp = nodes[tp].ch[!nodes[tp].ch[0]];
    }
    else
    {
        int r = nodes[nodes[tp].ch[0]].k &amp;lt; nodes[nodes[tp].ch[1]].k;
        rotate(tp, r ^ 1);
        remove(nodes[tp].ch[r]);
        update(tp);
    }
}
int kth(int tp, int k) // return id
{
    node&amp;amp; n = nodes[tp];
    int sz = nodes[n.ch[0]].sz;
    if (sz &amp;gt;= k) return kth(n.ch[0], k);
    if (sz + n.dup &amp;gt;= k) return tp;
    return kth(n.ch[1], k - sz - n.dup);
}
int rank(int tp, const data&amp;amp; d, int dup)
{
    if (tp == 0) return 1;
    node&amp;amp; n = nodes[tp];
    if (d == n.d) return nodes[n.ch[0]].sz + 1 + dup * n.dup;
    else if (d &amp;lt; n.d) return rank(n.ch[0], d, dup);
    return rank(n.ch[1], d, dup) + nodes[n.ch[0]].sz + n.dup;
}
// interface
void init(int size)
{
    nodes.clear();
    recycle.clear();
    nodes.reserve(size + 1);
    nodes.push_back(node(0));
    root = 0; reserve_size = size;
}
int get(int id) { return nodes[id].d.v; }
int size() { return nodes[root].sz; }
int insert(data v) { reserve(); return insert(root, v); }
int erase(data v) { return erasefind(root, v); }
int find(data v) { return find(root, v); } // return id
int kth(int k) { return kth(root, k); } // return id
// upperbound when upper = 1
int rank(data v, int upper = 0) { return rank(root, v, upper); }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sbt&#34;&gt;SBT&lt;/h2&gt;

&lt;p&gt;这个名字和BST特别像，但它全名是&lt;code&gt;Size Balanced Tree&lt;/code&gt;，作者是&lt;a href=&#34;https://www.zhihu.com/question/30541674&#34; target=&#34;_blank&#34;&gt;CQF&lt;/a&gt;，它通过size字段来进行树平衡。它的关键操作叫做&lt;code&gt;maintain&lt;/code&gt;，这个操作的平摊复杂度是 $O(1)$ ，这货具体解释可以看CQF的论文，SBT的时间常数比Treap更小一些，内存也更小，不过代码也稍长一些（就是因为&lt;code&gt;maintain&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct sbt
{
    struct data
    {
        int v;
        data(int _v = 0) :v(_v) {}
        bool operator==(const data&amp;amp; d) const
        {
            return v == d.v;
        }
        bool operator&amp;lt;(const data&amp;amp; d) const
        {
            return v &amp;lt; d.v;
        }
    };
    struct node
    {
        int ch[2], sz, dup;
        data d;
        node(int z = 1) :sz(z), dup(z) { ch[0] = ch[1] = 0; }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = n.dup + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
    }
    int insert(int&amp;amp; tp, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        ++n.sz;
        if (d == n.d)
        {
            ++n.dup;
            return tp;
        }
        int r = d &amp;lt; n.d;
        int&amp;amp; s = n.ch[r ^ 1];
        int ret = insert(s, d);
        maintain(tp, r ^ 1);
        return ret;
    }
    void rotate(int&amp;amp; tp, int r)
    {
        node&amp;amp; n = nodes[tp];
        int s = n.ch[r];
        n.ch[r] = nodes[s].ch[r ^ 1];
        nodes[s].ch[r ^ 1] = tp;
        update(tp); update(s);
        tp = s;
    }
    void maintain(int&amp;amp; tp, int s)
    {
        if (tp == 0) return;
        if (nodes[nodes[nodes[tp].ch[s]].ch[s]].sz &amp;gt; nodes[nodes[tp].ch[s ^ 1]].sz)
            rotate(tp, s);
        else if (nodes[nodes[nodes[tp].ch[s]].ch[s ^ 1]].sz &amp;gt; nodes[nodes[tp].ch[s ^ 1]].sz)
        {
            rotate(nodes[tp].ch[s], s ^ 1);
            rotate(tp, s);
        }
        else return;

        maintain(nodes[tp].ch[s], s);
        maintain(nodes[tp].ch[s ^ 1], s ^ 1);
        maintain(tp, s);
        maintain(tp, s ^ 1);
    }

    int find(int tp, const data&amp;amp; d) // return id
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d) return tp;
        return find(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d);
    }
    int erasefind(int&amp;amp; tp, const data&amp;amp; d) // return deleted
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d)
        {
            --nodes[tp].sz;
            if (--nodes[tp].dup &amp;lt;= 0) remove(tp);
            return 1;
        }
        if (erasefind(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d))
        {
            --nodes[tp].sz;
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int r = nodes[nodes[tp].ch[0]].sz &amp;gt;= nodes[nodes[tp].ch[1]].sz;
            rotate(tp, r ^ 1);
            remove(nodes[tp].ch[r]);
            update(tp);
        }
    }
    int kth(int tp, int k) // return id
    {
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + n.dup &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - n.dup);
    }
    int rank(int tp, const data&amp;amp; d, int dup)
    {
        if (tp == 0) return 1;
        node&amp;amp; n = nodes[tp];
        if (d == n.d) return nodes[n.ch[0]].sz + 1 + dup * n.dup;
        else if (d &amp;lt; n.d) return rank(n.ch[0], d, dup);
        return rank(n.ch[1], d, dup) + nodes[n.ch[0]].sz + n.dup;
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    int get(int id) { return nodes[id].d.v; }
    int size() { return nodes[root].sz; }
    int insert(data v) { reserve(); return insert(root, v); }
    int erase(data v) { return erasefind(root, v); }
    int find(data v) { return find(root, v); } // return id
    int kth(int k) { return kth(root, k); } // return id
    // upperbound when upper = 1
    int rank(data v, int upper = 0) { return rank(root, v, upper); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;温馨提示&#34;&gt;温馨提示&lt;/h2&gt;

&lt;p&gt;别看代码长，如果你还没自己实现过，硬着头皮写一次，你就懂了，核心其实只有那么点。以上没有实现插入相等元素后用链表串起来，实在有需要时自己加一下就好了。又或者，如果你不需要处理相同元素，那么代码也有不少的简化，特别是删除元素的地方。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线段树</title>
      <link>/post/20191208-segtree/</link>
      <pubDate>Sun, 08 Dec 2019 18:26:00 +0800</pubDate>
      <guid>/post/20191208-segtree/</guid>
      <description>&lt;p&gt;很多人在初始接触线段树的时候，一看到别人写一大堆代码就直接弃坑了，其实不要被它的外表所欺骗，线段树其实是相当好写的树结构了，而且理解起来其实很简单。要学会这个，你不能光会抄模板就会区间修改和求个区间和，因为实际应用经常会使用它的变形，还是在于理解&lt;del&gt;（理解后背板）&lt;/del&gt;。&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;p&gt;首先，回想一下heap的结构，它使用一个数组，同时使用下标本身来表达父子关系，这样的方式能节省大量指针所需要的内存空间，以下也使用这种表示方法来表示一棵线段树，也就是说，这里介绍的，属于&lt;strong&gt;狭义线段树&lt;/strong&gt;。假设我们的数据是以下这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;构建线段树后结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16--&amp;gt;1,4:8
1,8:16--&amp;gt;5,8:8
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
5,8:8--&amp;gt;5,6:7
5,8:8--&amp;gt;7,8:1
5,6:7--&amp;gt;5,5:3
5,6:7--&amp;gt;6,6:4
7,8:1--&amp;gt;7,7:0
7,8:1--&amp;gt;8,8:1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冒号前面的两个数表示一条线段，冒号后表示的是数据，这个数据表示的是这个区间的和。如此一来，我们查询一个区间的和，可以很快地计算出来，例如求&lt;code&gt;[1,6]&lt;/code&gt;的和，那么需要拆分为&lt;code&gt;[1,4]&lt;/code&gt;与&lt;code&gt;[5,6]&lt;/code&gt;的和，分别是8和7，所以结果是&lt;code&gt;8+7=15&lt;/code&gt;，原理就是这样而已。&lt;/p&gt;

&lt;h2 id=&#34;单点数据更新&#34;&gt;单点数据更新&lt;/h2&gt;

&lt;p&gt;单点更新时，可以参考树状数组，先更新子节点，然后向上找父节点更新即可，也可以递归实现，这不在本节讨论范围。不过如果你确实只需要单点修改，那么可以考虑ZKW线段树，ZKW线段树是先更新子节点，然后向上找父节点更新，由于少了很多递归，常数比递归的线段树要小。后文提供一个简易的模板作为参考。&lt;/p&gt;

&lt;h2 id=&#34;区间数据更新&#34;&gt;区间数据更新&lt;/h2&gt;

&lt;p&gt;例如，我们希望对区间&lt;code&gt;[3,5]&lt;/code&gt;上的数都加上2，这时候需要引入懒惰标记，其实就是把操作记录在父节点上，有必要时再向下传递。像刚才的例子，都加上懒惰标记后&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16,0--&amp;gt;1,4:8,0
1,8:16,0--&amp;gt;5,8:8,0
1,4:8,0--&amp;gt;1,2:1,0
1,4:8,0--&amp;gt;3,4:7,0
1,2:1,0--&amp;gt;1,1:1,0
1,2:1,0--&amp;gt;2,2:0,0
3,4:7,0--&amp;gt;3,3:5,0
3,4:7,0--&amp;gt;4,4:2,0
5,8:8,0--&amp;gt;5,6:7,0
5,8:8,0--&amp;gt;7,8:1,0
5,6:7,0--&amp;gt;5,5:3,0
5,6:7,0--&amp;gt;6,6:4,0
7,8:1,0--&amp;gt;7,7:0,0
7,8:1,0--&amp;gt;8,8:1,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后对区间&lt;code&gt;[3,5]&lt;/code&gt;上的数都加上2，那么把这个区间拆分为&lt;code&gt;[3,4]&lt;/code&gt;和&lt;code&gt;[5,5]&lt;/code&gt;，更新标记&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16,0--&amp;gt;1,4:8,0
1,8:16,0--&amp;gt;5,8:8,0
1,4:8,0--&amp;gt;1,2:1,0
1,4:8,0--&amp;gt;3,4:11,2
1,2:1,0--&amp;gt;1,1:1,0
1,2:1,0--&amp;gt;2,2:0,0
3,4:11,2--&amp;gt;3,3:5,0
3,4:11,2--&amp;gt;4,4:2,0
5,8:8,0--&amp;gt;5,6:7,0
5,8:8,0--&amp;gt;7,8:1,0
5,6:7,0--&amp;gt;5,5:5,2
5,6:7,0--&amp;gt;6,6:4,0
7,8:1,0--&amp;gt;7,7:0,0
7,8:1,0--&amp;gt;8,8:1,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，&lt;code&gt;[3,3]&lt;/code&gt;和&lt;code&gt;[4,4]&lt;/code&gt;都没有更新，更新在&lt;code&gt;[3,4]&lt;/code&gt;上了，那么接下来需要查询&lt;code&gt;[3,3]&lt;/code&gt;的话，就把标记向下传递一层，变成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16,0--&amp;gt;1,4:8,0
1,8:16,0--&amp;gt;5,8:8,0
1,4:8,0--&amp;gt;1,2:1,0
1,4:8,0--&amp;gt;3,4:11,0
1,2:1,0--&amp;gt;1,1:1,0
1,2:1,0--&amp;gt;2,2:0,0
3,4:11,0--&amp;gt;3,3:7,2
3,4:11,0--&amp;gt;4,4:4,2
5,8:8,0--&amp;gt;5,6:7,0
5,8:8,0--&amp;gt;7,8:1,0
5,6:7,0--&amp;gt;5,5:5,2
5,6:7,0--&amp;gt;6,6:4,0
7,8:1,0--&amp;gt;7,7:0,0
7,8:1,0--&amp;gt;8,8:1,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，再获取区间&lt;code&gt;[3,3]&lt;/code&gt;的结果7，就是所需要的答案&lt;/p&gt;

&lt;h2 id=&#34;基础模板&#34;&gt;基础模板&lt;/h2&gt;

&lt;p&gt;以下基础模板只支持区间求和，以及区间整体加上一个数的操作，和&lt;a href=&#34;/post/20191111-fenwicktree/&#34;&gt;树状数组&lt;/a&gt;后面提供的模板实现了相同的功能&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree_add
{
    struct node
    {
        int sum;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d; // 仿heap的形式保存线段树
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    // 当前tp节点对应的线段区间为[tl,tr]，更新区间是[l,r]
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl + 1) * v;
            d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 更新左右儿子
        if (l &amp;lt;= tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid + 1, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    int get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 统计左右儿子
        int sum = 0;
        if (l &amp;lt;= tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid + 1, tr, rson(tp));
        return sum;
    }
    void init(int size) // 可操作下标范围为0~size-1，如需要从1开始那么要+1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz; // 扩展为满二叉树
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r, v, 0, sz - 1, 0);
    }
    int get_sum(int l, int r)
    {
        return get_sum(l, r, 0, sz - 1, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法，调用init初始化范围（注意下标从0到size-1，下标要从1开始的话要size+1，否则如果size正好是2的k次方时操作下标为size时会出问题），然后通过&lt;code&gt;update_add&lt;/code&gt;和&lt;code&gt;get_sum&lt;/code&gt;更新数据即可。&lt;/p&gt;

&lt;p&gt;另外一点，这个模板实现没有使用左闭右开区间来写，如果改用左闭右开区间，并添加build实现，则得到如下实现（代码有少许简化且更对称更好读）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree_add
{
    struct node
    {
        int sum;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl) * v;
            d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 更新左右儿子
        if (l &amp;lt; tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    int get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 统计左右儿子
        int sum = 0;
        if (l &amp;lt; tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid, tr, rson(tp));
        return sum;
    }
    void build(int a[], int alen, int tl, int tr, int tp)
    {
        if (tl + 1 == tr)
        {
            if (tl &amp;lt; alen)
                d[tp].sum = a[tl];
            else
                d[tp].sum = 0;
            return;
        }
        int tmid = (tl + tr) / 2;
        build(a, alen, tl, tmid, lson(tp));
        build(a, alen, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
        d[tp].lz_add = 0;
    }
    void build(int a[], int alen)
    {
        build(a, alen, 0, sz, 0);
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r + 1, v, 0, sz, 0);
    }
    int get_sum(int l, int r)
    {
        return get_sum(l, r + 1, 0, sz, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;进阶模板&#34;&gt;进阶模板&lt;/h2&gt;

&lt;p&gt;如果你需要支持区间整体加上某个数，同时支持区间整体设置为指定数，那么就需要多重懒惰标记，模板可以改写如下（闭区间实现）&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree
{
    static const int lz_mark = 0x80000000;
    struct node
    {
        int sum;
        int lz_set;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl + 1) * v;
            if (d[tp].lz_set != lz_mark) d[tp].lz_set += v;
            else d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid + 1, tr, d[tp].lz_set, tmid + 1, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt;= tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid + 1, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    void update_set(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum = (tr - tl + 1) * v; //区间和
            d[tp].lz_set = v;
            d[tp].lz_add = 0;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid + 1, tr, d[tp].lz_set, tmid + 1, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt;= tmid) update_set(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_set(l, r, v, tmid + 1, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    int get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid + 1, tr, d[tp].lz_set, tmid + 1, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        int sum = 0;
        if (l &amp;lt;= tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid + 1, tr, rson(tp));
        return sum;
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r, v, 0, sz - 1, 0);
    }
    void update_set(int l, int r, int v)
    {
        update_set(l, r, v, 0, sz - 1, 0);
    }
    int get_sum(int l, int r)
    {
        return get_sum(l, r, 0, sz - 1, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;左闭右开区间实现（接口为闭区间）&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree
{
    static const int lz_mark = 0x80000000;
    struct node
    {
        int sum;
        int lz_set;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl) * v;
            if (d[tp].lz_set != lz_mark) d[tp].lz_set += v;
            else d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid, tr, d[tp].lz_set, tmid, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt; tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    void update_set(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum = (tr - tl) * v; //区间和
            d[tp].lz_set = v;
            d[tp].lz_add = 0;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid, tr, d[tp].lz_set, tmid, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt; tmid) update_set(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_set(l, r, v, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    ll get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid, tr, d[tp].lz_set, tmid, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        int sum = 0;
        if (l &amp;lt; tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid, tr, rson(tp));
        return sum;
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r + 1, v, 0, sz, 0);
    }
    void update_set(int l, int r, int v)
    {
        update_set(l, r + 1, v, 0, sz, 0);
    }
    ll get_sum(int l, int r)
    {
        return get_sum(l, r + 1, 0, sz, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;简易区间最值模板（就是简易得只有查询，如果要支持更新就自己加上）&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree
{
    struct node
    {
        int max;
        int min;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    int get_max(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].max;
        }
        int tmid = (tl + tr) / 2;
        int ret = INT_MIN;
        if (l &amp;lt; tmid) ret = max(ret, get_max(l, r, tl, tmid, lson(tp)));
        if (r &amp;gt; tmid) ret = max(ret, get_max(l, r, tmid, tr, rson(tp)));
        return ret;
    }
    int get_min(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].min;
        }
        int tmid = (tl + tr) / 2;
        int ret = INT_MAX;
        if (l &amp;lt; tmid) ret = min(ret, get_min(l, r, tl, tmid, lson(tp)));
        if (r &amp;gt; tmid) ret = min(ret, get_min(l, r, tmid, tr, rson(tp)));
        return ret;
    }
    void build(int a[], int alen, int tl, int tr, int tp)
    {
        if (tl + 1 == tr)
        {
            if (tl &amp;lt; alen)
            {
                d[tp].max = a[tl];
                d[tp].min = a[tl];
            }
            else
            {
                d[tp].max = 0;
                d[tp].min = 0;
            }
            return;
        }
        int tmid = (tl + tr) / 2;
        build(a, alen, tl, tmid, lson(tp));
        build(a, alen, tmid, tr, rson(tp));
        d[tp].max = max(d[lson(tp)].max, d[rson(tp)].max);
        d[tp].min = min(d[lson(tp)].min, d[rson(tp)].min);
    }
    void build(int a[], int alen)
    {
        build(a, alen, 0, sz, 0);
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    int get_min(int l, int r)
    {
        return get_min(l, r + 1, 0, sz, 0);
    }
    int get_max(int l, int r)
    {
        return get_max(l, r + 1, 0, sz, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h2 id=&#34;zkw线段树模板&#34;&gt;ZKW线段树模板&lt;/h2&gt;

&lt;p&gt;这是单点修改求区间和的模板，求区间最值稍微改改就好了，如果需要区间修改，那么可以模仿树状数组的办法做差分，或做永久化标记，适应性比递归实现的线段树差一些，优点是常数小，以下实现比前面的大约快30%左右，代码更简单，就不额外解释了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct zkwseg_tree
{
    struct node
    {
        int sum;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int p, int v)
    {
        int i = sz + p;
        while (i)
        {
            d[i].sum += v;
            i &amp;gt;&amp;gt;= 1;
        }
    }
    int get_sum(int l, int r)
    {
        int sum = 0;
        l += sz;
        r += sz + 1;
        for (; l &amp;lt; r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1)
        {
            if (l &amp;amp; 1)
            {
                sum += d[l++].sum;
            }
            if (r &amp;amp; 1)
            {
                sum += d[--r].sum;
            }
        }
        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它说明&#34;&gt;其它说明&lt;/h2&gt;

&lt;p&gt;以上模板为了解释简单，有的实现只有&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;get_sum&lt;/code&gt;操作，并没有&lt;code&gt;build&lt;/code&gt;的部分，只使用&lt;code&gt;update&lt;/code&gt;即可完成build的操作，时间复杂度也是一样的。除了维护区间和，也可以维护区间最大最小值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>后缀数组</title>
      <link>/post/20191113-suffixarray/</link>
      <pubDate>Wed, 13 Nov 2019 18:26:00 +0800</pubDate>
      <guid>/post/20191113-suffixarray/</guid>
      <description>&lt;p&gt;后缀数组其实概念很好理解，就是给出一个字符串，长度是n，对它所有的n个后缀编号从1到n进行排序，排序后，最小的那个后缀的编号假设是m1，那么&lt;code&gt;sa[1] = m1&lt;/code&gt;，类似地，第二小的是m2的话，&lt;code&gt;sa[2] = m2&lt;/code&gt;，sa这个数组就是我们所需要的后缀数组。根据这个，我们可以直接用sort算出sa，以下为最简单的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_simple
{
    vector&amp;lt;int&amp;gt; sa;
    int s_size;
    const char* p_s;
    int size() const
    {
        return s_size;
    }
    static bool cmp(const char* x, const char* y)
    {
        return strcmp(x, y) &amp;lt; 0;
    }
    void init(char * str)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;

        sa.resize(n + 1);
        vector&amp;lt; const char* &amp;gt; rp;
        rp.resize(n + 1);

        for (int i = 1; i &amp;lt;= n; ++i)
        {
            rp[i] = p_s + i;
        }
        sort(rp.begin() + 1, rp.end(), cmp);
        for (int i = 1; i &amp;lt;= n; ++i)
        {
            sa[i] = rp[i] - p_s;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现的时间复杂度 $O(n^2logn)$&lt;/p&gt;

&lt;p&gt;要注意的一点是下标从1开始。有了这个，可以做点什么呢？例如给你一个串p，求出p在主串s中出现了多少次。那么在有了sa的情况下，因为sa是有序的，问题就变成了二分搜索，分别用&lt;code&gt;lower_bound&lt;/code&gt;和&lt;code&gt;upper_bound&lt;/code&gt;通过sa搜索p，两个相减便得出现次数。&lt;/p&gt;

&lt;h2 id=&#34;rank-数组&#34;&gt;rank 数组&lt;/h2&gt;

&lt;p&gt;光有sa其实还不够用，我们还需要rank数组，&lt;code&gt;rank[m]&lt;/code&gt;的值是p的话，那么表示字符串中编号m的后缀，它的排名是p，即与sa数组是互逆，所以我们可以得到 &lt;code&gt;sa[rank[i]] == rank[sa[i]] == i&lt;/code&gt; ，也就是说通过rank，可以快速判断某两个后缀的大小关系。&lt;/p&gt;

&lt;h2 id=&#34;height-数组&#34;&gt;height 数组&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;height[i]&lt;/code&gt;的值表示的是，&lt;code&gt;sa[i-1]&lt;/code&gt;与&lt;code&gt;sa[i]&lt;/code&gt;这两个后缀的相同前缀长度，特别地，&lt;code&gt;height[1] == 0&lt;/code&gt;，求解height需要用到rank数组和sa数组，以及如下引理&lt;/p&gt;

&lt;p&gt;$$height[rank[i]]\ge height[rank[i-1]]-1$$&lt;/p&gt;

&lt;p&gt;通过以上引理直接暴力实现即可，复杂度 $O(n)$ ，这里不做证明。&lt;/p&gt;

&lt;p&gt;三个数组的完整实现如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_simple
{
    vector&amp;lt;int&amp;gt; sa, rk, ht;
protected:
    int s_size;
    const char* p_s;
public:
    int size() const
    {
        return s_size;
    }

    static bool cmp(const char* x, const char* y)
    {
        return strcmp(x, y) &amp;lt; 0;
    }

    void init(char * str, bool h = true)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;

        sa.resize(n + 1);
        rk.resize(n + 1);
        vector&amp;lt;const char*&amp;gt; rp;
        rp.resize(n + 1);

        for (int i = 1; i &amp;lt;= n; ++i)
        {
            rp[i] = p_s + i;
        }
        sort(rp.begin() + 1, rp.end(), cmp);
        for (int i = 1; i &amp;lt;= n; ++i)
        {
            sa[i] = rp[i] - p_s;
            rk[sa[i]] = i;
        }
        if (h) create_height();
    }
    void create_height()
    {
        ht.resize(s_size + 1);
        for (int i = 1, k = 0; i &amp;lt;= s_size; ++i)
        {
            if (k) --k;
            while (p_s[i + k] == p_s[sa[rk[i] - 1] + k])
                ++k;
            ht[rk[i]] = k;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;应用1-可重叠最长重复子串&#34;&gt;应用1 可重叠最长重复子串&lt;/h2&gt;

&lt;p&gt;这个题目在本博客讲&lt;a href=&#34;/post/20191028-kmp/&#34;&gt;kmp&lt;/a&gt;部分已经有介绍，例如&lt;code&gt;eabcaefabcabc&lt;/code&gt;，最长重复子串是&lt;code&gt;abca&lt;/code&gt;，长度是4，这里介绍用后缀数组的解法。其实所谓的最长重复子串，就是找到两个后缀，让它们的公共前缀最长，那这就简单了，我们只要在height数组里找最大值就可以了，查找时间 $O(n)$ 。&lt;/p&gt;

&lt;h2 id=&#34;应用2-不同子串的个数&#34;&gt;应用2 不同子串的个数&lt;/h2&gt;

&lt;p&gt;来看这道题 &lt;a href=&#34;https://vjudge.net/problem/SPOJ-DISUBSTR&#34; target=&#34;_blank&#34;&gt;SPOJ-DISUBSTR&lt;/a&gt; ，说的是统计一个字符串里有多少不同的子串。&lt;/p&gt;

&lt;p&gt;这里我们就需要用到height数组，由于它表示的正是和前一个后缀的相同前缀长度，那么我们对任意的后缀&lt;code&gt;sa[i]&lt;/code&gt;，取这个后缀的长度，即&lt;code&gt;len(s)-sa[i]&lt;/code&gt;，减去&lt;code&gt;height[i]&lt;/code&gt;再加上1，即表示&lt;code&gt;sa[i]&lt;/code&gt;这个后缀有多少个前缀与&lt;code&gt;sa[i-1]&lt;/code&gt;不相同，所以我们累加即可。核心代码也就这么几行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sum_h = 0;
for (int i = 1; i &amp;lt;= sa.size(); ++i)
{
    sum_h += sa.size() - sa.sa[i] - sa.ht[i] + 1;
}
printf(&amp;quot;%d\n&amp;quot;, sum_h);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许有人会发现问题了，这个题直接用hash实现，才 $O(n^2)$ 的复杂度，这个后缀数组的实现，光是生成就 $O(n^2logn)$ ，不是还更慢吗？单看时间复杂度的确是这样，但事实上后缀数组可以0ms通过，hash实现约400ms左右。&lt;/p&gt;

&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;

&lt;p&gt;直接排序的后缀数组确实过于暴力了，虽然不少题目已经足够AC，但我们还有更好的，这里简要介绍倍增法。假设对字符串&amp;rdquo;ababaabb&amp;rdquo;求后缀数组，那么先对每一个字符做排序，计算出它们的rank，注意相同串的rank结果要相同，结果在下表的&amp;rdquo;排序1&amp;rdquo;，然后我们对每个&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;i+1&lt;/code&gt;在&amp;rdquo;排序1&amp;rdquo;上的rank组合起来，这个组合的key再做排序，如下表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;组合1&lt;/td&gt;
&lt;td&gt;1 2&lt;/td&gt;
&lt;td&gt;2 1&lt;/td&gt;
&lt;td&gt;1 2&lt;/td&gt;
&lt;td&gt;2 1&lt;/td&gt;
&lt;td&gt;1 1&lt;/td&gt;
&lt;td&gt;1 2&lt;/td&gt;
&lt;td&gt;2 2&lt;/td&gt;
&lt;td&gt;2 0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事实上这样得到了所有后缀中，前缀长度为2的排名，接下来，我们步长翻倍，对每个&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;i+2&lt;/code&gt;在&amp;rdquo;排序2&amp;rdquo;上的rank组合起来再排序&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;排序2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;组合2&lt;/td&gt;
&lt;td&gt;2 2&lt;/td&gt;
&lt;td&gt;4 4&lt;/td&gt;
&lt;td&gt;2 1&lt;/td&gt;
&lt;td&gt;4 2&lt;/td&gt;
&lt;td&gt;1 5&lt;/td&gt;
&lt;td&gt;2 3&lt;/td&gt;
&lt;td&gt;5 0&lt;/td&gt;
&lt;td&gt;3 0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事实上这样得到了所有后缀中，前缀长度为4的排名，接下来，我们步长翻倍，对每个&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;i+4&lt;/code&gt;在&amp;rdquo;排序3&amp;rdquo;上的rank组合起来再排序&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;排序3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;组合3&lt;/td&gt;
&lt;td&gt;3 1&lt;/td&gt;
&lt;td&gt;7 4&lt;/td&gt;
&lt;td&gt;2 8&lt;/td&gt;
&lt;td&gt;6 5&lt;/td&gt;
&lt;td&gt;1 0&lt;/td&gt;
&lt;td&gt;4 0&lt;/td&gt;
&lt;td&gt;8 0&lt;/td&gt;
&lt;td&gt;5 0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;至此，再下一轮的步长是8，已经大于等于字符串长度的时候，rank数组便计算完成了。以下是使用此思路的实现代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_2_sort
{
    vector&amp;lt;int&amp;gt; sa, ht;
    int *rk;
protected:
    vector&amp;lt;int&amp;gt; rk1, rk2;
    int s_size;
    int *p_rk, *o_rk;
    const char* p_s;

    struct SA_2_sort_cmp
    {
        int *rk, w;
        SA_2_sort_cmp(int *_rk, int _w) :rk(_rk), w(_w) {}
        bool operator()(int x, int y) const
        {
            return rk[x] == rk[y] ? rk[x + w] &amp;lt; rk[y + w] : rk[x] &amp;lt; rk[y];
        }
    };
public:
    bool cmp(int x, int y, int w)
    {
        return o_rk[x] == o_rk[y] &amp;amp;&amp;amp; o_rk[x + w] == o_rk[y + w];
    }
    int size() const
    {
        return s_size;
    }
    void init(char * str, bool h = true)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;
        sa.resize(n + 1);
        rk1.clear(); rk1.resize(n * 2 + 2);
        rk2.clear(); rk2.resize(n * 2 + 2);
        p_rk = &amp;amp;*rk1.begin();
        o_rk = &amp;amp;*rk2.begin();

        for (int i = 1; i &amp;lt;= n; ++i) p_rk[i] = p_s[i];

        for (int w = 1, i, p; w &amp;lt; n; w &amp;lt;&amp;lt;= 1)
        {
            // init sa
            for (int i = 1; i &amp;lt;= n; ++i) sa[i] = i;

            sort(sa.begin() + 1, sa.end(), SA_2_sort_cmp(p_rk, w));

            // write new rank
            for (std::swap(p_rk, o_rk), p = 0, i = 1; i &amp;lt;= n; ++i)
                p_rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        }
        rk = p_rk;
        if (n == 1) sa[1] = rk[1] = 1;
        if (h) create_height();
    }
    void create_height()
    {
        int n = s_size;
        ht.resize(n + 1);
        for (int i = 1, k = 0; i &amp;lt;= n; ++i)
        {
            if (k) --k;
            while (p_s[i + k] == p_s[sa[p_rk[i] - 1] + k])
                ++k;
            ht[p_rk[i]] = k;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上实现的时间复杂度是 $O(nlog^2n)$ ，如果你想要更快，那就用 $O(n)$ 的计数排序吧，便可把整体时间复杂度下降到 $O(nlogn)$&lt;/p&gt;

&lt;h2 id=&#34;再优化&#34;&gt;再优化&lt;/h2&gt;

&lt;p&gt;绝大多数情况下，使用以上方法 $O(nlogn)$ 复杂度已经够用了，但如果你是一个更有追求的人，可以继续学习 $O(n)$ 复杂度建立后缀数组的办法，名字叫做&lt;code&gt;SA-IS&lt;/code&gt;和&lt;code&gt;DC3&lt;/code&gt;，你可以通过搜索以上两个名字得到更具体的介绍，本文就只介绍到这里。&lt;/p&gt;

&lt;h2 id=&#34;o-nlogn-模板&#34;&gt;$O(nlogn)$ 模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_2
{
    vector&amp;lt;int&amp;gt; sa, ht;
    int *rk;
protected:
    vector&amp;lt;int&amp;gt; rk1, rk2;
    int s_size;
    int *p_rk, *o_rk;
    const char* p_s;
public:
    bool cmp(int x, int y, int w)
    {
        return o_rk[x] == o_rk[y] &amp;amp;&amp;amp; o_rk[x + w] == o_rk[y + w];
    }
    int size() const
    {
        return s_size;
    }
    void init(char * str, bool h = true)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;
        int cnt_size = max(256, n) + 1;
        vector&amp;lt;int&amp;gt; vid, vpx, vcnt;
        sa.resize(n + 1);
        rk1.clear(); rk1.resize(n * 2 + 2);
        rk2.clear(); rk2.resize(n * 2 + 2);
        vid.resize(n + 1); vpx.resize(n + 1);
        vcnt.resize(cnt_size);
        int* id = &amp;amp;*vid.begin();
        int* px = &amp;amp;*vpx.begin();
        int* cnt = &amp;amp;*vcnt.begin();
        p_rk = &amp;amp;*rk1.begin();
        o_rk = &amp;amp;*rk2.begin();

        int m = 128, p = 0;
        for (int i = 1; i &amp;lt;= n; ++i) ++cnt[p_rk[i] = p_s[i]];
        for (int i = 1; i &amp;lt;= m; ++i) cnt[i] += cnt[i - 1];
        for (int i = n; i &amp;gt;= 1; --i) sa[cnt[p_rk[i]]--] = i;

        for (int w = 1, i; w &amp;lt; n; w &amp;lt;&amp;lt;= 1, m = p)
        {
            // init id
            for (p = 0, i = n; i &amp;gt; n - w; --i)
                id[++p] = i;
            for (int i = 1; i &amp;lt;= n; ++i)
                if (sa[i] &amp;gt; w) id[++p] = sa[i] - w;

            sort(cnt, id, px, n, m);

            // write new rank
            for (std::swap(p_rk, o_rk), p = 0, i = 1; i &amp;lt;= n; ++i)
                p_rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        }
        rk = p_rk;
        if (n == 1) sa[1] = rk[1] = 1;
        if (h) create_height();
    }
    void sort(int* cnt, int* id, int* px, int n, int m)
    {
        memset(cnt, 0, sizeof(int) * (m + 1));
        for (int i = 1; i &amp;lt;= n; ++i)
            ++cnt[px[i] = p_rk[id[i]]];
        for (int i = 1; i &amp;lt;= m; ++i)
            cnt[i] += cnt[i - 1];
        for (int i = n; i &amp;gt;= 1; --i)
            sa[cnt[px[i]]--] = id[i];
    }
    void create_height()
    {
        int n = s_size;
        ht.resize(n + 1);
        for (int i = 1, k = 0; i &amp;lt;= n; ++i)
        {
            if (k) --k;
            while (p_s[i + k] == p_s[sa[p_rk[i] - 1] + k])
                ++k;
            ht[p_rk[i]] = k;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>树状数组</title>
      <link>/post/20191111-fenwicktree/</link>
      <pubDate>Mon, 11 Nov 2019 13:32:00 +0800</pubDate>
      <guid>/post/20191111-fenwicktree/</guid>
      <description>&lt;p&gt;树状数组，是一个用于在近似 $O(logn)$ 时间内动态修改以及查询前缀和的数据结构，以下我们先来看以下树关系表格&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里表达的是，16的子节点有8, 12, 14, 15&lt;/p&gt;

&lt;p&gt;8的子节点有4, 6, 7&lt;/p&gt;

&lt;p&gt;12的子节点有10, 11，即夹在12与它的同级节点8之间&lt;/p&gt;

&lt;p&gt;我们把数值与它的二进制一起形象化画出下图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
2,0010--&amp;gt;1,0001
4,0100--&amp;gt;3,0011
4,0100--&amp;gt;2,0010
6,0110--&amp;gt;5,0101
8,1000--&amp;gt;7,0111
8,1000--&amp;gt;6,0110
8,1000--&amp;gt;4,0100
10,1010--&amp;gt;9,1001
12,1100--&amp;gt;11,1011
12,1100--&amp;gt;10,1010
14,1110--&amp;gt;13,1101
16,10000--&amp;gt;8,1000
16,10000--&amp;gt;12,1100
16,10000--&amp;gt;14,1110
16,10000--&amp;gt;15,1111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样构造的原理是运用到一个二进制运算技巧，假设一个节点x，那么它的父节点就是&lt;code&gt;x + (x &amp;amp; -x)&lt;/code&gt;，其中，&lt;code&gt;x &amp;amp; -x&lt;/code&gt;是去掉右起第一个1的左边的1，例如x如果是6，二进制是110，只保留最右边的1结果就是10了，所以6的父节点就是&lt;code&gt;6+2=8&lt;/code&gt;，更多的可以参考这篇&lt;a href=&#34;/post/20191012-binary-skill/&#34;&gt;二进制技巧&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;前缀和&#34;&gt;前缀和&lt;/h2&gt;

&lt;p&gt;给一个数组a，如果我们需要计算前n个元素的和 $\sum_{i=1}^n{a[i]}$ ，直接累加是很慢的，这里我们用树状数组，我们规定，每个节点保存的值，是它和它的子节点的和，我们用数组 &lt;code&gt;9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1&lt;/code&gt; 画个表格，注意数组下标从1开始。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;66&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那有了这个表，我们要是求出前4个数的和，直接看第4列是30，答案就出来了，因为它上面的数就是它和它所有子结点的和。但如果是别的数呢，例如要求前7个数的和，就不能光看第7列了，需要把第4列、第6列和第7列的3个数相加，即&lt;code&gt;30+9+3=42&lt;/code&gt;就是前7个数的和。注意到这三列其实就是三个同级节点，而且我们通过7这个数本身可以轻松计算前两列的数，计算的方法是&lt;code&gt;x - (x &amp;amp; -x)&lt;/code&gt;，把&lt;code&gt;x=7&lt;/code&gt;代入，得到6，再把6代入，得到4，再把4代入，得到0，0就结束了，而在这个迭代的过程里，就知道我们应该把4,6,7三列的数相加。&lt;/p&gt;

&lt;p&gt;再换一个数，例如11呢，把&lt;code&gt;x=11&lt;/code&gt;代入，得到10，再把10代入，得到8，再把8代入，得到0，所以我们应该把8,10,11三列的数加起来，即&lt;code&gt;44+1+6=51&lt;/code&gt;就是前11个数的和。&lt;/p&gt;

&lt;p&gt;把以上过程写成函数，就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sum(int fwtree[], int x)
{
    int r = 0;
    while (x &amp;gt; 0)
    {
        r += fwtree[x];
        x -= x&amp;amp;-x;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，这段代码的时间复杂度近似是 $O(logx)$&lt;/p&gt;

&lt;h2 id=&#34;动态维护&#34;&gt;动态维护&lt;/h2&gt;

&lt;p&gt;还是前面的数组 &lt;code&gt;9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1&lt;/code&gt; ，现在假如已经计算好了树状数组，但我们需要对第6个元素，让它减少6，怎么操作呢，其实很简单，根据定义，在子节点修改的时候，让它的所有父节点都做相同的修改，那么6的父节点分别有8,16，所以我们对第6,8,16列都一起减少6，得到以下新表格&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;-2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这样就维护完成了，所以咱们的实现代码也非常的简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void add(int fwtree[], int treesize, int x, int add)
{
    while (x &amp;lt;= treesize)
    {
        fwtree[x] += add;
        x += x&amp;amp;-x;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;区间和&#34;&gt;区间和&lt;/h2&gt;

&lt;p&gt;我们之所以需要前缀和，就是为了能快速求区间和。例如我们需要求出数组第i个到第j个元素的和，那么我们用&lt;code&gt;sum(x)&lt;/code&gt;表示前x个元素的和，那么可以转化为求&lt;code&gt;sum(j) - sum(i-1)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;区间操作-单点查询&#34;&gt;区间操作+单点查询&lt;/h2&gt;

&lt;p&gt;因为树状数组的修改是单点修改，即每次只能修改一个数，那么现在我们提出一个新问题，如果我们需要多次做区间操作（整个区间的数同时加上y），然后查询数组里面指定第k个元素是什么，例如这个题&lt;a href=&#34;https://loj.ac/problem/131&#34; target=&#34;_blank&#34;&gt;loj131&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于树状数组不能快速做区间操作，我们用到另一个技巧叫做差分法，我们对数组 &lt;code&gt;9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1&lt;/code&gt;求相邻元素的差，得到新的数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样做了后，如果我们要求出原来第k个元素，那么就是求前k个元素之和，所以如果第i个元素加上a，那么相当于i后面所有元素都加上a。&lt;/p&gt;

&lt;p&gt;所以，这时候的区间操作，就会变成单点操作，例如我们要对区间&lt;code&gt;[i,j]&lt;/code&gt;所有的元素加上a，那么在差分了以后，其实就是对第i个元素加上a，再对第j+1个元素减去a。&lt;/p&gt;

&lt;h2 id=&#34;区间操作-区间和&#34;&gt;区间操作+区间和&lt;/h2&gt;

&lt;p&gt;如果我们既要做区间操作，同时还要求区间和怎么办，为了支持区间操作，我们仍然先做差分，然后接下来就是让人头痛的数学推导，假设数组a是原数组，b是a的差分数组，由前缀和的定义，我们求前n个元素的和，即&lt;/p&gt;

&lt;p&gt;$$ \sum_{i=1}^{n} a_i $$&lt;/p&gt;

&lt;p&gt;展开为b数组表达&lt;/p&gt;

&lt;p&gt;$$ = \sum_{i=1}^n{} \sum_{j=1}^i b_j $$&lt;/p&gt;

&lt;p&gt;展开，合并同类项&lt;/p&gt;

&lt;p&gt;$$ = \sum_{i=1}^n b_i\times(n-i+1) $$&lt;/p&gt;

&lt;p&gt;$$ = (n+1)\times\sum_{i=1}^n b_i - \sum_{i=1}^n b_i\times i $$&lt;/p&gt;

&lt;p&gt;那么，我们再定义一个c数组，满足&lt;code&gt;c[i] == b[i] * i&lt;/code&gt;，然后我们再分别对b和c维护一个树状数组，定义&lt;code&gt;sum(b,x)&lt;/code&gt;表示数组b前x个元素的和，&lt;code&gt;sum(c,x)&lt;/code&gt;表示数组c前x个元素的和，那么我们便可以通过计算&lt;code&gt;(x + 1) * sum(b, x) - sum(c, x)&lt;/code&gt;求出数组a的前缀和。&lt;/p&gt;

&lt;p&gt;习题：&lt;a href=&#34;https://loj.ac/problem/132&#34; target=&#34;_blank&#34;&gt;loj132&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;拓展&#34;&gt;拓展&lt;/h2&gt;

&lt;p&gt;树状数组还有一些别的技巧，一是 $O(n)$ 建立，通过已知数组a在 $O(n)$ 时间生成对应的树状数组（直接add来操作是nlogn），这个在这里不做介绍。&lt;/p&gt;

&lt;p&gt;还有权值树状数组求第k小元素。所谓权值树状数组，就是用&lt;code&gt;a[i] = v&lt;/code&gt;来表示数值i重复出现了v次，所以v是非负数，那么这个数组的前缀和就是递增的，即存在二分。然后对数组a维护的树状数组直接二分的话是 $O(lognlogn)$ ，但我们可以运用树状数组的特性优化到 $O(logn)$ ，以下是实现代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int kth(int fwtree[], int size, int k)
{
    int cnt = 0, ret = 0;
    for (int i = (int)(log(size + 0.1) / log(2)); ~i; --i)
    {
        ret += 1 &amp;lt;&amp;lt; i;
        if (ret &amp;gt;= size || cnt + fwtree[ret] &amp;gt;= k)
            ret -= 1 &amp;lt;&amp;lt; i;
        else
            cnt += fwtree[ret];
    }
    return ret + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;权值树状数组还有一个应用，就是用来求&lt;strong&gt;逆序数&lt;/strong&gt;，先对原数组排序求出每个元素的rank，转化为长度n，元素为1~n的一个排列，之后使用权值树状数组，就可以轻松求出在&lt;code&gt;a[1]&lt;/code&gt;到&lt;code&gt;a[i-1]&lt;/code&gt;有多少个元素比&lt;code&gt;a[i]&lt;/code&gt;要大，计算&lt;code&gt;sum(n) - sum(a[i])&lt;/code&gt;便知，把结果累加就是逆序数。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;区间修改+区间求和模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;vector&amp;gt;
typedef long long ll;


struct fwtree_range
{
    std::vector&amp;lt;int&amp;gt; ta;
    std::vector&amp;lt;ll&amp;gt; tb;
    int sz;
    void init(int size)
    {
        ta.clear(); ta.resize(size + 1);
        tb.clear(); tb.resize(size + 1);
        sz = size;
    }
    void add(int x, int a)
    {
        ll v = a * (ll)x;
        for (; x &amp;lt;= sz; x += x&amp;amp;-x)
        {
            ta[x] += a;
            tb[x] += v;
        }
    }
    template &amp;lt;class T&amp;gt;
    ll sum_t(T&amp;amp; t, int x)
    {
        ll r = 0;
        for (; x &amp;gt; 0; x -= x&amp;amp;-x)
            r += t[x];
        return r;
    }
    ll sum(int x)
    {
        return (x + 1) * sum_t(ta, x) - sum_t(tb, x);
    }
    void range_add(int l, int r, int a)
    {
        add(l, a);
        add(r + 1, -a);
    }
    ll range_sum(int l, int r)
    {
        return sum(r) - sum(l - 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法，调用&lt;code&gt;init&lt;/code&gt;初始化大小后，使用&lt;code&gt;range_add&lt;/code&gt;及&lt;code&gt;range_sum&lt;/code&gt;做区间修改及区间和查询就行了，当然它也支持单点修改和单点查询，你令区间&lt;code&gt;l == r&lt;/code&gt;就行了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>KMP及扩展KMP</title>
      <link>/post/20191028-kmp/</link>
      <pubDate>Mon, 28 Oct 2019 13:32:00 +0800</pubDate>
      <guid>/post/20191028-kmp/</guid>
      <description>&lt;p&gt;KMP之所以在竞赛中常见，并不是因为它用来匹配字符串，而是用它的next数组，为了介绍它，我们先讲讲最长公共前缀&lt;/p&gt;

&lt;h2 id=&#34;最长公共前缀&#34;&gt;最长公共前缀&lt;/h2&gt;

&lt;p&gt;我们拿字符串&lt;code&gt;ababcab&lt;/code&gt;作为例子&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里所表达的是，例如取第3、4个字符&amp;rdquo;ab&amp;rdquo;，这个子串与前缀完全匹配，且它的长度是2，所以就记录2，而第3、4、5个字符&amp;rdquo;abc&amp;rdquo;与前缀不能完全匹配，就记作0，含义就这么简单，而且你会发现，计算b的时候，可以根据它所匹配的字符的偏移来，b如果是匹配的，就找到匹配的那个字符是数组中的第几个，它是第二个，所以填2进去。我们再来看更复杂的例子&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最后那个字符不匹配的时候，1是怎么计算出来的呢，直接重新计算当然也可以，但就出现重复计算了。我们考虑一下匹配过程，在前面的字符a的时候，前后各一个指针，像这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后两个a匹配，&lt;code&gt;arr[6] = pointer1 - arr&lt;/code&gt; 得到3，然后两指针一起移动&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这时候，不匹配，那么前一个指针上一次指向的是&lt;code&gt;arr[2]&lt;/code&gt;的位置，即图上&lt;code&gt;*&lt;/code&gt;的地方，值是1，这个值如果是p，那就移动到&lt;code&gt;arr[p]&lt;/code&gt;的地方，所以就移动到&lt;code&gt;arr[1]&lt;/code&gt;的地方，本质上就是找到前一个匹配此后缀的位置，即&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后再尝试匹配，这次匹配上了，然后前一指针指向第二个元素，所以赋值2&lt;/p&gt;

&lt;h2 id=&#34;next数组&#34;&gt;next数组&lt;/h2&gt;

&lt;p&gt;以上过程你需要细细理解，在理解以上过程后，再去理解next数组就非常简单了，next数组只是把以上数组加了一偏移，如下&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;next&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这么做是为了简化代码的书写，当然你直接用公共前缀的那个数组来做也是可以的&lt;/p&gt;

&lt;p&gt;不过本文不介绍怎么做字符串匹配，这种文章到处都是，我们要讲的是竞赛中的典型应用&lt;/p&gt;

&lt;p&gt;生成next数组的算法的时间复杂度为 $O(n)$ ，n是数组长度&lt;/p&gt;

&lt;h3 id=&#34;应用1-poj2406&#34;&gt;应用1 &lt;a href=&#34;http://poj.org/problem?id=2406&#34; target=&#34;_blank&#34;&gt;poj2406&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;题目大意是给你一个字符串s，找出一个串a，使得a自己重复n次，便得到字符串s，要找到最大的n值。例如&lt;code&gt;ababab&lt;/code&gt;，可以找到&lt;code&gt;ab&lt;/code&gt;重复3次得到，所以输出3。像这种就是next数组表演的时候，它在计算自匹配方面非常合适，我们先再来理解一下next数组，它的值表示与前缀的重复长度，那么看下表，使用长度为102的&lt;code&gt;abab....abab&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;&amp;hellip;&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;next&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;97&lt;/td&gt;
&lt;td&gt;98&lt;/td&gt;
&lt;td&gt;99&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们发现，使用串长102减去next数组最后一个值，自然就得到了重复前缀的最短长度，既然它是最短的，那么我们用总长102除以2，就得到了重复的次数，就是我们想要的答案。当然前提是能整除，如果不能整除那么这样的前缀便不存在，输出1就行了。&lt;/p&gt;

&lt;h3 id=&#34;应用2-poj2752&#34;&gt;应用2 &lt;a href=&#34;http://poj.org/problem?id=2752&#34; target=&#34;_blank&#34;&gt;poj2752&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;题目大意是给你一个字符串s，找出所有前缀等于后缀的串长。我们先来试试算一个短点的&lt;code&gt;ababcababcabab&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;next&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以轻松看出next的最后一个值9肯定就是其中一个长度，那接着呢？我们需要回想一下，构造这个数组的时候，如果匹配失败，是怎么找到前一个匹配当前后缀的前缀的，这个值如果是p，那就移动到&lt;code&gt;arr[p]&lt;/code&gt;的地方，如果你还记得这个，那就好办了，我们取&lt;code&gt;arr[9]&lt;/code&gt;，结果是4，再取&lt;code&gt;arr[4]&lt;/code&gt;结果是2，再取&lt;code&gt;arr[2]&lt;/code&gt;，结果是0，循环结束，所以加上整个串长14就是我们所要的答案了，完整结果是&lt;code&gt;2 4 9 14&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;应用3-子串出现次数&#34;&gt;应用3 子串出现次数&lt;/h3&gt;

&lt;p&gt;给你主串s和子串t，求t在s中出现了多少次，例如&lt;code&gt;s=&amp;quot;abababa&amp;quot;&lt;/code&gt;，&lt;code&gt;t=&amp;quot;aba&amp;quot;&lt;/code&gt;，那么t在s中出现了3次。&lt;/p&gt;

&lt;p&gt;这里运用到一个技巧，我们把s和t连接成这个串&lt;code&gt;u=&amp;quot;aba#abababa&amp;quot;&lt;/code&gt;，即把t放在s的前面并中间使用&lt;code&gt;#&lt;/code&gt;分隔，这个符号在两个串中都没有出现。然后我们对u计算next数组，那么next数组中值等于t的长度的元素个数就是答案。&lt;/p&gt;

&lt;h3 id=&#34;应用4-可重叠最长重复子串&#34;&gt;应用4 可重叠最长重复子串&lt;/h3&gt;

&lt;p&gt;大意是给你一个字符串s，任意选取两个不同的起始位置i和j，这两个位置的后缀串有相同的前缀，这个前缀可以重叠，问这个相同的前缀的最大长度&lt;/p&gt;

&lt;p&gt;例如&lt;code&gt;eabcaefabcabc&lt;/code&gt;，最长重复子串是&lt;code&gt;abca&lt;/code&gt;，长度是4。&lt;/p&gt;

&lt;p&gt;KMP在生成的时候，总是以串的前缀作为匹配对象，我们要做的，就是遍历那个字符串的每一个后缀，都生成一次next数组，而在生成过程中出现的最大值就是答案，所以时间复杂度 $O(n^2)$ 。当然我们还有更好的算法，这个之后再讲。&lt;/p&gt;

&lt;h2 id=&#34;z-algorithm&#34;&gt;Z Algorithm&lt;/h2&gt;

&lt;p&gt;Z函数的定义是对于字符串s，生成数组z，定义&lt;code&gt;z[i]&lt;/code&gt;是&lt;code&gt;s.substr(i)&lt;/code&gt;与&lt;code&gt;s&lt;/code&gt;的最长相同前缀长度&lt;/p&gt;

&lt;p&gt;样例如下&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;扩展KMP需要依赖这个z数组，但是在介绍这个之前，我们先介绍下面的扩展KMP&lt;/p&gt;

&lt;h2 id=&#34;扩展kmp&#34;&gt;扩展KMP&lt;/h2&gt;

&lt;p&gt;所谓扩展KMP，即给定两个字符串s和p，需要求出数组&lt;code&gt;ext&lt;/code&gt;，其中&lt;code&gt;ext[i]&lt;/code&gt;的值表示&lt;code&gt;s.substr(i)&lt;/code&gt;与&lt;code&gt;p&lt;/code&gt;的最长相同前缀长度&lt;/p&gt;

&lt;p&gt;这个算法依赖 Z Algorithm 中生成的z数组。&lt;/p&gt;

&lt;p&gt;为了比较容易理解，我省略一堆说明，我们直接来模拟匹配过程，一边模拟一边解说，一开始数据如下，i是匹配位置指针&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上表，一开始，不匹配，不操作，移动p&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这时，p与&lt;code&gt;s[i]&lt;/code&gt;是匹配的，我们用e指针记录&lt;strong&gt;未能匹配&lt;/strong&gt;的位置，并写入&lt;code&gt;ext[i]=e-i&lt;/code&gt;得1&lt;/p&gt;

&lt;p&gt;继续移动p，并更新e，得到下表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;得到上表这个后，令&lt;code&gt;ext[i]=e-i&lt;/code&gt;得5，这个时候，移动到下一个元素，但同时p暂时不动。这个情况出现于&lt;code&gt;p&amp;lt;e&lt;/code&gt;的时候，严格来说，应该是&lt;code&gt;z[i-p]+i &amp;lt; e&lt;/code&gt;的时候，具体原因后面解释。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上表这个时候，不看字符匹配的情况，只看i指针位置上那一列对应的Z数组的值，即&lt;code&gt;z[i-p]&lt;/code&gt;为0，如果这个数加上i小于e的话，直接令&lt;code&gt;ext[i]=z[i-p]&lt;/code&gt;得到0&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;继续以上操作，&lt;code&gt;ext[i]=z[i-p]&lt;/code&gt;得到1。之所以能这么操作，是因为p是自匹配的，在这个位置上的z值，就同时表达了i开始，字符串s与p连续多少个字符能匹配p的前缀，前提是这个串的范围必须在e的前面。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;继续以上操作，&lt;code&gt;ext[i]=z[i-p]&lt;/code&gt;得到0，注意到，下一步i将指向a，导致&lt;code&gt;z[i-p]+i &amp;gt;= e&lt;/code&gt;，这个会导致z数组的内容不能直接复制到ext数组内，所以我们要恢复之前的字符串匹配过程，令p等于i，得如下状态&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个时候，写入&lt;code&gt;ext[i]=e-i&lt;/code&gt;得1&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最后一步，第一个也不匹配，写入&lt;code&gt;ext[i]=e-i&lt;/code&gt;得0，下一步i到达字符串末尾，结束。&lt;/p&gt;

&lt;p&gt;扩展kmp与经典kmp的算法的时间复杂度均为 $O(len(s)+len(p))$&lt;/p&gt;

&lt;p&gt;那么讲完了扩展KMP我们回来讲Z Algorithm，其实它们的区别，仅仅是计算对象的差异，即扩展KMP是通过字符串p求出s的ext数组，而Z Algorithm是通过自身来求，我们只需要把原来扩展KMP的代码复制一份改改名字，且起点改为1行了，详见下面模板实现代码。&lt;/p&gt;

&lt;p&gt;应用实例有：&lt;a href=&#34;http://acm.hdu.edu.cn/showproblem.php?pid=4333&#34; target=&#34;_blank&#34;&gt;hdu4333&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;kmp模板&#34;&gt;KMP模板&lt;/h2&gt;

&lt;p&gt;以下是我写的模板代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void kmp_next(const char* pattern, int next[])
{
    int len = strlen(pattern);
    next[0] = -1;
    for (int i = 0, j = -1; i &amp;lt; len;)
    {
        if (j == -1 || pattern[i] == pattern[j])
            next[++i] = ++j;
        else
            j = next[j];
    }
}

const char* kmp_match(const char* str, const char* pattern, int next[])
{
    int len = strlen(pattern);
    int i = 0;
    kmp_next(pattern, next);
    while (*str &amp;amp;&amp;amp; i &amp;lt; len)
    {
        if (pattern[i] == *str)
        {
            ++i, ++str;
        }
        else
        {
            i = next[i];
            if (i == -1)
            {
                ++i, ++str;
            }
        }
    }
    return i == len ? str - i : str;
}

void extkmp_z(const char* str, int z[])
{
    int s_len = strlen(str);
    z[0] = s_len;
    for (int i = 1, p = 1, e = 1; i &amp;lt; s_len; ++i)
    {
        if (i + z[i - p] &amp;gt;= e)
        {
            e = std::max(i, e);
            p = i;

            while (e &amp;lt; s_len &amp;amp;&amp;amp; str[e] == str[e - i])
                ++e;

            z[i] = e - i;
        }
        else
            z[i] = z[i - p];
    }
}

void extkmp_ext(const char* str, int ext[], const char* pattern, int z[])
{
    int s_len = strlen(str);
    extkmp_z(pattern, z);
    for (int i = 0, p = 0, e = 0; i &amp;lt; s_len; ++i)
    {
        if (i + z[i - p] &amp;gt;= e)
        {
            e = std::max(i, e);
            p = i;

            while (e &amp;lt; s_len &amp;amp;&amp;amp; str[e] == pattern[e - i])
                ++e;

            ext[i] = e - i;
        }
        else
            ext[i] = z[i - p];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;最后总结&#34;&gt;最后总结&lt;/h2&gt;

&lt;p&gt;字符串就是一个深坑，不过KMP也许是打开你理解后缀树或后缀数组的好工具，为后者的学习做铺垫。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Quick sort(快速排序)杂谈 3</title>
      <link>/post/20191019-qsort-talk-3/</link>
      <pubDate>Mon, 21 Oct 2019 17:32:00 +0800</pubDate>
      <guid>/post/20191019-qsort-talk-3/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;/post/20191007-qsort-talk-2/&#34;&gt;上一篇&lt;/a&gt;我们介绍了快排的各种优化，最后得到了一个超越VS的STL std::sort实现的版本，这回我们来讲讲怎么折磨gcc的std::sort。&lt;/p&gt;

&lt;h2 id=&#34;gcc的实现&#34;&gt;GCC的实现&lt;/h2&gt;

&lt;p&gt;这个我直接给个&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/gcc-8-branch/libstdc++-v3/include/bits/stl_algo.h#L1896&#34; target=&#34;_blank&#34;&gt;github来源&lt;/a&gt;，链接里是gcc8分支的实现源码，我已经通过链接标记出第1896行，那里就是&lt;code&gt;__unguarded_partition&lt;/code&gt;函数的实现，就是快排的划分函数，而在后面几个函数就是快排的本体了。为了避免它代码更新导致位置变化，我把相关代码复制过来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
  template&amp;lt;typename _Iterator, typename _Compare&amp;gt;
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
                           _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
        {
          if (__comp(__b, __c))
            std::iter_swap(__result, __b);
          else if (__comp(__a, __c))
            std::iter_swap(__result, __c);
          else
            std::iter_swap(__result, __a);
        }
      else if (__comp(__a, __c))
        std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
        std::iter_swap(__result, __c);
      else
        std::iter_swap(__result, __b);
    }

  /// This is a helper function...
  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
                          _RandomAccessIterator __last,
                          _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
        {
          while (__comp(__first, __pivot))
            ++__first;
          --__last;
          while (__comp(__pivot, __last))
            --__last;
          if (!(__first &amp;lt; __last))
            return __first;
          std::iter_swap(__first, __last);
          ++__first;
        }
    }

  /// This is a helper function...
  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
                                _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                                  __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline void
    __partial_sort(_RandomAccessIterator __first,
                   _RandomAccessIterator __middle,
                   _RandomAccessIterator __last,
                   _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }

  /// This is a helper function for the sort routine.
  template&amp;lt;typename _RandomAccessIterator, typename _Size, typename _Compare&amp;gt;
    void
    __introsort_loop(_RandomAccessIterator __first,
                     _RandomAccessIterator __last,
                     _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first &amp;gt; int(_S_threshold))
        {
          if (__depth_limit == 0)
            {
              std::__partial_sort(__first, __last, __last, __comp);
              return;
            }
          --__depth_limit;
          _RandomAccessIterator __cut =
            std::__unguarded_partition_pivot(__first, __last, __comp);
          std::__introsort_loop(__cut, __last, __depth_limit, __comp);
          __last = __cut;
        }
    }

  // sort

  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Compare __comp)
    {
      if (__first != __last)
        {
          std::__introsort_loop(__first, __last,
                                std::__lg(__last - __first) * 2,
                                __comp);
          std::__final_insertion_sort(__first, __last, __comp);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;吐槽一句，连gcc源代码也把tab和空格混合使用我也是醉了，源代码的tab在这里已替换为空格以保证版面一致&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;这里我们并不需要关注太多东西，在上一篇我们讲到过，快排最大的弱点正在于它的划分元素选择上，所以我们只需要看这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
                                _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                                  __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数从&lt;code&gt;__first + 1&lt;/code&gt;, &lt;code&gt;__mid&lt;/code&gt;, &lt;code&gt;__last - 1&lt;/code&gt;三个数里面，取一个中位数交换到&lt;code&gt;__first&lt;/code&gt;的位置，知道这个就能想办法生成对抗数据了。为了让它运行缓慢，那么只要让它这个函数每次都选到&lt;strong&gt;第二小&lt;/strong&gt;的元素放最左边，这样每次调用&lt;code&gt;__unguarded_partition&lt;/code&gt;的结果，就是把划分点划分到了&lt;code&gt;__first + 2&lt;/code&gt;的位置上，即每次只划分两个元素，这就是它的最坏情况。&lt;/p&gt;

&lt;p&gt;构造这个东西需要一些技巧，我们要模拟std::sort的过程，但为了复杂性降低，我们令最右边元素值最大，那么中位数必定在&lt;code&gt;__first + 1&lt;/code&gt;与&lt;code&gt;__mid&lt;/code&gt;中选出，这样在partition过程中就能保证不会动到最后的元素，只会在这两个之间换来换去。然后我们只模拟出交换的结果，而不必去遍历，否则你生成的复杂度就$O(n^2)$了。&lt;/p&gt;

&lt;p&gt;另外，还要注意的一点是，它使用的是&lt;code&gt;intro sort&lt;/code&gt;来实现，也就是说深度到一定程度后，会转化为堆排序，而堆排序的最坏情况是乱序数组，我们不必一直这么做，否则堆排序时间并不是最长的，我们只要弄深度150的就够用了。我们来看看生成的数据在8000000长度下，使用mingw64-gcc8编译参数-O3的实测结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;evil&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;intro_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;76&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;82&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;509&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;510&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;510&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;282&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;94&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;473&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;487&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1650&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;480&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::heap&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;584&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;369&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;421&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1436&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1467&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1499&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;962&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;第4、5列是随机打乱的数据，作为对比组，而evil列就是生成的对抗数据，我把&lt;code&gt;heap sort&lt;/code&gt;及前一篇的&lt;code&gt;intro_sort&lt;/code&gt;实现放上来做比较，可以看出在这组数据下，&lt;code&gt;std::sort&lt;/code&gt;必然地比堆排序还要慢，是乱序数据的3.5倍左右，当然这个时间完全取决于堆排序的时间。&lt;/p&gt;

&lt;p&gt;附上生成代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct save_index
{
    int val;
    int index;

    save_index(int i = 0, int v = -1)
        : val(v)
        , index(i)
    {}
    void swap(save_pos&amp;amp; p)
    {
        int t = p.val;
        p.val = val;
        val = t;
    }
    bool operator &amp;lt; (const save_index&amp;amp; p) const
    {
        return index &amp;lt; p.index;
    }
};

void qsort_sim_gcc(save_index * beg, save_index * end, int max_round)
{
    int cur_num = 0;
    if ((end-1)-&amp;gt;val == -1)
    {
        (end - 1)-&amp;gt;val = (end - beg) * 2;
    }
    while (beg + 1 &amp;lt; end &amp;amp;&amp;amp; --max_round &amp;gt; 0)
    {
        save_index *l = beg + 1, *r = end - 1, *m = beg + (end - beg) / 2;

        if (l-&amp;gt;val == -1)
            l-&amp;gt;val = ++cur_num;
        if (r-&amp;gt;val == -1)
            r-&amp;gt;val = ++cur_num;
        if (m-&amp;gt;val == -1)
            m-&amp;gt;val = ++cur_num;

        if (l-&amp;gt;val &amp;gt; m-&amp;gt;val)
        {
            if (m-&amp;gt;val &amp;gt; r-&amp;gt;val)
                std::swap(*beg, *m);
            else if (l-&amp;gt;val &amp;gt; r-&amp;gt;val)
                std::swap(*beg, *r);
            else
                std::swap(*beg, *l);
        }
        else
        {
            if (m-&amp;gt;val &amp;lt; r-&amp;gt;val)
                std::swap(*beg, *m);
            else if (l-&amp;gt;val &amp;gt; r-&amp;gt;val)
                std::swap(*beg, *l);
            else
                std::swap(*beg, *r);
        }
        if (l-&amp;gt;val &amp;lt; beg-&amp;gt;val &amp;amp;&amp;amp; l-&amp;gt;val != -1)
            ;
        else if (m-&amp;gt;val &amp;lt; beg-&amp;gt;val &amp;amp;&amp;amp; m-&amp;gt;val != -1)
            std::swap(*l, *m);
        beg += 2;
    }
}

void anti_qsort_gen_gcc(std::vector&amp;lt;save_index&amp;gt;&amp;amp; vec, size_t len, int max_round)
{
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        vec.push_back(save_index((int)i));
    }
    qsort_sim_gcc(&amp;amp;*vec.begin(), &amp;amp;*vec.begin() + len, max_round);
    int cnt = 0;
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        if (vec[i].val == -1)
            ++cnt;
    }
    std::vector&amp;lt;int&amp;gt; val_list(cnt);
    for (int i = 0; i &amp;lt; cnt; ++i)
    {
        val_list[i] = i + len - cnt;
    }
    // 以下 random_shuffle 实现需要自己实现，如果你用的是mingw
    // 不能使用std::random_shuffle，注意
    random_shuffle(val_list.begin(), val_list.end());
    for (int i = 0, j = 0; i &amp;lt; len; ++i)
    {
        if (vec[i].val == -1)
        {
            vec[i].val = val_list[j++];
        }
    }
    std::sort(vec.begin(), vec.end());
}

void anti_qsort_gen_gcc(sort_element_t arr[], size_t len)
{
    std::vector&amp;lt;save_index&amp;gt; vec;
    anti_qsort_gen_gcc(vec, len, 150);
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        arr[i] = vec[i].val;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中注释的random_shuffle问题参见&lt;a href=&#34;../20191006-mingw-bug/&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后总结，老实加个rand比啥都强，至少大大增加构造evil数据的难度，也大大降低遇到最坏情况的可能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Quick sort(快速排序)杂谈 2</title>
      <link>/post/20191019-qsort-talk-2/</link>
      <pubDate>Sat, 19 Oct 2019 00:57:00 +0800</pubDate>
      <guid>/post/20191019-qsort-talk-2/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;/post/20191007-qsort-talk-1/&#34;&gt;上一篇&lt;/a&gt;我们介绍了四种不同的划分算法，现在我们来针对&lt;a href=&#34;/post/20191007-qsort-talk-1/#3-hoare-partition-scheme&#34;&gt;Hoare partition scheme&lt;/a&gt;来讲解一些优化和注意的问题。&lt;/p&gt;

&lt;h2 id=&#34;最坏时间复杂度的优化&#34;&gt;最坏时间复杂度的优化&lt;/h2&gt;

&lt;p&gt;在前一篇的示例代码里面，只是最简单地选择的最开头或最后面的元素作为划分，这对于乱序的数据还好，对于有序的数据这么做，时间复杂度就直接变成$O(n^2)$了，那么怎么解决？第一个要解决的反而不是划分元素的选择上，而是改成&lt;code&gt;intro sort&lt;/code&gt;，记录递归深度或类似的办法，到达限制条件的时候改而使用堆排序，这属于混合排序，先让排序的最坏时间复杂度降下来是第一要务。所以可以改写出以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    sort_element_t *l = beg, *r = end - 1;
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}

void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 1)
        return;

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    intro_sort_recursive(p + 1, end, depth - 1);
}

void intro_sort(sort_element_t * beg, sort_element_t * end)
{
    int depth = (int)(log(end - beg) * 2.5);
    intro_sort_recursive(beg, end, depth);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，这份代码使用的分割结果是&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;左&lt;/th&gt;
&lt;th&gt;中&lt;/th&gt;
&lt;th&gt;右&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;至于为什么选择这种划分结果，与后面的优化有关系。&lt;/p&gt;

&lt;h2 id=&#34;划分元素的选择&#34;&gt;划分元素的选择&lt;/h2&gt;

&lt;p&gt;好，我们从这个代码开始重新谈一下分割元素的选取，网上常见有以下方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;固定选择最开头或最后一个&lt;/li&gt;
&lt;li&gt;固定选择中间的元素&lt;/li&gt;
&lt;li&gt;随机选择元素&lt;/li&gt;
&lt;li&gt;在开头、中间、末尾固定三个数里选择一个中位数&lt;/li&gt;
&lt;li&gt;在更多的数里面找中位数，同样是固定选择&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，我们能显然地排除第一个，它对已排序或接近排序完成的数据效率特别低，所以，接下来我们的思路就是分别针对这些选择方案看看有哪些情况让它们特别低效。&lt;/p&gt;

&lt;p&gt;那么按这个思路，我样再来考虑一下，如果要排序的数据重复元素特别的多，甚至于所有元素都相等呢？这时候你会发现不管哪种选取方案都没有用，都会陷入最坏情况，所以我们接下来在继续研究分割元素的选取之前，先考虑重复元素的问题。&lt;/p&gt;

&lt;h2 id=&#34;重复元素的过滤&#34;&gt;重复元素的过滤&lt;/h2&gt;

&lt;p&gt;之所以分割方式使用上文那种，为的就是能更方便地过滤重复元素，大于等于分割元素的，都一定在分割位置的右边，所以&lt;code&gt;intro_sort_recursive&lt;/code&gt;函数可以这样改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 1)
        return;

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    for (++p; p &amp;lt; end &amp;amp;&amp;amp; !(p[-1] &amp;lt; *p || *p &amp;lt; p[-1]); )
        ++p;
    intro_sort_recursive(p, end, depth - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;!(p[-1] &amp;lt; *p || *p &amp;lt; p[-1])&lt;/code&gt;就是判断&lt;code&gt;p[-1] == *p&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样修改后，在所有元素相等的情况下，时间复杂度能达到$O(n)$&lt;/p&gt;

&lt;h2 id=&#34;再次考虑划分元素的选择&#34;&gt;再次考虑划分元素的选择&lt;/h2&gt;

&lt;p&gt;这次我们把方案一个个来列举优缺点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;固定选择中间的元素，速度快，对有序或逆序的数据分割效率最高，但在中间附近元素都是数据里最大的数据的时候，即遇到最坏情况，会快速退化成堆排序&lt;/li&gt;
&lt;li&gt;在开头、中间、末尾固定三个数里选择一个中位数，这个是也gcc的STL实现，但能构造出让它遇到最坏情况的数据，比乱序数据慢4倍甚至更多&lt;/li&gt;
&lt;li&gt;在更多的数里面找中位数，同样是固定选择，VS的STL实现就是在9个数里面取，但同样能构造出让它遇到最坏情况的数据，比乱序数据慢4倍甚至更多&lt;/li&gt;
&lt;li&gt;随机选择元素，遇到最坏情况机率极低，但对于有序或逆序的数据时间比前三种都会慢一些&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事实上，任何的固定选取方案理论上都能构造出固定的使其遇到最坏的情况，而我们的目标当然是让它减少遇到的机率，所以我推荐增加随机选择在里面，但单纯的随机选择虽然并不太优秀，但已足够实用，而且我们并不需要真的搞什么复杂的随机数，所以我们先来实现这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    static int s_rnd = 0x123456;
    sort_element_t *l = beg, *r = end - 1;
    sort_element_swap(r, l + (++s_rnd % (end - beg)));
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要一个静态的计数器作为随机数其实就足够了，把选中的元素交换到最右边即可。&lt;/p&gt;

&lt;p&gt;那我们还是要考虑优化的话怎么弄呢？那我们结合着来，在三个数里取中位数，不过还要带上随机，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline void make_mid_pivot(sort_element_t* l, sort_element_t* mid, sort_element_t* r)
{
    if (*r &amp;lt; *mid)
    {
        if (*mid &amp;lt; *l)
            return;
        sort_element_swap(mid, r);
    }
    if (*mid &amp;lt; *l)
    {
        sort_element_swap(mid, l);
        if (*r &amp;lt; *mid)
            sort_element_swap(mid, r);
    }
}

sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    static int s_rnd = 0x123456;
    sort_element_t *l = beg, *r = end - 1;
    int half = (end - beg) / 2;
    make_mid_pivot(l + s_rnd % half, l + half, r - s_rnd % half);
    ++s_rnd;
    sort_element_swap(r, l + half);
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这个阶段，这个实现已经能和VS版本的std::sort平起平坐了，接下我们就要超越它&lt;/p&gt;

&lt;h2 id=&#34;小数据优化&#34;&gt;小数据优化&lt;/h2&gt;

&lt;p&gt;当需要排序的数据长度较小的时候，快速排序其实并不快，我们改用插入排序，在16个元素或以下的时候使用。修改的那部分代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 16)
    {
        insert_sort(beg, end);
        return;
    }

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    for (++p; p &amp;lt; end &amp;amp;&amp;amp; !(p[-1] &amp;lt; *p || *p &amp;lt; p[-1]); )
        ++p;
    intro_sort_recursive(p, end, depth - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，已经能比VS的std::sort快了&lt;/p&gt;

&lt;h2 id=&#34;运行测试&#34;&gt;运行测试&lt;/h2&gt;

&lt;p&gt;我们来看在VS2005下对4500000个int排序的测试结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;intro_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;38&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;43&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;282&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;281&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;60&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;103&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;269&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;116&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;327&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;331&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;72&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;85&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;317&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;139&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再看mingw64-gcc9下使用&lt;code&gt;-O3&lt;/code&gt;参数编译，对4500000个int排序的测试结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;intro_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;41&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;274&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;281&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;67&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;105&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;266&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;118&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;45&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;55&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;254&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;255&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;98&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;82&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;106&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;248&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;125&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看到几乎在所有的测试数据里都比VS的实现快。不过尽管这个比VS的实现快，但比起gcc的实现还是稍差一点点，但已经足够好。&lt;/p&gt;

&lt;p&gt;本篇就介绍到这里了，最后把优化后的完整代码给出，更多优化请看下一篇文章&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline void make_mid_pivot(sort_element_t* l, sort_element_t* mid, sort_element_t* r)
{
    if (*r &amp;lt; *mid)
    {
        if (*mid &amp;lt; *l)
        {
            return;
        }
        sort_element_swap(mid, r);
    }
    if (*mid &amp;lt; *l)
    {
        sort_element_swap(mid, l);
        if (*r &amp;lt; *mid)
            sort_element_swap(mid, r);
    }
}

sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    static int s_rnd = 0x123456;
    sort_element_t *l = beg, *r = end - 1;
    int half = (end - beg) / 2;
    make_mid_pivot(l + s_rnd % half, l + half, r - s_rnd % half);
    ++s_rnd;
    sort_element_swap(r, l + half);
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}

void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 16)
    {
        insert_sort(beg, end);
        return;
    }

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    for (++p; p &amp;lt; end &amp;amp;&amp;amp; !(p[-1] &amp;lt; *p || *p &amp;lt; p[-1]); )
        ++p;
    intro_sort_recursive(p, end, depth - 1);
}

void intro_sort(sort_element_t * beg, sort_element_t * end)
{
    int depth = (int)(log(end - beg) * 2.5);
    intro_sort_recursive(beg, end, depth);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>毕氏三元数与复数</title>
      <link>/post/20191018-pythagorean-triple/</link>
      <pubDate>Fri, 18 Oct 2019 14:17:00 +0800</pubDate>
      <guid>/post/20191018-pythagorean-triple/</guid>
      <description>&lt;p&gt;所谓毕氏（毕达哥拉斯）三元数（Pythagorean triple），又叫做勾股数，商高数，是由毕氏定理衍生出来的，即直角三角形两直角边的平方和等于第三边的平方。毕氏三元数就是满足方程 $a^2+b^2=c^2$ 的正整数解，例如3,4,5这组解，以下我们用 $(3,4,5)$ 来表示一组毕氏三元数。这里存在一个问题，有没有可能表示出所有的正整数解呢？&lt;/p&gt;

&lt;p&gt;假设我们随意取直角边的长度，例如1和2，那么斜边长为 $\sqrt{5}$ ，斜边长度不是整数，那怎么把它变成整数呢，很简单，直接平方一下，可是两直角边就不对了，那怎么解决呢？标题上已经剧透了我们要使用复数，那么，我们可以把斜边看成是一个复数，而两直角边分别是复数的实部和虚部，那么我们就可以把刚刚例子中的直角三角形用 $2+i$ 来表示，那我们对这个复数计算平方，$(2+i)(2+i)=4+4i-1=3+4i$，这个复数的模就是5。哎？我们看到了这是啥？是不是正好表示 $(3,4,5)$ ，这是巧合吗？&lt;/p&gt;

&lt;p&gt;我们再来换一组，就 $3+2i$ 吧，平方一下，得到 $(3+2i)(3+2i)=9+12i-4=5+12i$ ，模是13，表示的是 $(5,12,13)$ 。刚刚的都是实部比虚部要大的，再试试虚部大的 $(2+3i)(2+3i)=4+12-9=-5+12i$ ，得到的是方程的负数解。你继续试验其它的值的话将得到更多的毕氏三元数。&lt;/p&gt;

&lt;p&gt;首先我们要知道一个结论，实部虚部都是整数的复数，它平方后实部虚部仍然是整数，同时它的模也会得到整数，那么它的实部虚部的平方和，就等于模的平方。例如 $(a+bi)(a+bi)=a^2+2abi-b^2=a^2-b^2+2abi$ ，而这个复数的模是 $a^2+b^2$，于是我们得到毕氏三元数的整数解公式&lt;/p&gt;

&lt;p&gt;$$(u^2-v^2,2uv,u^2+v^2)$$&lt;/p&gt;

&lt;p&gt;接下来我们用另一种方法证明&lt;/p&gt;

&lt;p&gt;根据原式公式 $a^2+b^2=c^2$ ，我们假定a与b互质，那么可推论a,b,c两两互质，又称为素三元数。原式子可以改写为 $a^2=c^2-b^2=(c+b)(c-b)$ 那么 $\frac{a}{c-b}=\frac{c+b}{a}$ ，令 $\frac{c-b}{a}=\frac{c}{a}-\frac{b}{a}=\frac{n}{m}$ ，其中$m,n$都是正整数且互质，得$\frac{c+b}{a}=\frac{c}{a}+\frac{b}{a}=\frac{m}{n}$ 两式相加得&lt;/p&gt;

&lt;p&gt;$$\frac{c}{a}=\frac{1}{2}(\frac{n}{m}+\frac{m}{n})=\frac{m^2+n^2}{2mn}$$&lt;/p&gt;

&lt;p&gt;两式相减得&lt;/p&gt;

&lt;p&gt;$$\frac{b}{a}=\frac{1}{2}(\frac{m}{n}-\frac{n}{m})=\frac{m^2-n^2}{2mn}$$&lt;/p&gt;

&lt;p&gt;因为我们需要$a,b,c$都是正整数，所以$\frac{c}{a}$与$\frac{b}{a}$是有理数且不可约简（它们之间互质），而且两数分母一样，而这两个等式右边分母都是$2mn$，即式子左右两边分母相等，所以$a=2mn$且$\frac{m^2+n^2}{2mn}$与$\frac{m^2-n^2}{2mn}$不可约简（互质）。另外因为分母一定是偶数，所以$m,n$当中必须一个奇数一个偶数。由此解得三元数公式与前面完全一致。&lt;/p&gt;

&lt;p&gt;那有没有这个公式无法表示的毕氏三元数呢，我们假设这个无法表示的三元数是$(a&amp;rsquo;,b&amp;rsquo;,c&amp;rsquo;)$，那么c-b是个正整数，所以$\frac{c-b}{a}$一定是有理数，满足 $\frac{c-b}{a}=\frac{n}{m}$ 的唯一的一对素质m与n必定存在，而通过这个m与n必定能通过上面的公式表示出$(a&amp;rsquo;,b&amp;rsquo;,c&amp;rsquo;)$，但前提是a,b,c之间两两互质，在这个前提下，与前面假设矛盾，所以这个公式能表示所有的素毕氏三元数，但不能表示所有的毕氏三元数。&lt;/p&gt;

&lt;p&gt;那咱们回到复数表示法上，对于任意的 $(a,b,c)$ ，相应的复数定义为 $a+bi$ ，再通过前面的公式替换为 $m^2-n^2+2mni$ ，然后我们来求解 $\sqrt{m^2-n^2+2mni}=m+ni$，即任意整系数复数的平方，均能表示一组毕氏三元数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>smooth sort与weakheap sort实现</title>
      <link>/post/20191017-weakheapsort/</link>
      <pubDate>Thu, 17 Oct 2019 17:14:00 +0800</pubDate>
      <guid>/post/20191017-weakheapsort/</guid>
      <description>&lt;p&gt;本篇补充&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;，不打算做太多介绍，&lt;del&gt;因为自己太菜不会讲，&lt;/del&gt;只作为笔记来记录一下实现代码。&lt;code&gt;smooth sort&lt;/code&gt;在接近排序完成的情况下的动态图&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Smoothsort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/a/a5/Smoothsort.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;smooth-sort&#34;&gt;smooth sort&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// http://www.keithschwarz.com/smoothsort/
static const unsigned int leonardo[] =
{
   1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973,
   3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049, 242785,
   392835, 635621, 1028457, 1664079, 2692537, 4356617, 7049155, 11405773,
   18454929, 29860703, 48315633, 78176337, 126491971, 204668309, 331160281,
   535828591, 866988873, 1402817465, 2269806339u, 3672623805u,
};

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void smooth_sort_fix(RandomAccessIterator arr, size_t current_heap, int level_index, int levels[], Comp compare)
{
    while (level_index &amp;gt; 0)
    {
        size_t prev_heap = current_heap - leonardo[levels[level_index]];
        if (compare(arr[current_heap], arr[prev_heap]))
        {
            if (levels[level_index] &amp;gt; 1)
            {
                size_t child_heap2 = current_heap - 1;
                size_t child_heap1 = child_heap2 - leonardo[levels[level_index] - 2];
                if (compare(arr[prev_heap], arr[child_heap1])
                    || compare(arr[prev_heap], arr[child_heap2]))
                    break;
            }
            std::swap(arr[current_heap], arr[prev_heap]);
            current_heap = prev_heap;
            level_index -= 1;
        }
        else
            break;
    }

    int current_level = levels[level_index];
    while (current_level &amp;gt; 1)
    {
        size_t max_child = current_heap;
        size_t child_heap2 = current_heap - 1;
        size_t child_heap1 = child_heap2 - leonardo[current_level - 2];

        if (compare(arr[max_child], arr[child_heap1])) max_child = child_heap1;
        if (compare(arr[max_child], arr[child_heap2])) max_child = child_heap2;
        if (max_child == child_heap1)
        {
            std::swap(arr[current_heap], arr[child_heap1]);
            current_heap = child_heap1;
            current_level -= 1;
        }
        else if (max_child == child_heap2)
        {
            std::swap(arr[current_heap], arr[child_heap2]);
            current_heap = child_heap2;
            current_level -= 2;
        }
        else break;
    }
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void smooth_sort(RandomAccessIterator arr, size_t size, Comp compare)
{
    int levels[64] = { 1 };
    int toplevel = 0;

    for (size_t i = 1; i &amp;lt; size; ++i)
    {
        if (toplevel &amp;gt; 0 &amp;amp;&amp;amp; levels[toplevel - 1] - levels[toplevel] == 1)
        {
            toplevel -= 1;
            levels[toplevel] += 1;
        }
        else if (levels[toplevel] != 1)
        {
            toplevel += 1;
            levels[toplevel] = 1;
        }
        else
        {
            toplevel += 1;
            levels[toplevel] = 0;
        }
        smooth_sort_fix(arr, i, toplevel, levels, compare);
    }

    for (size_t i = size - 2; i &amp;gt; 0; --i)
    {
        if (levels[toplevel] &amp;lt;= 1)
        {
            toplevel -= 1;
        }
        else
        {
            levels[toplevel] -= 1;
            levels[toplevel + 1] = levels[toplevel] - 1;
            toplevel += 1;

            smooth_sort_fix(arr, i - leonardo[levels[toplevel]], toplevel - 1, levels, compare);
            smooth_sort_fix(arr, i, toplevel, levels, compare);
        }
    }
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void smooth_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        smooth_sort(&amp;amp;*beg, (size_t)(end - beg), compare);
    }
}

template&amp;lt;typename RandomAccessIterator&amp;gt;
void smooth_sort(RandomAccessIterator beg, RandomAccessIterator end)
{
    smooth_sort(beg, end, std::less&amp;lt;typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;weakheap-sort&#34;&gt;weakheap sort&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;unsigned char weakheap_getflag(unsigned char *r, size_t index)
{
    return (r[index &amp;gt;&amp;gt; 3] &amp;gt;&amp;gt; (index &amp;amp; 7)) &amp;amp; 1;
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void weakheap_merge(unsigned char flags[], RandomAccessIterator beg, RandomAccessIterator i, RandomAccessIterator j, Comp compare)
{
    if (compare(*i, *j))
    {
        flags[(j - beg) &amp;gt;&amp;gt; 3] ^= 1 &amp;lt;&amp;lt; ((j - beg) &amp;amp; 7);
        std::swap(*i, *j);
    }
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void weakheap_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        size_t n = (size_t)(end - beg);
        unsigned char * flags = new unsigned char[(n + 7) / 8];
        for (size_t i = 0; i &amp;lt; n / 8; ++i)
            flags[i] = 0;
        for (size_t i = n - 1; i &amp;gt; 0; --i)
        {
            size_t j = i;
            while ((j &amp;amp; 1) == weakheap_getflag(flags, j &amp;gt;&amp;gt; 1))
                j &amp;gt;&amp;gt;= 1;
            weakheap_merge(flags, beg, beg + (j &amp;gt;&amp;gt; 1), beg + i, compare);
        }
        for (size_t i = n - 1; i &amp;gt; 1; --i)
        {
            std::swap(*beg, *(beg + i));
            size_t j = 1, k;
            while ((k = 2 * j + weakheap_getflag(flags, j)) &amp;lt; i)
                j = k;
            while (j &amp;gt; 0)
            {
                weakheap_merge(flags, beg, beg, beg + j, compare);
                j &amp;gt;&amp;gt;= 1;
            }
        }
        std::swap(*beg, *(beg + 1));
        delete[] flags;
    }
}

template&amp;lt;typename RandomAccessIterator&amp;gt;
void weakheap_sort(RandomAccessIterator beg, RandomAccessIterator end)
{
    weakheap_sort(beg, end, std::less&amp;lt;typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>堆排序优化思路</title>
      <link>/post/20191015-sorting-3/</link>
      <pubDate>Tue, 15 Oct 2019 20:52:52 +0800</pubDate>
      <guid>/post/20191015-sorting-3/</guid>
      <description>&lt;p&gt;堆排序其实是最不好优化的一个，在数据结构都确定的情况下，优化空间太小，除非优化数据结构本身，但那样就不叫做堆排序了。类似堆排序的还有&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;，有兴趣可以自己查找相关资料。&lt;/p&gt;

&lt;h2 id=&#34;堆排序原理&#34;&gt;堆排序原理&lt;/h2&gt;

&lt;p&gt;堆排序其实是选择排序的优化变种，选择排序是把最大或最小的元素放到最边上，然后不断重复以上过程，堆排序也是如此，只不过堆排序通过构建数据结构，让查找最大或最小元素并放到最边上的速度比选择排序快得多。&lt;/p&gt;

&lt;p&gt;首先我们先来介绍什么是堆。堆只是个缩写，全名是二叉堆，是一种完全二叉树，它的特点是二叉堆的父节点元素不小于子节点的元素，以下为二叉堆例图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
30--&amp;gt;29
30--&amp;gt;28
29--&amp;gt;24
29--&amp;gt;25
28--&amp;gt;26
28--&amp;gt;22
24--&amp;gt;21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根节点是最大值的时候，就叫做最大堆，反之叫做最小堆。之所以使用完全二叉堆，是为了它能直接放到数组里，例如上图放数组里的结果是：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看出，就是按层序遍历的结果。这样表示的好处是，可以通过下标的简单运算得到子节点的下标，我们通过简单找规律就能发现，下标k的子节点是2k+1和2k+2，所以我们能直接在数组里组织一个二叉堆。而且堆的根节点就是最值，找最值的时间复杂度是O(1)&lt;/p&gt;

&lt;p&gt;那么假如堆结构已经组织好了，我们接下来看怎么排序，还是以刚刚的数组作为例子，下标0就是最大值，那么我们就把它拿出来，与最右边元素交换，得到&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;30&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指针&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下标7的是已经排好的，后面不管它。这时候堆的性质破坏了，我们要去修正，指针r的子结点分别是a和b，在r,a,b中找出最大的元素a与r交换，得到&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再继续操作&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这时候，指针r已经没有子结点，这时候堆就修正好了。这个过程由于是从根向叶子的操作，叫做shiftdown，还有一种相反的过程叫做shiftup，就是从叶子向根的方向操作。以上就是一轮完整的操作，包括交换最值，修正堆两步。不断循环以上操作直到所有元素有序即可。&lt;/p&gt;

&lt;p&gt;排序方法说完了，我们回头来说怎么构建堆。用shiftup法描述起来比较简单，一开始，只看下标0，那一个元素就肯定是堆。然后添加一个元素在最末，然后shiftup，修改新添加的元素，如此循环。伪代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;makeheap(arr, len)
    for i in (1, len)
        shiftup(arr, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而使用shiftdown的话，原理一样，只是换一个方向&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;makeheap(arr, len)
    for i in (len / 2, 1)
        shiftdown(arr, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下为完整动态图演示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Heapsort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;堆排序基本实现&#34;&gt;堆排序基本实现&lt;/h2&gt;

&lt;p&gt;以下shiftdown实现的函数名是max_heapify&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void max_heapify(sort_element_t arr[], size_t index, size_t length)
{
    size_t child;
    sort_element_t temp = arr[index];
    for (; (child = 2 * index + 1) &amp;lt; length; index = child)
    {
        if (child + 1 &amp;lt; length &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1])
            ++child;
        if (temp &amp;lt; arr[child])
            arr[index] = arr[child];
        else
            break;
    }
    arr[index] = temp;
}

void heap_sort(sort_element_t arr[], size_t length)
{
    if (length &amp;gt; 1)
    {
        for (size_t i = length / 2; i-- &amp;gt; 0; )
            max_heapify(arr, i, length);
        for (size_t i = length - 1; i &amp;gt; 0; --i)
        {
            sort_element_swap(&amp;amp;arr[0], &amp;amp;arr[i]);
            max_heapify(arr, 0, i);
        }
    }
}

void heap_sort(sort_element_t* beg, sort_element_t* end)
{
    heap_sort(beg, end - beg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;堆排序-优化&#34;&gt;堆排序&amp;rdquo;优化&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;我们来重新看原来的表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里下标k的子节点是2k+1和2k+2，运算起来麻烦，那我们如果把所有的下标加1，得到&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这时候，下标k的子节点是2k和2k+1，能减少一步加法运算&lt;/p&gt;

&lt;p&gt;所以可以得到以下模板代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void max_heapify(RandomAccessIterator arr, size_t index, size_t last, Comp compare)
{
    typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type temp = arr[index];
    size_t child;
    for (; (child = index &amp;lt;&amp;lt; 1) &amp;lt;= last; index = child)
    {
        if (child &amp;lt; last &amp;amp;&amp;amp; compare(*(arr + child), *(arr + child + 1)))
            ++child;
        if (compare(temp, *(arr + child)))
            *(arr + index) = *(arr + child);
        else
            break;
    }
    *(arr + index) = temp;
}

template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void heap_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        size_t length = (size_t)(end - beg);
        RandomAccessIterator parr = beg - 1;
        for (size_t i = length / 2; i &amp;gt; 0; --i)
            max_heapify_1(parr, i, length, compare);
        for (size_t i = length - 1; i &amp;gt; 0; --i)
        {
            std::swap(*beg, *(beg + i));
            max_heapify_1(parr, 1, i, compare);
        }
    }
}

template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void heap_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    heap_sort(beg, end, compare);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，还是那句但是，这些所谓的优化到了不同编译器的手上结果可能会和你想象的不一样。这个在VS上是有效果的，但不幸的是这份代码在GCC下跑得并没有比原来的快，不过在GCC上办法还是有的，就是把下标操作全部换成指针，见代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void max_heapify_p(RandomAccessIterator first, RandomAccessIterator target, RandomAccessIterator last, Comp compare)
{
    typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type temp = *target;
    --first;
    RandomAccessIterator son;
    for (; (son = target + (target - first)) &amp;lt;= last; target = son)
    {
        if (son &amp;lt; last &amp;amp;&amp;amp; compare(*son, *(son + 1)))
            ++son;
        if (compare(temp, *son))
            *target = *son;
        else
            break;
    }
    *target = temp;
}

template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void heap_sort_p(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        for (RandomAccessIterator i = beg + (end - beg) / 2; i &amp;gt;= beg; --i)
            max_heapify_p(beg, i, end - 1, compare);
        for (; --end &amp;gt; beg; )
        {
            std::swap(*beg, *end);
            max_heapify_p(beg, beg, end - 1, compare);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这份代码比GCC STL中的make_heap/sort_heap实现来得快一些。完整实现可以参见我的&lt;a href=&#34;https://github.com/Baobaobear/sort&#34; target=&#34;_blank&#34;&gt;sort项目&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;堆排序其它注意问题&#34;&gt;堆排序其它注意问题&lt;/h2&gt;

&lt;p&gt;堆排序在特殊情况下是能以O(n)复杂度完成的，就是当几乎所有元素或所有元素都相等的时候，是可以很快完成的。但是VS和GCC的STL中的堆排序实现面对这种情形时却花费较多的时间，原因是对相等元素的处理上，我们拿最前面的代码作为例子，我们如果改成这样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void max_heapify(sort_element_t arr[], size_t index, size_t length)
{
    size_t child;
    sort_element_t temp = arr[index];
    for (; (child = 2 * index + 1) &amp;lt; length; index = child)
    {
        if (child + 1 &amp;lt; length &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1])
            ++child;
        if (temp &amp;lt;= arr[child]) // 小于改小于等于
            arr[index] = arr[child];
        else
            break;
    }
    arr[index] = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void max_heapify(sort_element_t arr[], size_t index, size_t length)
{
    size_t child;
    sort_element_t temp = arr[index];
    for (; (child = 2 * index + 1) &amp;lt; length; index = child)
    {
        if (child + 1 &amp;lt; length &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1])
            ++child;
        if (arr[child] &amp;lt; temp) // 小于才跳出，与前一个等价
            break;
        arr[index] = arr[child];
    }
    arr[index] = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样导致的后果是不存在最优情况下O(n)的时间复杂度。最后再来回应开头的问题，什么很少听说&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;呢？单从时间复杂度其实看不出来不用它们的理由，但真正的问题是时间常数的问题，对普通的乱序数组，&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;比&lt;code&gt;heap sort&lt;/code&gt;慢，而且实现更复杂。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>素数判断和因子分解</title>
      <link>/post/20191013-prime-number/</link>
      <pubDate>Sun, 13 Oct 2019 15:37:00 +0800</pubDate>
      <guid>/post/20191013-prime-number/</guid>
      <description>&lt;p&gt;这里记录的是素数判断 &lt;code&gt;Miller Rabbin&lt;/code&gt; 的快速判定算法，而分解使用的算法是 &lt;code&gt;Pollard Rho&lt;/code&gt; 的玄学分解算法，这个算法的理论依据是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C&#34; target=&#34;_blank&#34;&gt;生日悖论&lt;/a&gt;，这里不具体讨论这个数学问题，具体讨论看前面链接就可以了。&lt;/p&gt;

&lt;p&gt;以下我们分别简要介绍这两个算法的原理&lt;/p&gt;

&lt;p&gt;首先这是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%B1%B3%E5%8B%92-%E6%8B%89%E5%AE%BE%E6%A3%80%E9%AA%8C&#34; target=&#34;_blank&#34;&gt;Miller Rabbin&lt;/a&gt;的维基百科介绍页，由于页面是中文，这里不做重复介绍。&lt;/p&gt;

&lt;p&gt;下面简要解释一下Pollard&amp;rsquo;s Rho算法的原理，这是它的&lt;a href=&#34;https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm&#34; target=&#34;_blank&#34;&gt;维基百科页面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先我们来定义这样一个函数&lt;/p&gt;

&lt;p&gt;$$f(x)=(x*x+c)%n$$&lt;/p&gt;

&lt;p&gt;其中n是需要被分解的数，c是一个任意小于n的正整数常数。那么我们给一个初始值x1，通过计算 $f(x1)$ 得到x2，然后去求 $|x1-x2|$ 与 n 的最大公约数，只要结果大于1就找到了分解结果。那如果最大公约数仍然是1，那么就通过刚才的x2求出 $x3=f(x2)$ 并计算 $|x1-x3|$ 与 n 的最大公约数。也就是说，我们可以通过这个公式得到一个数列&lt;/p&gt;

&lt;p&gt;$$ x1,x2,x3,&amp;hellip;,xn,&amp;hellip; $$&lt;/p&gt;

&lt;p&gt;但这个数列总是不会无限的，总是会循环的，那怎么去判断它有没有陷入循环呢，这用到的办法是Floyd判环算法，两个数在数列里以不同速度前进，如果环存在，那它们总会有相遇的时刻。在代码里，我们令变量x是正常速度，变量y是在x每迭代两次后y再迭代一次，所以如果环的长度是k，那么迭代k次就能发现环的存在。&lt;/p&gt;

&lt;p&gt;而在具体实现中，如果发现环的存在，我们需要变换常数c，再次进行尝试。那么我们下面不废话直接上代码，作为笔记。为了避免部分环境的输入输出问题，main函数使用了C++的输入输出，其它部分可以作为C函数使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdint&amp;gt;

int64_t gcd(int64_t a, int64_t b)
{
    return b == 0 ? a : gcd(b, a%b);
}

int64_t mul(int64_t a, int64_t b, int64_t mod)
{
    a %= mod;
    int64_t res = 0;
    while (b) {
        if (b &amp;amp; 1) res = (res + a) % mod;
        b &amp;gt;&amp;gt;= 1;
        a = (a &amp;lt;&amp;lt; 1) % mod;
    }
    return res;
}

int64_t quick_pow(int64_t a, int64_t n, int64_t mod)
{
    int64_t res = 1;
    while (n)
    {
        if (n &amp;amp; 1) res = mul(res, a, mod);
        a = mul(a, a, mod);
        n &amp;gt;&amp;gt;= 1;
    }
    return res;
}

int miller_rabbin(int64_t n, int a)
{
    int r = 0;
    int64_t s = n - 1;
    if (!(n % a))
        return 0;
    while (!(s &amp;amp; 1))
    {
        s &amp;gt;&amp;gt;= 1;
        r++;
    }
    int64_t k = quick_pow(a, s, n);
    if (k == 1)
        return 1;
    for (int j = 0; j &amp;lt; r; j++, k = mul(k, k, n))
        if (k == n - 1)
            return 1;
    return 0;
}

int is_prime(int64_t n)
{
    int test_large[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23 };
    int test_small[] = { 2, 7, 61 };
    int test_size = 9, *test = test_large;
    if (n &amp;lt; 2)
        return 0;
    if (n &amp;lt; 4759123141)
    {
        test = test_small;
        test_size = 3;
    }
    for (int i = 0; i &amp;lt; test_size; ++i)
    {
        if (n == test[i])
            return 1;
        if (miller_rabbin(n, test[i]) == 0)
            return 0;
    }
    return 1;
}

int64_t pollard_rho(int64_t n, int c)
{
    int64_t x = rand() % (n - 1) + 1, y;
    y = x = (mul(x, x, n) + c) % n;
    for (int n_try = 3, i = 0; n_try; )
    {
        x = (mul(x, x, n) + c) % n;
        if (y == x)
        {
            --n_try;
            c = rand() % (n - 1) + 1;
            continue;
        }
        int64_t d = gcd((y - x + n) % n, n);
        if (d != 1 &amp;amp;&amp;amp; d != n)
            return d;
        if (++i == 2)
        {
            y = (mul(y, y, n) + c) % n;
            i = 0;
        }
    }
    return n;
}

int main(void)
{
    int64_t n;
    std::cout &amp;lt;&amp;lt; &amp;quot;质数计算器，请输入任意小于1e18的正整数&amp;quot; &amp;lt;&amp;lt; std::endl;
    while (std::cin &amp;gt;&amp;gt; n)
    {
        if (is_prime(n))
        {
            std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot;是质数&amp;quot; &amp;lt;&amp;lt; std::endl;
        }
        else if (n &amp;gt; 2)
        {
            int64_t p = pollard_rho(n, rand() % (n - 1) + 1);
            std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot;不是质数，能被&amp;quot; &amp;lt;&amp;lt; p &amp;lt;&amp;lt; &amp;quot;整除&amp;quot; &amp;lt;&amp;lt; std::endl;
        }
        else
        {
            std::cout &amp;lt;&amp;lt; &amp;quot;请输入大于1小于1e18的整数&amp;quot; &amp;lt;&amp;lt; std::endl;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下为python版本实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random

def _try_composite(a, d, n, s):
    if pow(a, d, n) == 1:
        return False
    for i in range(s):
        if pow(a, 2**i * d, n) == n-1:
            return False
    return True

def _is_prime(n):
    if n in _known_primes:
        return True
    if n &amp;lt; 2 or any((n % p) == 0 for p in _known_primes):
        return False
    return True

def is_prime(n, _precision_for_huge_n = 32):
    if n in _known_primes:
        return True
    d, s = n - 1, 0
    while not d % 2:
        d, s = d &amp;gt;&amp;gt; 1, s + 1
    if n &amp;lt; 4759123141: 
        return not any(_try_composite(a, d, n, s) for a in (2, 7, 61))
    if n &amp;lt; 1122004669633: 
        return not any(_try_composite(a, d, n, s) for a in (2, 13, 23, 1662803))
    if n &amp;lt; 3317044064679887385961981: 
        return not any(_try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41))
    return not any(_try_composite(a, d, n, s) 
                   for a in _test_primes[:_precision_for_huge_n])
 
_known_primes = [2, 3]
_known_primes += [x for x in range(5, 1000, 2) if _is_prime(x)]
_test_primes = [2,3,307] + _known_primes[2:]

def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a%b)

def pollard_rho(n):
    x, c, 0 = random.randint(1, n - 1), random.randint(1, n - 1), 0
    y = x = (pow(x, 2, n) + c) % n
    for n_try in range(3):
        while True:
            x = (pow(x, 2, n) + c) % n
            if x == y:
                c = random.randint(1, n - 1)
                break
            d = gcd(y - x + n, n)
            if d &amp;gt; 1 and d &amp;lt; n:
                return d
            a += 1
            if a == 2:
                y = (pow(y, 2, n) + c) % n
                a = 0
    return n

number = 3451973391686190983
for i in range(number, number + 100, 2):
    if is_prime(i):
        print(i)
        break

if is_prime(number):
    print(number, &amp;quot;prime number&amp;quot;)
else:
    a = pollard_rho(number)
    print(number, &amp;quot;=&amp;quot;, a, &amp;quot;*&amp;quot;, number // a)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>二进制技巧</title>
      <link>/post/20191012-binary-skill/</link>
      <pubDate>Sat, 12 Oct 2019 15:18:00 +0800</pubDate>
      <guid>/post/20191012-binary-skill/</guid>
      <description>&lt;p&gt;二进制位运算的技巧特别多，这里就做一份cheat sheet，希望能帮助到大家。不过过于简单的就不列举了&lt;/p&gt;

&lt;h2 id=&#34;单行表达式&#34;&gt;单行表达式&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;把右边连续的1变成0&lt;/td&gt;
&lt;td&gt;n &amp;amp; ( n + 1 )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;把右边第一个1变成0&lt;/td&gt;
&lt;td&gt;n &amp;amp; ( n - 1 )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;把右起第一个0变成1&lt;/td&gt;
&lt;td&gt;n | ( n + 1 )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;把右起连续的0变成1&lt;/td&gt;
&lt;td&gt;n | ( n - 1 )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;取右边连续的1&lt;/td&gt;
&lt;td&gt;n ^ ( n + 1 )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;去掉右起第一个1的左边&lt;/td&gt;
&lt;td&gt;n &amp;amp; -n 或 n &amp;amp; ( n ^ ( n - 1 ) )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;高低位交换，前x位&lt;/td&gt;
&lt;td&gt;( n &amp;lt;&amp;lt; x ) | ( x &amp;gt;&amp;gt; ( 32 - x ) )&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;有符号整数计算绝对值&lt;/td&gt;
&lt;td&gt;( n ^ (n &amp;gt;&amp;gt; 31) ) - (n &amp;gt;&amp;gt; 31)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;多行的技巧&#34;&gt;多行的技巧&lt;/h2&gt;

&lt;h3 id=&#34;1-两数交换不使用第三个变量&#34;&gt;1. 两数交换不使用第三个变量&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void swap(int* a, int* b)
{
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-奇偶校验码&#34;&gt;2. 奇偶校验码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int check_bit(int n)
{
    n ^= n &amp;gt;&amp;gt; 1;
    n ^= n &amp;gt;&amp;gt; 2;
    n ^= n &amp;gt;&amp;gt; 4;
    n ^= n &amp;gt;&amp;gt; 8;
    n ^= n &amp;gt;&amp;gt; 16;
    return n &amp;amp; 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-计算二进制中的1的个数-popcount&#34;&gt;3. 计算二进制中的1的个数(popcount)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;uint32_t method_1_uint32_popcount(uint32_t n)
{
	n = (n &amp;amp; 0x55555555) + ((n &amp;gt;&amp;gt; 1) &amp;amp; 0x55555555);
	n = (n &amp;amp; 0x33333333) + ((n &amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
	n = (n &amp;amp; 0x0f0f0f0f) + ((n &amp;gt;&amp;gt; 4) &amp;amp; 0x0f0f0f0f);
	n = (n &amp;amp; 0x00ff00ff) + ((n &amp;gt;&amp;gt; 8) &amp;amp; 0x00ff00ff);
	n = (n &amp;amp; 0x0000ffff) + ((n &amp;gt;&amp;gt; 16) &amp;amp; 0x0000ffff);
	return n;
}

uint32_t method_2_uint32_popcount(uint32_t n)
{
	n = n - ((n &amp;gt;&amp;gt; 1) &amp;amp; 0x55555555);
	n = (n &amp;amp; 0x33333333) + ((n &amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
	n = (n + (n &amp;gt;&amp;gt; 4)) &amp;amp; 0x0f0f0f0f;
	n = n + (n &amp;gt;&amp;gt; 8);
	n = n + (n &amp;gt;&amp;gt; 16);
	return n &amp;amp; 0x3f;
}

uint32_t method_3_uint32_popcount(uint32_t n)
{
	n = n - ((n&amp;gt;&amp;gt;1) &amp;amp; 0x55555555);
	n = (n &amp;amp; 0x33333333) + ((n &amp;gt;&amp;gt; 2) &amp;amp; 0x33333333);
	return ((n + (n &amp;gt;&amp;gt; 4) &amp;amp; 0xF0F0F0F) * 0x1010101) &amp;gt;&amp;gt; 24;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-计算下一组合&#34;&gt;4. 计算下一组合&lt;/h3&gt;

&lt;p&gt;前提：我们使用一个整数的二进制位来代表对应集合上的元素有没有选中，从而来表达一个组合。当我们要遍历所有组合的时候，就可以用这个办法了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int next_combination(int k)
{
    int b = k &amp;amp; -k, t = (k + b);
    return (((t ^ k) &amp;gt;&amp;gt; 2) / b) | t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-n皇后问题位运算实现&#34;&gt;5. n皇后问题位运算实现&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;uint64_t queen(uint32_t row, uint32_t lb, uint32_t rb)
{
    if (row == 0)
        return 1;
    uint64_t sum = 0;
    for (uint32_t r = row; r; r &amp;amp;= r - 1)
    {
        uint32_t p = r ^ (r &amp;amp; (r - 1));
        if ((p &amp;amp; lb) == 0 &amp;amp;&amp;amp; (p &amp;amp; rb) == 0)
            sum += queen(row ^ p, (lb | p) &amp;lt;&amp;lt; 1, (rb | p) &amp;gt;&amp;gt; 1);
    }
    return sum;
}

uint64_t nqueen(int n) // 返回值为棋盘大小n时解的个数
{
    return queen(((uint32_t)1 &amp;lt;&amp;lt; n) - 1, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-古老的快速平方根倒数&#34;&gt;6. 古老的快速平方根倒数&lt;/h3&gt;

&lt;p&gt;求 &lt;code&gt;1/sqrt(n)&lt;/code&gt;，这段代码出自Quake-III Arena (雷神之锤3)源代码 &lt;code&gt;/game/code/q_math.c&lt;/code&gt;，针对 IEEE 754 标准的单精度浮点格式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;float Q_rsqrt( float number )
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * ( long * ) &amp;amp;y;                       // evil floating point bit level hacking
    i  = 0x5f3759df - ( i &amp;gt;&amp;gt; 1 );               // what the fuck?
    y  = * ( float * ) &amp;amp;i;
    y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed

#ifndef Q3_VM
#ifdef __linux__
    assert( !isnan(y) ); // bk010122 - FPE?
#endif
#endif
	return y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：使用常数 0x5f375a86 可以使得结果误差更小，详见&lt;a href=&#34;https://en.wikipedia.org/wiki/Fast_inverse_square_root&#34; target=&#34;_blank&#34;&gt;维基百科&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;7-绘画sierpinski三角&#34;&gt;7. 绘画Sierpinski三角&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
    const int n = (1 &amp;lt;&amp;lt; 5);
    for (int i = 0; i &amp;lt; n; ++i)
    {
        for (int j = 0; j &amp;lt;= i; ++j)
           putchar( ( i &amp;amp; j ) == j ? &#39;#&#39; : &#39; &#39;);
        printf(&amp;quot;\n&amp;quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;#
##
# #
####
#   #
##  ##
# # # #
########
#       #
##      ##
# #     # #
####    ####
#   #   #   #
##  ##  ##  ##
# # # # # # # #
################
#               #
##              ##
# #             # #
####            ####
#   #           #   #
##  ##          ##  ##
# # # #         # # # #
########        ########
#       #       #       #
##      ##      ##      ##
# #     # #     # #     # #
####    ####    ####    ####
#   #   #   #   #   #   #   #
##  ##  ##  ##  ##  ##  ##  ##
# # # # # # # # # # # # # # # #
################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Blogroll</title>
      <link>/blogroll/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0800</pubDate>
      <guid>/blogroll/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;AgOH的&lt;a href=&#34;https://space.bilibili.com/120174936/&#34; target=&#34;_blank&#34;&gt;B站空间&lt;/a&gt; 准备开始周更的蒟蒻UP主&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tifa-233.xyz/&#34; target=&#34;_blank&#34;&gt;Tifa’s Blog&lt;/a&gt; 一个数学系 ACMer 的小站，主要记录与数学和算法竞赛相关的内容&lt;/li&gt;
&lt;li&gt;DXTsT的&lt;a href=&#34;https://mrskirt.cc/&#34; target=&#34;_blank&#34;&gt;小裙子&lt;/a&gt;和&lt;a href=&#34;https://fs49.org/&#34; target=&#34;_blank&#34;&gt;裙中世界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://vrmei.52chye.cn/&#34; target=&#34;_blank&#34;&gt;vrmei的博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;//jiangkk.top&#34; target=&#34;_blank&#34;&gt;废江&amp;rsquo;s博客&lt;/a&gt;  备战acm小菜鸟的个人日常&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/burningdzb&#34; target=&#34;_blank&#34;&gt;burningdzb的博客&lt;/a&gt;  白月光__编程小萌新&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>插入排序与希尔排序优化思路</title>
      <link>/post/20191009-sorting-2/</link>
      <pubDate>Thu, 10 Oct 2019 20:52:52 +0800</pubDate>
      <guid>/post/20191009-sorting-2/</guid>
      <description>&lt;p&gt;本篇针对插入排序和希尔排序来讲优化思路，有部分内容因为前一篇文章已经有交代，这里不重复，如果你还没有看，请先看&lt;a href=&#34;../20191008-sorting-1&#34;&gt;前一篇&lt;/a&gt;。我们来看插入排序的动图演示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Insertion_sort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://github.com/heray1990/AlgorithmVisualization/blob/master/images/insertion_sort_50samples_fps30_dpi50.gif?raw=true&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插入排序保证前面一块是有序的情况下，新增的一个元素通过向前交换到合适的位置，所以叫做插入排序。&lt;/p&gt;

&lt;h2 id=&#34;插入排序基本实现&#34;&gt;插入排序基本实现&lt;/h2&gt;

&lt;p&gt;我们先来看插入排序的基本实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void insert_sort(sort_element_t * beg, sort_element_t * end)
{
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        sort_element_t val = *i;
        sort_element_t* j = i;
        for (; j &amp;gt; beg &amp;amp;&amp;amp; val &amp;lt; j[-1]; --j)
        {
            *j = j[-1];
        }
        *j = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入排序即使不做任何优化，效率也明显高于上篇所说的冒泡排序和选择排序。那么按照惯例，先上双向看看效果&lt;/p&gt;

&lt;h3 id=&#34;插入排序优化-双向插入&#34;&gt;插入排序优化，双向插入&lt;/h3&gt;

&lt;p&gt;不过双向版本的插入排序可能并不是你想象中那么好写，甚至于有点不太好懂&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void double_insert_sort(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        for (sort_element_t* i = beg + 1, *j = end - 1; ; )
        {
            sort_element_t val = *i;
            sort_element_t* t = i;
            for (; t &amp;gt; beg &amp;amp;&amp;amp; val &amp;lt; t[-1]; --t)
            {
                *t = t[-1];
            }
            *t = val;

            if (++i &amp;gt; j)
            {
                if (*i &amp;lt; *j)
                    ++j;
                else
                    break;
            }

            val = j[-1];
            t = j;
            for (; t &amp;lt; end &amp;amp;&amp;amp; *t &amp;lt; val; ++t)
            {
                t[-1] = *t;
            }
            t[-1] = val;

            if (i &amp;gt; --j)
            {
                if (*j &amp;lt; j[-1])
                    --i;
                else
                    break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;我们来看看测试结果，在 VS2015 下对 45000 个int排序&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;insert2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;376&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;165&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;174&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;176&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;177&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;114&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;insert&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;359&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;165&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;174&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;177&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;192&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;115&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;575&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1259&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1224&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;532&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;855&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;568&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1252&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1474&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1537&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1611&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;642&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;813&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;733&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1068&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;809&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1076&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1082&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1073&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1072&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1074&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1073&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1065&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;939&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1192&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2190&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2220&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2193&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;832&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1376&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2159&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2174&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2157&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2137&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2166&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2160&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2155&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2149&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2146&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2138&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2154&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个优化效果非常不明显，有种吃力不讨好的感觉。那么，我们换个方法，来试试加大步长吧，这个变动让算法有了另一个名字&lt;/p&gt;

&lt;h2 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h2&gt;

&lt;p&gt;希尔排序的坑特别深，你需要有心理准备。希尔排序和梳排序类似，都是通过使用较大的步长让元素更快速地到达正确位置附近&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Shellsort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过在步长的选择上，希尔排序与梳排序差别巨大。首先梳排序的步长选择较为简单，每次乘以0.8即可，这个数字就不要管怎么来的了，我也不知道。梳排序的研究资料较少，但希尔排序则不一样，步长选择的研究非常多，也就是说光是步长的选择就是一门学问，这就是一个大坑，而且这个步长选择对性能的影响十分明显。我们先来看最早的希尔排序版本，最早的版本使用步长每次乘以0.5。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort_0_5(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        size_t incre = (size_t)(end - beg) / 2;
        for (; incre &amp;gt;= 1; incre /= 2)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后来，Pratt 与 Knuth 改进了新的&lt;a href=&#34;https://oeis.org/A003462&#34; target=&#34;_blank&#34;&gt;步长序列&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;1, 4, 13, 40, 121, ...&lt;/code&gt;&lt;br /&gt;
得到以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        size_t incre = 1;
        while (incre &amp;lt; (size_t)(end - beg - 1) / 3)
            incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973
        for (; incre &amp;gt;= 1; incre /= 3)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多关于步长的研究可以参考&lt;a href=&#34;https://en.wikipedia.org/wiki/Shellsort&#34; target=&#34;_blank&#34;&gt;维基百科&lt;/a&gt;，本篇不对步长做讲解。后文的优化将使用这个版本的代码&lt;/p&gt;

&lt;h3 id=&#34;希尔排序优化-运用带哨兵的插入排序&#34;&gt;希尔排序优化，运用带哨兵的插入排序&lt;/h3&gt;

&lt;p&gt;带哨兵的插入排序是什么东西？其实就是指以下这样的插入排序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void unguarded_insert_sort(sort_element_t * beg, sort_element_t * end)
{
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        sort_element_t val = *i;
        sort_element_t* j = i;
        for (; val &amp;lt; j[-1]; --j)
        {
            *j = j[-1];
        }
        *j = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和前面的插入排序的区别在哪？就是少了&lt;code&gt;j &amp;gt; beg &amp;amp;&amp;amp;&lt;/code&gt;，不做边界判断。不做边界判断确实能运行得更快，但不会越界吗？我们来考虑以下这种情况&lt;br /&gt;
&lt;code&gt;int arr[8] = {-1, 8, 9, 4, 5, 6, 1, 6};&lt;/code&gt;&lt;br /&gt;
然后我们排序的时候写&lt;code&gt;unguarded_insert_sort(arr + 1, arr + 8);&lt;/code&gt;它就能正确排序而且不会发生越界，因为最前面存在比需要排序的元素都要小的数，而那个数就是哨兵，它充当着让内循环退出的作用，也就是说，在调用这个函数的时候，只要保证beg的左边存在比右边都要小的元素就行了。&lt;/p&gt;

&lt;p&gt;有了这个能怎么优化呢？我们把步长1的部分单独拆出来，写成下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort_o1(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        size_t incre = 1;
        while (incre &amp;lt; (size_t)(end - beg - 1) / 3)
            incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973
        for (; incre &amp;gt; 1; incre /= 3)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
        insert_sort(beg, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个能理解吧，步长1的时候完全就是插入排序，但真正厉害的在下面这步，要注意到这种写法在变为步长1之前，它的步长是4，我们可以证明整个数组的最小值一定在前4个数中，即前一个步长的范围内。这里不给出具体证明，有兴趣你可以自己试试证明。有了这个结论，前4个元素用插入排序排好了后，后面的就可以使用&lt;code&gt;unguarded_insert_sort&lt;/code&gt;了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort_o2(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 10)
    {
        size_t incre = 1;
        while (incre &amp;lt; (size_t)(end - beg - 1) / 3)
            incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973
        for (; incre &amp;gt; 1; incre /= 3)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
        insert_sort(beg, beg + 4);
        unguarded_insert_sort(beg + 4, end);
    }
    else
    {
        insert_sort(beg, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个哨兵技巧在其它的排序里面甚至别的问题里同样也会存在。除了这个还有没有别的优化空间呢？例如，shellsort的最优情况下的时间复杂度还是&lt;code&gt;O(nlogn)&lt;/code&gt;，那有没有办法使得最优情况时间复杂度下降到&lt;code&gt;O(n)&lt;/code&gt;呢？确实有办法，如果在某一轮发现没有数进行交换，那么就立即转成带次数限制的插入排序进行尝试，具体请参阅我的&lt;a href=&#34;https://github.com/Baobaobear/sort&#34; target=&#34;_blank&#34;&gt;sort项目&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;测试结果&#34;&gt;测试结果&lt;/h2&gt;

&lt;p&gt;以下是在 VS2015 上对 4,500,000 个int排序的测试&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bao_shell&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;373&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;368&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;148&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;350&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;147&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shell_o2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;68&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;553&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;540&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;187&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;59&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;106&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;216&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shell_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;54&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;563&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;547&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;190&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;67&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;59&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;509&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;222&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shell_0_5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;89&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;606&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;601&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;236&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;82&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;89&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;143&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;572&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;261&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;comb_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;166&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;161&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;180&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;492&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;477&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;214&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;171&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;169&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;223&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;478&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;273&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;code&gt;bao_shell&lt;/code&gt;是我在&lt;a href=&#34;https://github.com/Baobaobear/sort&#34; target=&#34;_blank&#34;&gt;sort项目&lt;/a&gt;中写的希尔排序，使用了更优的步长序列，里面包含更多的优化技巧，本篇就不一一介绍了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>选择和冒泡排序优化思路</title>
      <link>/post/20191008-sorting-1/</link>
      <pubDate>Tue, 08 Oct 2019 13:15:36 +0800</pubDate>
      <guid>/post/20191008-sorting-1/</guid>
      <description>&lt;p&gt;本篇针对两种最基本的排序（冒泡、选择）来讲优化思路。越是简单的东西反而可能存在你越想不到的优化点。但是在开始之前，先给不了解的人讲一个设计原则的问题，我们在设计排序接口的时候，最为常见的有&lt;br /&gt;
&lt;code&gt;void sort(type arr[], int len)&lt;/code&gt;&lt;br /&gt;
也许你也见过&lt;br /&gt;
&lt;code&gt;void sort(iter beg, iter end)&lt;/code&gt;&lt;br /&gt;
这时候问题就来了，很多人会错误地把end认为是最后一个元素，其实不然，这两接口可以相互转换，例如我们可以写 &lt;code&gt;sort(arr, arr + len)&lt;/code&gt; ，这样写很自然对不对，但如果你认为end是最后一个元素，那你就不得不改成 &lt;code&gt;sort(arr, arr + len - 1)&lt;/code&gt; 。事实上，这类的接口我们需要一个统一的原则，就是左闭右开区间原则，即beg就是首个元素，而end是最后一个元素+1，即end是作为结束标志，不应该把end算在范围内。接下来下面所有的接口写法，都是以&lt;br /&gt;
&lt;code&gt;void sort(iter beg, iter end)&lt;/code&gt;&lt;br /&gt;
这种方式写的，至于这样写有什么好处，接下来我们就看示例。&lt;/p&gt;

&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/heray1990/AlgorithmVisualization/master/images/selection_sort_50samples_fps30_dpi50.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本实现&#34;&gt;基本实现&lt;/h3&gt;

&lt;p&gt;我们先来看选择排序，因为它编写简单，而且最不容易出错，我们来看以下两种不同的接口写法，我们定义要排序的数据类型名字是&lt;code&gt;sort_element_t&lt;/code&gt;，定义交换函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void sort_element_swap(sort_element_t *x, sort_element_t *y)
{
    sort_element_t t = *x;
    *x = *y;
    *y = t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void select_sort(sort_element_t arr[], size_t len) //方式1
{
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        size_t head = i;
        for (size_t j = i + 1; j &amp;lt; len; ++j)
        {
            if (arr[j] &amp;lt; arr[head])
                head = j;
        }
        sort_element_swap(arr + i, arr + head);
    }
}

void select_sort(sort_element_t * beg, sort_element_t * end) //方式2
{
    for (; beg &amp;lt; end; ++beg)
    {
        sort_element_t* head = beg;
        for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; *head)
                head = i;
        }
        sort_element_swap(beg, head);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就这么一眼看过去，看起来还真差不多，这样，我们再细分一下，选择排序的中间那步，其实就是找一个最小的元素，我们单独提取成一个独立函数再来看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//方式1
size_t find_min(sort_element_t arr[], size_t beg, size_t len)
{
    size_t head = beg;
    for (size_t j = beg + 1; j &amp;lt; len; ++j)
    {
        if (arr[j] &amp;lt; arr[head])
            head = j;
    }
    return head;
}

void select_sort(sort_element_t arr[], size_t len)
{
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        sort_element_swap(arr + i, arr + find_min(arr, i, len));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//方式2
sort_element_t* find_min(sort_element_t * beg, sort_element_t * end)
{
    sort_element_t* head = beg;
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        if (*i &amp;lt; *head)
            head = i;
    }
    return head;
}

void select_sort(sort_element_t * beg, sort_element_t * end)
{
    for (; beg &amp;lt; end; ++beg)
    {
        sort_element_swap(beg, find_min(beg, end));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细观察一下，是不是第二种写法函数参数统一，而且参数数量少，而且也少了很多不必要的加法运算（像方法一需要写&lt;code&gt;arr + i&lt;/code&gt;这类）。如果你说方法一的find_min参数也可以只写两个，写成&lt;code&gt;find_min(sort_element_t arr[], size_t len)&lt;/code&gt;，那么你在调用的地方将不得不写成&lt;code&gt;find_min(arr + i, len - i)&lt;/code&gt;，这种又加又减在遇到更复杂的情况的时候，更容易把你弄晕出Bug。总之结论是最好把参数写成两个指针（或两个迭代器）的形式，不建议使用数组加长度的形式，STL的接口也全使用迭代器的形式。&lt;/p&gt;

&lt;p&gt;对于这个排序要注意的一点是，有人会写成类似下面的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void select_sort(sort_element_t arr[], size_t len)
{
	for (size_t j = 0; j &amp;lt; len; ++j)
	{
		for (size_t i = j + 1; i &amp;lt; len; ++i)
		{
			if (arr[j] &amp;gt; arr[i])
			{
				sort_element_t t = arr[j];
				arr[j] = arr[i];
				arr[i] = t;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上这种叫做劣化版的选择排序，在大多数的情况下会比前一个方法慢，极端条件下甚至会慢1倍甚至更多&lt;/p&gt;

&lt;p&gt;那说完劣化再讲优化，选择排序的时间复杂度是$O(n^2)$，而且运行时间与原来的排列完全无关。以上的选择排序总是选择小的，那大小一起选呢？能不能起到优化的作用？如果你单纯的多写一个find_max变成双向选择来做，在VS2005下是没有优化效果的，我测试过了。那应该怎么样呢？确实还是双向选择，不过具体实现稍有点不同。&lt;/p&gt;

&lt;h3 id=&#34;优化1-双向选择&#34;&gt;优化1，双向选择&lt;/h3&gt;

&lt;p&gt;这里的实现是一个函数里同时把最大最小一起找，这样减少了一次遍历的过程，时间能减半之余，还有一个非常有用的优化，就是当你发现最大值等于最小值的时候能提前跳出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* find_min_max(
    sort_element_t * beg,
    sort_element_t * end,
    sort_element_t** head_max)
{
    sort_element_t* head = beg;
    *head_max = beg;
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        if (*i &amp;lt; *head)
            head = i;
        else if (**head_max &amp;lt; *i)
            *head_max = i;
    }
    return head;
}

void double_select_sort(sort_element_t * beg, sort_element_t * end)
{
    while (end - beg &amp;gt; 1)
    {
        sort_element_t * head_max, * head = find_min_max(beg, end, &amp;amp;head_max);
        if (head_max != head)
        {
            if (head_max == beg)
                head_max = head;
            sort_element_swap(beg++, head);
            sort_element_swap(--end, head_max);
        }
        else
        {
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与选择排序的运行时间比较如下，排序45000个int，编译环境是VS2015，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;834&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1113&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1141&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;981&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2213&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2227&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2241&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2260&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;合理运用双向，效果也往往不错，但是千万要注意，环境不同会导致测试结果不相同，例如你换到mingw上使用-O3编译那么将会是select比select2快，所以上面数据只供参考，具体结果请自己做测试。&lt;/p&gt;

&lt;h3 id=&#34;优化2-数据结构&#34;&gt;优化2，数据结构&lt;/h3&gt;

&lt;p&gt;选择排序的优化主要是在find_min上面，find_min的时间复杂度是$O(n)$，那如果我们通过一些数据结构的组织，例如二叉堆，那么找最大或最小值时间将变成$O(1)$，而维护这个数据结构的代价是$O(logn)$的话，总体时间复杂度将变为$O(nlogn)$，这比起选择排序的$O(n^2)$就是一个巨大的变化，具体内容在之后的 &lt;a href=&#34;/post/20191015-sorting-3/&#34;&gt;堆排序&lt;/a&gt; 篇具体讲解。&lt;/p&gt;

&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/5/54/Sorting_bubblesort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本实现-1&#34;&gt;基本实现&lt;/h3&gt;

&lt;p&gt;冒泡排序是我们课本必然介绍的一个排序，相对于选择排序，这种在编写的时候更容易出现逻辑错误，我们先来看典型的实现（双迭代器实现）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(sort_element_t * beg, sort_element_t * end)
{
    for (; beg &amp;lt; end; --end)
    {
        for (sort_element_t * i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-1])
                sort_element_swap(i - 1, i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冒泡排序这种写法，铁定的$O(n^2)$时间没跑，不过好在冒泡排序的优化方法也不少。&lt;/p&gt;

&lt;h3 id=&#34;优化1-提前跳出&#34;&gt;优化1，提前跳出&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(sort_element_t * beg, sort_element_t * end)
{
    for (; beg &amp;lt; end; --end)
    {
        int sorted = 1;
        for (sort_element_t * i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (sorted)
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过sorted变量记录某一轮是不是存在交换，如果没有交换则表明数据已经是有序的，可以提前退出循环。有这个优化对于已经有序的数据，冒泡排序将运行得特别快，即最优情况时间复杂度只有$O(n)$&lt;/p&gt;

&lt;h3 id=&#34;优化2-鸡尾酒排序&#34;&gt;优化2，鸡尾酒排序&lt;/h3&gt;

&lt;p&gt;前面的冒泡写法是单向冒泡，把最大值向最右边移，这回我们做成双向，一边把最大值右移，一边把最小值左移，不过这种方法有另一个命名，叫做鸡尾酒排序&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cocktail_shaker_sort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void cocktail_sort(sort_element_t * beg, sort_element_t * end)
{
    while (beg &amp;lt; end)
    {
        int sorted = 1;
        for (sort_element_t * i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (sorted)
            break;
        --end;

        sorted = 1;
        for (sort_element_t * i = end - 1; i &amp;gt; beg; --i)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (sorted)
            break;
        ++beg;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那改成双向就真的有提升了吗？我们看实测，排序45000个int，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1313&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1502&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1614&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1674&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;836&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;761&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2286&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2329&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2332&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;871&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1459&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1052&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中第4组是乱序无重复数值的数据，最有代表性的一列。从中可以看到，cocktail比起bubble能节省30%的时间&lt;/p&gt;

&lt;p&gt;让我们再脑洞大开，除了可以双向，还有一种对CPU执行有利的优化方式&lt;/p&gt;

&lt;h3 id=&#34;优化3-奇偶排序&#34;&gt;优化3，奇偶排序&lt;/h3&gt;

&lt;p&gt;这种排序的排序方式见下表，假设有8个数，奇数轮比较(1,2), (3,4), (5,6), (7,8)，偶数轮比较(2,3), (4,5), (6,7)，如此循环，直到没有交换为止&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;轮次&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;具体实现代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void odd_even_sort(sort_element_t * beg, sort_element_t * end)
{
    int sorted = 0, last_sorted = 0;
    while (sorted == 0)
    {
        last_sorted = sorted;
        sorted = 1;
        for (sort_element_t * i = beg + 1; i &amp;lt; end; i += 2)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (last_sorted &amp;amp;&amp;amp; sorted)
            break;

        last_sorted = sorted;
        sorted = 1;
        for (sort_element_t * i = beg + 2; i &amp;lt; end; i += 2)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (last_sorted &amp;amp;&amp;amp; sorted)
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们再脑洞大开，除了比较方向，好像我们有一个条件没有考虑上，就是冒泡排序总是相邻元素的比较，那么如果不相邻地比较呢？&lt;/p&gt;

&lt;h3 id=&#34;优化4-梳排序&#34;&gt;优化4，梳排序&lt;/h3&gt;

&lt;p&gt;通过一开始设置较大的步长，让元素能较快移动，然后逐步减少步长，直到1变成普通的冒泡排序为止。这个方法的优点，就是快，相对前面的方法来说飞快。当然，最后一步你也可以选择不调用冒泡排序，而改调用&lt;code&gt;cocktail_sort&lt;/code&gt;或&lt;code&gt;odd_even_sort&lt;/code&gt;都可以，差别不明显。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Comb_sort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/46/Comb_sort_demo.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void comb_sort(sort_element_t * beg, sort_element_t * end)
{
    const double shrink_factor = 0.8;
    ptrdiff_t gap = end - beg;
    while (gap &amp;gt; 1)
    {
        if (gap &amp;gt; 1)
        {
            gap = (ptrdiff_t)(gap * shrink_factor);
            if (gap == 10 || gap == 9)
                gap = 11;
        }
        for (sort_element_t * i = beg + gap; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-gap])
                sort_element_swap(i, i - gap);
        }
    }
    bubble_sort(beg, end);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完整测试&#34;&gt;完整测试&lt;/h2&gt;

&lt;p&gt;在完整测试里你会发现一些和你想象中完全不一样的情况，可不要以为你的“优化”一定就是优化&lt;/p&gt;

&lt;h3 id=&#34;vs2005下的运行时间比较-按avg平均值排序&#34;&gt;VS2005下的运行时间比较（按Avg平均值排序）&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;combsort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;574&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1315&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1315&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1222&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;557&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;878&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;586&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1313&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1502&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1614&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1674&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;836&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;761&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;834&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1113&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1141&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;981&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2286&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2329&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2332&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;871&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1459&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1052&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2213&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2227&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2241&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2260&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果你只测试随机数据，那么排序应该是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;combsort &amp;lt;&amp;lt; select2 &amp;lt; odd_even &amp;lt; cocktail &amp;lt; select &amp;lt; bubble&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;在mingw64-gcc8-下使用-o3-编译-最大优化-的运行时间比较&#34;&gt;在mingw64(gcc8)下使用&lt;code&gt;-O3&lt;/code&gt;编译（最大优化）的运行时间比较&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;combsort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;497&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;497&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;434&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;501&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;501&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;501&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;503&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;502&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;493&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;564&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1311&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1264&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1217&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;562&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;882&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;580&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1515&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1610&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1677&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;669&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;837&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;755&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;837&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1112&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1113&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1112&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;974&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1247&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2312&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2332&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2338&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;951&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1455&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1063&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;你可以发现，找最小值过程在mingw64下被特别照顾了一下，结果它比其它的明显要快，你可以从中得知，如果你想在mingw下写出运行得快的双向选择排序，如果你的想法是再写一个&lt;code&gt;find_max&lt;/code&gt;函数，那对不起，这样是没有优化效果的。但这不是全部，还有让你更大跌眼镜的情况。&lt;/p&gt;

&lt;h3 id=&#34;在mingw64-gcc8-下使用-o1-编译-基本优化-的运行时间比较&#34;&gt;在mingw64(gcc8)下使用&lt;code&gt;-O1&lt;/code&gt;编译（基本优化）的运行时间比较&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;combsort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;263&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;375&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;260&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;258&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;255&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;254&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;531&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;255&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;270&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;597&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1287&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1204&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1368&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;780&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;649&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1244&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1504&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1594&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1656&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1081&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;815&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;789&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1241&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2091&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2117&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2115&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;685&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1247&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;949&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2233&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2233&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2232&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2231&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2232&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2224&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2232&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2230&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在双向选择不但最快，而且还比&lt;code&gt;-O3&lt;/code&gt;下的快得多。老实说，会造成这种奇怪的结果，&lt;code&gt;-O1&lt;/code&gt;比&lt;code&gt;-O3&lt;/code&gt;还快的原因还真不要问我，找开发gcc/mingw的开发者。&lt;/p&gt;

&lt;p&gt;最后还是忠告一句，千万不要在一个编译器某个编译参数上看到有优化效果，就以为是事实，优化的坑远比你想象的要来得深，并不是你以为优化了它就一定变快了，编译器和编译参数以及运行环境才是你的老大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Quick sort(快速排序)杂谈 1</title>
      <link>/post/20191007-qsort-talk-1/</link>
      <pubDate>Mon, 07 Oct 2019 14:18:22 +0800</pubDate>
      <guid>/post/20191007-qsort-talk-1/</guid>
      <description>&lt;p&gt;我们现在使用的排序，很大比例在使用quick sort，因为它是平均速度最快的排序，但与此同时它可能也是坑最深的排序，现在我们就来讨论讨论它，因为内容较多，我计划写多篇，本篇是第一篇。&lt;/p&gt;

&lt;h2 id=&#34;快排的思路&#34;&gt;快排的思路&lt;/h2&gt;

&lt;p&gt;我们先来介绍一下快排的思路。快排的思路其实很简单，在数组中选一个元素，我们就称呼这个元素为pivot，通过与这个元素的比较，把数组划分成不比pivot大的在一边，不比pivot小的在另一边，于是就分成了两个更小的数据，对它们分别再排序就行了。但是，这个描述特别的含糊，首先是怎么选中间元素，这里面有很多不同的做法。然后就是划分了，这个划分方法非常的多，水也特别深，这里主要介绍最为常见的划分方法。&lt;/p&gt;

&lt;h2 id=&#34;划分结果分类&#34;&gt;划分结果分类&lt;/h2&gt;

&lt;p&gt;首先，就是划分的结果，划分的结果有什么好讲的呢？其实算法的描述只说了划分成不比pivot大的在一边，不比pivot小的在另一边，并没有说等于的数怎么办。事实上，关键就在等于的数怎么处理，你既可以划在其中一边，也可以两边都有，也可以划成3分，中间那块就是等于pivot的，左边是小于等于，右边是大于等于，三种划分结果都是可以的。但是，不能容许的一种情况是划分后只有一块，例如你选的pivot正好是最小的数，于是划分后，整个数组就一块，全是大于等于pivot的，这样很可能导致无限递归，这次划分也白干了。&lt;/p&gt;

&lt;p&gt;所以很多人单凭算法思路来实现的时候，往往陷入栈溢出异常，其实就是划分结果上出了问题，并没有保证每次划分后，至少划分成两块。&lt;/p&gt;

&lt;h2 id=&#34;划分手段分类&#34;&gt;划分手段分类&lt;/h2&gt;

&lt;p&gt;划分手段的典型方法至少有5种，本篇介绍其中的4种&lt;/p&gt;

&lt;h3 id=&#34;1-lomuto-partition-scheme&#34;&gt;1. Lomuto partition scheme&lt;/h3&gt;

&lt;p&gt;首先我们来看以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t * partition(
    sort_element_t * beg,
    sort_element_t * end)
{
    sort_element_t pivot = *beg;
    sort_element_t * p = beg;
    for (sort_element_t * i = beg + 1; i &amp;lt; end; i++)
    {
        if (*i &amp;lt; pivot)
        {
            sort_element_swap(++p, i);
        }
    }
    sort_element_swap(p, beg);
    return p;
}

void quick_sort_recursive(
    sort_element_t * beg,
    sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        sort_element_t * p = partition(beg, end);
        quick_sort_recursive(beg, p);
        quick_sort_recursive(p + 1, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种划分方法wiki上有描述，叫做 &lt;a href=&#34;https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Lomuto partition scheme&lt;/code&gt;&lt;/a&gt; 它的思路挺好理解，首先p就是划分边界，一开始&lt;code&gt;p = left&lt;/code&gt;，遍历数组，发现比pivot小的，就交换到p的位置，并且p++，那么p左边的就全是比p要小的。而在最后面，把pivot交换到p的位置，所以这个方法期望把数组划分成三块，小于pivot的，等于pivot的，大于等于pivot的，而且能保证至少划分出两块（中间那块等于pivot的一定存在，不过只有一个元素）。这个方法的优点是可以通过简单的修改就变成3路划分（小于、等于、大于三块），缺点是它这种划分方法速度最慢，交换次数较多。&lt;/p&gt;

&lt;h3 id=&#34;2-不知名字的方法&#34;&gt;2. 不知名字的方法&lt;/h3&gt;

&lt;p&gt;这种方法来源不明，如果你知道请告诉我，在我看来有点像 Hoare partition scheme 的变种，来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* partition(
    sort_element_t * first,
    sort_element_t * last)
{
    sort_element_t pivot = *first;
    while (first &amp;lt; last)
    {
        while (first &amp;lt; last &amp;amp;&amp;amp; pivot &amp;lt; *last)
            last--;
        *first = *last;
        while (first &amp;lt; last &amp;amp;&amp;amp; pivot &amp;gt;= *first)
            first++;
        *last = *first;
    }
    *first = pivot;
    return first;
}

void quick_sort_recursive(
    sort_element_t * beg,
    sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        sort_element_t* p = partition(beg, end - 1);
        quick_sort_recursive(beg, p);
        quick_sort_recursive(p + 1, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法通过在右边寻找应该放在左边的元素，与pivot交换，然后在左边寻找应该放在右边的元素，再次与pivot交换，这样pivot通过多数交换换到划分位置上。不过上面代码做了一个简单优化，通过赋值而不是直接交换以减少赋值的次数，这种方法在网上非常常见。&lt;/p&gt;

&lt;h3 id=&#34;3-hoare-partition-scheme&#34;&gt;3. Hoare partition scheme&lt;/h3&gt;

&lt;p&gt;后来有个叫做 C.A.R. Hoare 的人发明了这种划分方法，见代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* partition(
    sort_element_t * first,
    sort_element_t * last)
{
    sort_element_t * begin = first;
    sort_element_t pivot = *first;
    while (first &amp;lt; last)
    {
        while (first &amp;lt; last &amp;amp;&amp;amp; *last &amp;gt;= pivot)
            --last;
        while (first &amp;lt; last &amp;amp;&amp;amp; pivot &amp;gt;= *first)
            ++first;
        if (first &amp;lt; last)
            sort_element_swap(first, last);
    }
    sort_element_swap(first, begin);
    return first;
}

void quick_sort_recursive(
    sort_element_t * beg,
    sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        sort_element_t* p = partition(beg, end - 1);
        quick_sort_recursive(beg, p);
        quick_sort_recursive(p + 1, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意的是，这个写法和 &lt;a href=&#34;https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme&#34; target=&#34;_blank&#34;&gt;wiki&lt;/a&gt; 上的略有差别。这个方法与前一个的不同点是，通过在左边寻找应该放在右边的元素，而在右边寻找应该放在左边的元素，然后交换。这个方法是以上三种里面速度最快的，但与此同时是坑最多的。例如，原描述是左边找小于，右边找大于的交换，而上面代码的实现是左边找小于等于，右边找大于等于；原描述是先找左边再找右边，上面实现是先找右边再找左边。也就是说，取不取等于号有4种组合，再乘以先左或先右两种，共8种组合，这8种有一些要求pivot取最左边，有一些要求pivot取最右边，有些左右都行，有些pivot任意位置都行。所以当你写这种划分方法的时候，看起来没什么区别的代码，偏偏出现栈溢出各种问题，其实就隐藏在这些细节上。如果你想练习调试的本领，就把这8种组合的划分全写出来，你肯定收获不少。至于哪种组合最佳，我不知道，但我知道最差的组合，就是两边都取等于号的那两种。&lt;/p&gt;

&lt;p&gt;这个写法还有一个四路划分的变种，即先划分成以下这样&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;=&lt;/td&gt;
        &lt;td&gt;&lt;&lt;/td&gt;
        &lt;td&gt;&gt;&lt;/td&gt;
        &lt;td&gt;=&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;划分好后再把两端的相等元素交换到中间得到&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;&lt;/td&gt;
        &lt;td&gt;=&lt;/td&gt;
        &lt;td&gt;&gt;&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;这里不具体展开，有兴趣可以自行实现&lt;/p&gt;

&lt;h3 id=&#34;4-vs-partition-scheme&#34;&gt;4. VS partition scheme&lt;/h3&gt;

&lt;p&gt;之所以这么叫是因为我目前只看到在Visual Studio系列STL的&lt;code&gt;std::sort&lt;/code&gt;是这么写的，这个写成代码有点长，但思路和上面说的四路划分有点类似，这里简单讲讲它的思路。首先pivot选择在中间，形成这样的状态&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;&lt;/td&gt;
        &lt;td&gt;?&lt;/td&gt;
        &lt;td&gt;=&lt;/td&gt;
        &lt;td&gt;?&lt;/td&gt;
        &lt;td&gt;&gt;&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;找到等于的元素就交换到等于那块的旁边扩大它就行了，核心思想就这样，还有很多其它的细节，这里不展开。这种方法网上几乎没有人这么写，因为写起来确实挺麻烦的。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;本篇先介绍到这里，大家写快排练习建议使用 &lt;code&gt;Hoare partition scheme&lt;/code&gt; ，如果你觉得你的能力更好，那你可以写 &lt;code&gt;VS partition scheme&lt;/code&gt; 自己琢磨一下细节问题，相信你是能写出来的。那么下一篇会介绍优化的部分。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mingw 的 Bug</title>
      <link>/post/20191006-mingw-bug/</link>
      <pubDate>Sun, 06 Oct 2019 13:04:08 +0800</pubDate>
      <guid>/post/20191006-mingw-bug/</guid>
      <description>&lt;p&gt;这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。&lt;/p&gt;

&lt;p&gt;一开始我使用&lt;code&gt;std::random_shuffle&lt;/code&gt;打乱数组并用&lt;code&gt;std::sort&lt;/code&gt;排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是&lt;code&gt;std::sort&lt;/code&gt;对这种方式打乱的数据排序有点问题导致变慢。&lt;/p&gt;

&lt;p&gt;后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，&lt;code&gt;std::sort&lt;/code&gt;的时间是完全正常的，非得&lt;code&gt;std::random_shuffle&lt;/code&gt;才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向&lt;code&gt;std::random_shuffle&lt;/code&gt;，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是&lt;code&gt;arr[i] = i&lt;/code&gt;，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在&lt;a href=&#34;https://en.cppreference.com/w/cpp/algorithm/random_shuffle&#34; target=&#34;_blank&#34;&gt;cppreference&lt;/a&gt;下源代码长下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; class RandomIt &amp;gt;
void random_shuffle( RandomIt first, RandomIt last )
{
    typename std::iterator_traits&amp;lt;RandomIt&amp;gt;::difference_type i, n;
    n = last - first;
    for (i = n-1; i &amp;gt; 0; --i) {
        using std::swap;
        swap(first[i], first[std::rand() % (i+1)]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码我看着就不对，这个是生成不了我的执行结果的，于是又找到了下面这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator&amp;gt;
inline void random_shuffle(RandomAccessIterator first,
                           RandomAccessIterator last) {
  __random_shuffle(first, last, distance_type(first));
}
 
 
template &amp;lt;class RandomAccessIterator, class RandomNumberGenerator&amp;gt;
void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                    RandomNumberGenerator&amp;amp; rand) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i)
    iter_swap(i, first + rand((i - first) + 1));
}
 
 
template &amp;lt;class RandomAccessIterator, class Distance&amp;gt;
void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                      Distance*) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i) 
#ifdef __STL_NO_DRAND48
    iter_swap(i, first + Distance(rand() % ((i - first) + 1)));
#else
  iter_swap(i, first + Distance(lrand48() % ((i - first) + 1)));
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了这个代码，我瞬间明白这到底是怎么回事了，你能从中发现些什么吗？&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我发现的是，前面的代码用的是rand，而之前我发现的，是数组里前32768个数都特别大，我的直觉是这个rand函数最大值就是32767从而导致以上问题，结果一查，还真的只有mingw的rand函数的最大值这么小，也就是说如果你希望代码跨平台，使用&lt;code&gt;std::random_shuffle&lt;/code&gt;要慎重，当然最好是减少依赖。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>博客第一文，附hugo表格的坑</title>
      <link>/post/20191005-first-post/</link>
      <pubDate>Sat, 05 Oct 2019 23:12:10 +0800</pubDate>
      <guid>/post/20191005-first-post/</guid>
      <description>&lt;p&gt;第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把&lt;code&gt;\n&lt;/code&gt;自动换成&lt;code&gt;\r\n&lt;/code&gt;从而导致主题应用失败，服了。&lt;/p&gt;

&lt;p&gt;另一个坑就是hugo的表格，你不能像以下这么写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a|b|c
-|-|-
1|2|3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a  | b | c
---|---|---
1  | 2 | 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果就是这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;区别是什么呢？在表格的第二行是&lt;code&gt;---|---|---&lt;/code&gt;，这一行是用来描述对齐方式的，不过hugo的引擎要求每列至少3个字符，所以刚好3个字符时只能是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
:--
--:
:-:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中四选一，任何一个只剩下两个字符就不算是表格。&lt;/p&gt;

&lt;p&gt;本博客计划是发布我的研究成果，当然主要是算法方面，而且主要是网上不会轻易搜索到的东西。&lt;/p&gt;

&lt;p&gt;更多的东西可以关注我的 Github &lt;a href=&#34;https://github.com/Baobaobear&#34; target=&#34;_blank&#34;&gt;账号&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _CRT_SECURE_NO_WARNINGS
#include &amp;lt;stdio.h&amp;gt;
 
int g_eof;
int get_lv(char c) {
	return !(c == &#39;+&#39; || c == &#39;-&#39;);
}
 
double get_val(double v[], char op) {
	if (op == &#39;+&#39;) return v[0] + v[1];
	if (op == &#39;-&#39;) return v[0] - v[1];
	if (op == &#39;*&#39;) return v[0] * v[1];
	if (op == &#39;/&#39;) return v[0] / v[1];
	return v[0];
}
 
double calc(char* op, int level, double val, char o, int i) {
	char c[2] = { o };
	double v[2] = { val };
	if ((g_eof = scanf(&amp;quot;%lf&amp;quot;, &amp;amp;v[i])) != EOF)
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	if (c[i] == &#39;(&#39;) {
		v[i] = calc(&amp;amp;c[i], 0, 0, 0, 0);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	}
	if (i &amp;gt; 0) {
		if (!(c[i] == &#39;\n&#39; || c[i] == &#39;)&#39;
			|| get_lv(c[0]) &amp;gt;= get_lv(c[1])))
			v[i] = calc(&amp;amp;c[1], get_lv(c[1]), v[1], c[1], get_lv(c[1]) &amp;gt; 0);
		v[0] = get_val(v, c[0]);
		c[0] = c[1];
	}
	if (c[0] == &#39;\n&#39; || c[0] == &#39;)&#39; || get_lv(c[0]) &amp;lt; level) {
		*op = c[0];
		return v[0];
	}
	return calc(op, level, v[0], c[0], 1);
}
 
int main(void) {
	char op;
	while (g_eof != EOF)
		printf(&amp;quot;= %.15g\n&amp;quot;, calc(&amp;amp;op, 0, 0, &#39;\n&#39;, 0));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
