<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>大整数 | Baobaobear</title>
    <link>/tags/%E5%A4%A7%E6%95%B4%E6%95%B0/</link>
      <atom:link href="/tags/%E5%A4%A7%E6%95%B4%E6%95%B0/index.xml" rel="self" type="application/rss+xml" />
    <description>大整数</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 20 Mar 2021 00:00:00 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>大整数</title>
      <link>/tags/%E5%A4%A7%E6%95%B4%E6%95%B0/</link>
    </image>
    
    <item>
      <title>大整数高精度计算3——快速傅里叶/数论变换及分治除法</title>
      <link>/post/20210320-bigint3/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210320-bigint3/</guid>
      <description>&lt;p&gt;在上一篇介绍了基础优化算法后，本篇介绍更复杂的内容。本篇的三大内容：FFT，NTT，分治除法。中文资料中我尚未发现有博客文章在介绍分治除法的，所以我就来写&lt;del&gt;第一个&lt;/del&gt;介绍吧。&lt;/p&gt;

&lt;h2 id=&#34;fft-schönhage-strassen-algorithm&#34;&gt;FFT (Schönhage–Strassen algorithm)&lt;/h2&gt;

&lt;p&gt;FFT就是快速傅里叶变换的缩写，FFT这里不重点介绍，参见&lt;a href=&#34;https://oi-wiki.org/math/poly/fft/&#34; target=&#34;_blank&#34;&gt;oiwiki中对FFT的介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用比较显浅且简要的方式来介绍的话，FFT可以在$O(nlogn)$时间里（注：严格来说应该是$O(nlognloglogn)$，&lt;a href=&#34;https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/The%20Design%20and%20Analysis%20of%20Computer%20Algorithms%20%5BAho%2C%20Hopcroft%20%26%20Ullman%201974-01-11%5D.pdf&#34; target=&#34;_blank&#34;&gt;论文链接在这&lt;/a&gt;，在274页7.8处开始证明）求出两个多项式的乘积，而大整数乘法就可以视为两个整数系数的多项式的积再处理进位即可。那这样就产生一个问题，如果这个大整数采用的基数base，且长度为n，那么多项式的积的最大值可能会达到$n(base-1)^2$，因为FFT采用浮点运算，那么这个最大值必须在double的精度内，所以如果采用万进制，那么很容易导致精度不足进而结果错误，另外，还有求单位复根时的误差也会让它提早出现结果错误。实际应用的时候，一般采用10进制来增加长度的上限。所以如果你的大整数采用压位表示，那么在运用FFT之前，要先做拆位拆成10进制。总之，因为浮点精度的问题，不建议在大整数实现里使用FFT，建议采用下文要介绍的NTT来代替。所以这里对FFT的优化不做介绍，重心放在NTT上。&lt;/p&gt;

&lt;h2 id=&#34;ntt&#34;&gt;NTT&lt;/h2&gt;

&lt;p&gt;NTT就是快速数论变换，它和FFT很像，但它在整数域上做变换，具体数学介绍参见&lt;a href=&#34;https://oi-wiki.org/math/poly/ntt/&#34; target=&#34;_blank&#34;&gt;oiwiki中对NTT的介绍&lt;/a&gt;。由于没有浮点数参与，于是没有精度上的问题。&lt;/p&gt;

&lt;p&gt;NTT里面有两个重要的数，一个是原根g，通常取3，另一个是素数p，通常取1004535809或998244353，之所以取这两个素数是因为3都是它们的原根，此外，这个素数p必须是形如$2^nm+1$，像$1004535809-1=2^{21} \times 479,\ 998244353-1=2^{23} \times 119$，而这个n限制了变换时的最大长度为$2^n$。在NTT变换的结果里，最大值可能会达到$n(base-1)^2$，为了保证这个值没有因为求解过程中被求模变小了，就要限制$n(base-1)^2 &amp;lt; p$，即这个大整数的最大长度n满足$n &amp;lt; \lfloor\dfrac{p}{(base-1)^2}\rfloor$且$n = 2^k$，那么比如说我们取p为998244353，然后用万进制，得到n的最大值是8！？只有8还用什么呢，我们换换，改用10进制，那可以算得n的最大值是$2^{23}=8388608$，这个长度就比较实用了，如果用万进制做拆位，那这个最大长度就是$2^{21}=2097152$，对付数据范围在1e6以内的题目是足够了。&lt;/p&gt;

&lt;p&gt;但是，在实际使用时，要是真出现比这还要长的数怎么办？这个倒不难解决，先用前一篇文章的分治乘法，拆成原来的一半长度，直到满足NTT的使用上限时，再使用NTT即可。&lt;/p&gt;

&lt;p&gt;但以上这还不是本文要讲的重点，以上方法需要做拆位，拆位的常数能优化得更小吗？或者说，如果我坚持要使用万进制的话，NTT还能用吗？重新考虑一开始的限制，那个限制的原因，是最大值可能大于等于p，导致在模运算下失去了原来的值，那么，如果我们使用两个不同的p，最后用中国剩余定理来还原实际值呢，假设这2个素数是p1和p2，分别取1004535809和998244353，这样的话上限就是$p1p2=1002772198720536577$，在这个条件下用万进制的话，长度即使上100亿也不会越界，如果用65536进制的话长度也能达2亿，已经远远超过那个素数p本身带来的限制，完全足够使用了。不过代价是需要多做一次NTT变换，但比起万进制拆位拆成4个来比较，常数还是更小的。而且，即使不拆位，直接用10进制，速度也还是比不过使用双素数万进制。&lt;/p&gt;

&lt;p&gt;方案有了，接下来又有新问题，就是要解这个数论方程$z = xp_1 + c_1 = yp_2 + c_2 \ (x,y,z \in N)$&lt;/p&gt;

&lt;p&gt;直接用中国剩余定理可解，先求出$p_1$在$p_2$下的逆元$i_1$以及$p_2$在$p_1$下的逆元$i_2$，那么$z = (c_1i_1p_1+c_2i_2p_2) \ mod \ p_1p_2$&lt;/p&gt;

&lt;p&gt;注意到，我们的p是在1e9附近，于是就出问题了，$c_1i_1p_1$的结果可能会达到1e27，爆掉了int64，当然如果你选的p比$2^{21}$小，那就不至于溢出，但长度又受限制了，那这时候怎么办？&lt;/p&gt;

&lt;p&gt;有一个办法是模仿快速幂的方式来求乘法的模，但这个方法常数很大，我们要找更好的方案。&lt;/p&gt;

&lt;p&gt;在《算法竞赛进阶指南》里面(page 6)就介绍了这么一段代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int64_t mul_mod(int64_t a, int64_t b, int64_t m) {
    a %= m;
    b %= m;
    int64_t c = (int64_t)((long double)a * b / m);
    int64_t ans = a * b - c * m;
    if (ans &amp;lt; 0)
        ans += m;
    else if (ans &amp;gt;= m)
        ans -= m;
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体原理就不介绍了，但要注意的一点问题是，比如在VS编译器上，&lt;code&gt;long double&lt;/code&gt;等于&lt;code&gt;double&lt;/code&gt;，那么a和b就需要同时小于$2^{53}$，即$n(base-1)^2 &amp;lt; 2^{53}$，否则产生的误差就不是后面一个if能解决得了的，那么比如你用65536进制，那么n的最大值只有$2^{21}=2097152$，这是要注意的点（嗯，没错，这就是我踩过的坑）。&lt;/p&gt;

&lt;p&gt;那再来，有没有办法避免这个问题？经过我一番资料搜索，还真有，那个同余方程还有另一种解法。先回顾一下原方程 $z = xp_1 + c_1 = yp_2 + c_2 \ (x,y,z \in N)$&lt;/p&gt;

&lt;p&gt;我们可以不直接求z，改成求y，那么 $y = (c_1 - c_2)i_2 \ mod \ p_1$&lt;/p&gt;

&lt;p&gt;于是不但完美避开int64的乘法求模，而且计算量更少，现在&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger项目&lt;/a&gt;中的实现就是使用这个方法。&lt;/p&gt;

&lt;p&gt;基本原理介绍完了，以下讲讲细节，在选取NTT的模p的时候，其实网上最常用的两个数1004535809和998244353并不是两个模的时候的最好的选择，通过暴力求解，最佳选择是$469762049=2^{26} \times 7 + 1,\ 167772161=2^{25} \times 5 + 1$，这个组合可以让最大长度达到$2^{25}$。&lt;/p&gt;

&lt;p&gt;不过在这里就不给出用NTT的写法模板了，具体实现细节及常数优化参见项目源代码。以下列举部分关键代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline ntt_base_t mul_mod(int64_t a, int64_t b) {
    return a * b % NTT_MOD;
}
ntt_base_t pow_mod(int64_t a, int64_t b) {
    int64_t ans = 1;
    a %= NTT_MOD;
    while (b) {
        if (b &amp;amp; 1) ans = ans * a % NTT_MOD;
        b &amp;gt;&amp;gt;= 1;
        a = a * a % NTT_MOD;
    }
    return (ntt_base_t)ans;
}
void transform(ntt_base_t a[], size_t len, int on) {
    for (size_t i = 0; i &amp;lt; len; i++) {
        if (i &amp;lt; ntt_r[i]) std::swap(a[i], a[ntt_r[i]]);
    }
    size_t id = 0;
    for (size_t h = 1; h &amp;lt; len; h &amp;lt;&amp;lt;= 1) {
        ntt_base_t wn = ntt_wn[on][++id];
        for (size_t j = 0; j &amp;lt; len; j += h &amp;lt;&amp;lt; 1) {
            ntt_base_t w = 1;
            size_t e = j + h;
            for (size_t k = j; k &amp;lt; e; k++, w = mul_mod(w, wn)) {
                ntt_base_t t = mul_mod(w, a[k + h]);
                a[k + h] = (a[k] - t + NTT_MOD) % NTT_MOD;
                a[k] = (a[k] + t) % NTT_MOD;
            }
        }
    }
    if (on == 0) {
        ntt_base_t inv = pow_mod(len, NTT_MOD - 2);
        for (size_t i = 0; i &amp;lt; len; i++)
            a[i] = mul_mod(a[i], inv);
    }
}
void mul_conv(size_t n) {
    transform(&amp;amp;ntt_a.front(), n, 1);
    transform(&amp;amp;ntt_b.front(), n, 1);
    for (size_t i = 0; i &amp;lt; n; i++)
        ntt_a[i] = mul_mod(ntt_a[i], ntt_b[i]);
    transform(&amp;amp;ntt_a.front(), n, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分治除法&#34;&gt;分治除法&lt;/h2&gt;

&lt;p&gt;没错，大整数除法也能分治，这很多人还不知道这点。并不只有牛顿迭代这一路线。&lt;del&gt;（也许本文是中文博客中第一篇介绍大整数的分治除法）&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;我们假设，相除的两个数表示为$\dfrac{a_1a_2a_3a_4}{b_1b_2}$，其中$a_1,a_2,a_3,a_4,b_1,b_2$看成是一个以$base^n$为基的“1位数字”，即看成是“4位数”除以“2位数”，并且，我们假设$b_1 \geq \dfrac{base^n}2$，接下来，我们就看成是模拟手算的除法，用前3位除以那个2位数，求出的余数便再来一次3位除以2位。而在3位除以2位时，我们需要的便是先试商，试商的方法是取被除数的最高2位除以除数的最高1位。因为我们在前面假设了$b_1 \geq \dfrac{base^n}2$ （这又叫做规则化），Knuth在TAOCP书中证明了在除数规则化后，可以证明这样试商的结果q&amp;rsquo;与实际商q的关系满足$q&amp;rsquo;-2 \leq q \leq q&amp;rsquo;$，所以最多只要对试商结果做2次减法修正便可。再看试商这一步，是“2位数”除以“1位数”，那我们就把原本以$base^n$为基，改为以$base^{n/2}$为基，于是就变成“4位数”除以“2位数”，便可以递归进行了。&lt;/p&gt;

&lt;p&gt;对于实际应用的时候，在使用分治法之前，要做两件事情，首先找出系数m，令除数B乘以m后，最高位的$b_1$尽可能接近且小于base，然后让被除数和除数，均乘以m，再开始做分治。计算完毕后，得到的余数只需要再除以m即可。另外，如果分治过程中出现B的位数是奇数，不能正好除以2时，那也没有关系，直接向下取整，那么多出来的1位就作为精度补充使用。&lt;/p&gt;

&lt;p&gt;再简单复述一篇，对于2n/n，降低base的指数，转为4n/2n，然后就是模拟手算，前3位除以2位，即3n/2n，需要这样除两个回合。而在3n/2n的时候，需要试商，试商时就是2n/n的除法，此步通过递归完成，除得的商修正个位数即可。&lt;/p&gt;

&lt;p&gt;但当然，这个分治法仍然有改进的余地，我的实现可能比较糟糕，是同长度乘法的约2到4倍时间，这个倍数取决于长度，即它的时间复杂度为$O(mlogn)$，其中n表示除数长度，m表示长度n的乘法的时间，所以在n较大的时候，用牛顿迭代会更好。以下是我的实现部分代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//返回右移后的结果
BigIntSimple shr_to(size_t n) const {
    BigIntSimple r;
    if (n &amp;gt;= v.size()) return r;
    r.v.assign(v.begin() + n, v.end());
    return r;
}

//对自身左移
BigIntSimple &amp;amp;shl(size_t n) {
    if (n == 0) return *this;
    v.insert(v.begin(), n, 0);
    return *this;
}

//分治除法递归部分
BigIntSimple &amp;amp;dividediv_recursion(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
    if (a &amp;lt; b) {
        r = a;
        return *this = BigIntSimple(0);
    } else if (b.v.size() &amp;lt;= 300) {
        return *this = a.div_mod(b, r);
    }
    size_t base = (b.v.size() + 1) / 2;
    //符合3/2时，进行试商
    if (a.v.size() &amp;lt;= base * 3) {
        base = b.v.size() / 2;
        BigIntSimple ma = a, mb = b, e;
        BigIntSimple ha = ma.shr_to(base);
        BigIntSimple hb = mb.shr_to(base);
        dividediv_recursion(ha, hb, r);
        ha = *this * b;
        while (a &amp;lt; ha) {
            ha.subtract(b);
            subtract(BigIntSimple(1));
        }
        r = a - ha;
        return *this;
    }
    //选择合适的base长度做分割
    if (a.v.size() &amp;gt; base * 4) base = a.v.size() / 2;
    BigIntSimple ha = a.shr_to(base);
    BigIntSimple c, d, m;
    dividediv_recursion(ha, b, d);
    shl(base);
    m.v.resize(base + d.v.size());
    for (size_t i = 0; i &amp;lt; base; ++i)
        m.v[i] = a.v[i];
    for (size_t i = 0; i &amp;lt; d.v.size(); ++i)
        m.v[base + i] = d.v[i];
    *this = *this + c.dividediv_recursion(m, b, r);
    return *this;
}

//分治除法规则化准备
BigIntSimple &amp;amp;dividediv(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
    if (b.v.size() &amp;lt;= 300) {
        return *this = a.div_mod(b, r);
    }
    //被除数不及两倍除数长度减2时，可以忽略一部分最低位且不影响结果
    if (b.v.size() * 2 - 2 &amp;gt; a.v.size()) {
        BigIntSimple ta = a, tb = b;
        size_t ans_len = a.v.size() - b.v.size() + 2;
        size_t shr = b.v.size() - ans_len;
        ta = ta.shr_to(shr);
        tb = tb.shr_to(shr);
        return dividediv(ta, tb, r);
    }
    //规则化
    int mul = (int)(((uint64_t)BIGINT_BASE * BIGINT_BASE - 1) /    //
        (*(b.v.begin() + b.v.size() - 1) * (uint64_t)BIGINT_BASE + //
            *(b.v.begin() + b.v.size() - 2) + 1));
    BigIntSimple ma = a * BigIntSimple(mul);
    BigIntSimple mb = b * BigIntSimple(mul);
    BigIntSimple d;
    ma.sign = mb.sign = 1;
    dividediv_recursion(ma, mb, d);
    r = d.div_mod(BigIntSimple(mul), ma);
    return *this;
}

BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
    BigIntSimple r, t;
    // t = div_mod(b, r);
    t.dividediv(*this, b, r);
    t.sign = sign * b.sign;
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bigintsimple类的完整代码&#34;&gt;BigIntSimple类的完整代码&lt;/h2&gt;

&lt;p&gt;事实上，代码写到这里，就已经和我在项目里实现的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger/blob/main/bigint_mini.h&#34; target=&#34;_blank&#34;&gt;bigint_mini&lt;/a&gt;没有什么区别了，直接看这个好了，主要区别就是少了进制转换输入输出，性能上也稍微差一丁点。完整代码有点长，近500行。&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; // 1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) { *this = n; }
    //判断是否为0
    bool iszero() const { return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0; }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero()) sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size()) return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i]) return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //分治进制转换输入
    BigIntSimple &amp;amp;_from_str(const std::string &amp;amp;s, int base) {
        //较短长度时直接计算，36^4 &amp;lt; 2^31，但取5就大于了，所以长度上限是4
        if (s.size() &amp;lt;= 4) {
            int v = 0;
            for (size_t i = 0; i &amp;lt; s.size(); ++i) {
                int digit = -1;
                if (s[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;9&#39;)
                    digit = s[i] - &#39;0&#39;;
                else if (s[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;Z&#39;)
                    digit = s[i] - &#39;A&#39; + 10;
                else if (s[i] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;z&#39;)
                    digit = s[i] - &#39;a&#39; + 10;
                v = v * base + digit;
            }
            return *this = v;
        }
        BigIntSimple m(base), h;
        size_t len = 1;
        //计算分割点
        for (; len * 3 &amp;lt; s.size(); len *= 2) {
            m = m * m;
        }
        h._from_str(s.substr(0, s.size() - len), base);
        _from_str(s.substr(s.size() - len), base);
        *this = *this + m * h;
        return *this;
    }
    //任意进制字符串输入（2~36进制）
    BigIntSimple &amp;amp;from_str(const char *s, int base = 10) {
        //特殊情况直接用原来的读入函数速度快
        if (base == 10) {
            set(s);
            return *this;
        }
        int vsign = 1, i = 0;
        while (s[i] == &#39;-&#39;) {
            ++i;
            vsign = -vsign;
        }
        _from_str(std::string(s + i), base);
        sign = vsign;
        return *this;
    }
    //字符串输出
    std::string to_dec() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }
    //递归分治进制转换输出
    std::string _to_str(int base, int pack) const {
        std::string s;
        //长度只剩下2时可以直接算
        if (v.size() &amp;lt;= 2) {
            int d = v[0] + (v.size() &amp;gt; 1 ? v[1] : 0) * BIGINT_BASE;
            do {
                int g = d % base;
                if (g &amp;lt; 10) {
                    s += char(g + &#39;0&#39;);
                } else {
                    s += char(g + &#39;a&#39; - 10);
                }
                d /= base;
            } while (d);
            //填充前导0
            while (s.size() &amp;lt; pack)
                s += &#39;0&#39;;
            std::reverse(s.begin(), s.end());
            return s;
        }
        BigIntSimple m(base), h, l;
        size_t len = 1; //计算余数部分要补的前导0
        //计算分割点
        for (; m.v.size() * 3 &amp;lt; v.size(); len *= 2) {
            m = m * m;
        }
        h = div_mod(m, l); //算出分割后的高位h和低位l
        s = h._to_str(base, std::max(pack - (int)len, 0));
        return s + l._to_str(base, len);
    }
    //任意进制（2~36进制）字符串输出
    std::string to_str(int base = 10) const {
        if (base == 10) {
            return to_dec();
        }
        std::string s;
        BigIntSimple m(*this);
        m.sign = 1;
        s = m._to_str(base, 0);
        return sign &amp;gt;= 0 ? s : &amp;quot;-&amp;quot; + s;
    }

    bool operator&amp;lt;(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return sign &amp;gt; 0 ? absless(b) : b.absless(*this);
        } else {
            return sign &amp;lt; 0;
        }
    }

    bool operator==(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return !absless(b) &amp;amp;&amp;amp; !b.absless(*this);
        }
        return false;
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty()) v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign) return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size()) r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }

    BigIntSimple &amp;amp;offset_add(const BigIntSimple &amp;amp;b, int offset) {
        //填充高位
        if (v.size() &amp;lt; b.v.size() + offset) v.resize(b.v.size() + offset);
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += v[i + offset] + b.v[i] - BIGINT_BASE;
            v[i + offset] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size() + offset; carry &amp;amp;&amp;amp; i &amp;lt; v.size(); ++i) {
            carry += v[i] - BIGINT_BASE;
            v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) v.push_back(carry);
        return *this;
    }

    BigIntSimple mul(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        return r;
    }

    BigIntSimple &amp;amp;fastmul(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b) {
        //小于某个阈值就直接用暴力乘法
        if (std::min(a.v.size(), b.v.size()) &amp;lt;= 300) {
            return *this = a.mul(b);
        }
        BigIntSimple ah, al, bh, bl, h, m;
        //计算分割点
        size_t split = std::max(                            //
            std::min((a.v.size() + 1) / 2, b.v.size() - 1), //
            std::min((b.v.size() + 1) / 2, a.v.size() - 1));
        //按分割点拆成4个数
        al.v.assign(a.v.begin(), a.v.begin() + split);
        ah.v.assign(a.v.begin() + split, a.v.end());
        bl.v.assign(b.v.begin(), b.v.begin() + split);
        bh.v.assign(b.v.begin() + split, b.v.end());
        //按公式递归计算
        fastmul(al, bl);
        h.fastmul(ah, bh);
        m.fastmul(al + ah, bl + bh);
        m.subtract(*this + h);
        v.resize(a.v.size() + b.v.size());

        offset_add(m, split);
        offset_add(h, split * 2);
        trim();
        return *this;
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        r.fastmul(*this, b);
        // r = mul(b);
        r.sign = sign * b.sign;
        return r;
    }

    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0) return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }

    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) + (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        return d;
    }

    //返回右移后的结果
    BigIntSimple shr_to(size_t n) const {
        BigIntSimple r;
        if (n &amp;gt;= v.size()) return r;
        r.v.assign(v.begin() + n, v.end());
        return r;
    }

    //对自身左移
    BigIntSimple &amp;amp;shl(size_t n) {
        if (n == 0) return *this;
        v.insert(v.begin(), n, 0);
        return *this;
    }

    //分治除法递归部分
    BigIntSimple &amp;amp;dividediv_recursion(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
        if (a &amp;lt; b) {
            r = a;
            return *this = BigIntSimple(0);
        } else if (b.v.size() &amp;lt;= 300) {
            return *this = a.div_mod(b, r);
        }
        size_t base = (b.v.size() + 1) / 2;
        //符合3/2时，进行试商
        if (a.v.size() &amp;lt;= base * 3) {
            base = b.v.size() / 2;
            BigIntSimple ma = a, mb = b, e;
            BigIntSimple ha = ma.shr_to(base);
            BigIntSimple hb = mb.shr_to(base);
            dividediv_recursion(ha, hb, r);
            ha = *this * b;
            while (a &amp;lt; ha) {
                ha.subtract(b);
                subtract(BigIntSimple(1));
            }
            r = a - ha;
            return *this;
        }
        //选择合适的base长度做分割
        if (a.v.size() &amp;gt; base * 4) base = a.v.size() / 2;
        BigIntSimple ha = a.shr_to(base);
        BigIntSimple c, d, m;
        dividediv_recursion(ha, b, d);
        shl(base);
        m.v.resize(base + d.v.size());
        for (size_t i = 0; i &amp;lt; base; ++i)
            m.v[i] = a.v[i];
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i)
            m.v[base + i] = d.v[i];
        *this = *this + c.dividediv_recursion(m, b, r);
        return *this;
    }

    //分治除法规则化准备
    BigIntSimple &amp;amp;dividediv(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) {
        if (b.v.size() &amp;lt;= 300) {
            return *this = a.div_mod(b, r);
        }
        //被除数不及两倍除数长度减2时，可以忽略一部分最低位且不影响结果
        if (b.v.size() * 2 - 2 &amp;gt; a.v.size()) {
            BigIntSimple ta = a, tb = b;
            size_t ans_len = a.v.size() - b.v.size() + 2;
            size_t shr = b.v.size() - ans_len;
            ta = ta.shr_to(shr);
            tb = tb.shr_to(shr);
            return dividediv(ta, tb, r);
        }
        //规则化
        int mul = (int)(((uint64_t)BIGINT_BASE * BIGINT_BASE - 1) /                //
                        (*(b.v.begin() + b.v.size() - 1) * (uint64_t)BIGINT_BASE + //
                         *(b.v.begin() + b.v.size() - 2) + 1));
        BigIntSimple ma = BigIntSimple(mul) * a;
        BigIntSimple mb = BigIntSimple(mul) * b;
        BigIntSimple d;
        ma.sign = mb.sign = 1;
        dividediv_recursion(ma, mb, d);
        r = d.div_mod(BigIntSimple(mul), ma);
        return *this;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r, t;
        // t = div_mod(b, r);
        t.dividediv(*this, b, r);
        t.sign = sign * b.sign;
        return t;
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const { return *this - *this / b * b; }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算2——乘法优化及进制转换</title>
      <link>/post/20210308-bigint2/</link>
      <pubDate>Mon, 08 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210308-bigint2/</guid>
      <description>&lt;p&gt;在上一篇介绍了基础算法后，本篇介绍算法级别的优化。本篇的三大内容：乘法优化，任意进制输入，任意进制输出。&lt;/p&gt;

&lt;h2 id=&#34;乘法优化&#34;&gt;乘法优化&lt;/h2&gt;

&lt;p&gt;这里要介绍的，是Karatsuba发现的分治法，我们假设要相乘的两个数，都有2n位，那么这两个数就可以分别表示为$a_1base^n+a_2, b_1base^n+b_2$，其中，$a_1,a_2,b_1,b_2$是n位的大整数，那么，它们的积就是&lt;/p&gt;

&lt;p&gt;$$\begin{align}
&amp;amp;   (a_1base^n+a_2) \times (b_1base^n+b_2) \\&lt;br /&gt;
&amp;amp; = a_1b_1base^{2n} + (a_1b_2+a_2b_1)base^n + a_2b_2 \\&lt;br /&gt;
&amp;amp; = a_1b_1base^{2n} + ((a_1+a_2)(b_1+b_2)-a_1b_1-a_2b_2)base^n + a_2b_2
\end{align}$$&lt;/p&gt;

&lt;p&gt;如果这样不够明显的话，我们用$c_1$代替$a_1b_1$，用$c_3$代替$a_2b_2$，得到&lt;/p&gt;

&lt;p&gt;$c_1base^{2n} + ((a_1+a_2)(b_1+b_2)-c_1-c_3)base^n + c_3$&lt;/p&gt;

&lt;p&gt;于是，这里一共有3次乘法，比起原来的4次暴力乘法减少了1次。而里面的乘法又可以进行递归优化，时间复杂度从$O(n^2)$下降到$O(n^{log_23})$约$O(n^{1.585})$&lt;/p&gt;

&lt;p&gt;当然，在实际应用时，这两个数不可能都正好一样的位，不过也不要紧，这个算法对分割点位置也没有要求，但当然分割位置尽可能在中间，效率越高，于是实际实现就会有一堆细节，这里就不做介绍了。只要在原有的模板里面增加移位加法操作，这个优化算法就能套上去用，用起来非常简单。以下就是在上文中对&lt;code&gt;BigIntSimple&lt;/code&gt;修改的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple &amp;amp;offset_add(const BigIntSimple &amp;amp;b, int offset) {
        //填充高位
        if (v.size() &amp;lt; b.v.size() + offset) v.resize(b.v.size() + offset);
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += v[i + offset] + b.v[i] - BIGINT_BASE;
            v[i + offset] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size() + offset; carry &amp;amp;&amp;amp; i &amp;lt; v.size(); ++i) {
            carry += v[i] - BIGINT_BASE;
            v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) v.push_back(carry);
        return *this;
    }

    BigIntSimple mul(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        return r;
    }

    BigIntSimple &amp;amp;fastmul(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b) {
        //小于某个阈值就直接用暴力乘法
        if (std::min(a.v.size(), b.v.size()) &amp;lt;= 300) {
            return *this = a.mul(b);
        }
        BigIntSimple ah, al, bh, bl, h, m;
        //计算分割点
        size_t split = std::max(
            std::min((a.v.size() + 1) / 2, b.v.size() - 1),
            std::min((b.v.size() + 1) / 2, a.v.size() - 1));
        //按分割点拆成4个数
        al.v.assign(a.v.begin(), a.v.begin() + split);
        ah.v.assign(a.v.begin() + split, a.v.end());
        bl.v.assign(b.v.begin(), b.v.begin() + split);
        bh.v.assign(b.v.begin() + split, b.v.end());
        //按公式递归计算
        fastmul(al, bl);
        h.fastmul(ah, bh);
        m.fastmul(al + ah, bl + bh);
        m.subtract(*this + h);
        v.resize(a.v.size() + b.v.size());
        offset_add(m, split);
        offset_add(h, split * 2);
        trim();
        return *this;
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        r.fastmul(*this, b);
        r.sign = sign * b.sign;
        return r;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个优化一加，那个10000阶乘的题目就轻松缩短到109ms。且代码不长，加起来轻松又愉快。&lt;/p&gt;

&lt;p&gt;类似地，以上优化算法是分成两路进行分治，如果分成三路，那么就叫做&lt;code&gt;Toom-3&lt;/code&gt;算法，时间复杂度为$O(n^{log_35})$约$O(n^{1.465})$，如果分成四路，那么就叫做&lt;code&gt;Toom-4&lt;/code&gt;算法，时间复杂度为$O(n^{log_47})$约$O(n^{1.404})$，Toom算法还有很多个变种，Karatsuba分治法其实就是Toom算法在n为2的情况。但很多时候，用Karatsuba已经足够了，除非你对性能有特别的追求。&lt;/p&gt;

&lt;h2 id=&#34;任意进制读入&#34;&gt;任意进制读入&lt;/h2&gt;

&lt;p&gt;所谓任意进制，如果用字符串输入，通常限定为2~36进制，当然如果你直接用数组作为输入，那确实可以支持任意进制。为了方便表述，以下假设你的大整数类使用base进制，输入是b进制，$base \neq b$。&lt;/p&gt;

&lt;p&gt;对于这个问题，最多人的想法是，按进制的定义直接加起来，假设输入是$s_ns_{n-1} \dots s_2s_1s_0$，那就求出$s_0+s_1b+s_2b^2+ \dots +s_nb^n$，再整理就得到$((\dots((s_n*b+s_{n-1}) *b+s_{n-2}) *b+\dots)+s_1) *b + s_0$，所以写一个循环，计算过程用这个大整数类即可。这样一共有n次乘法，而这里每次乘法是$O(n)$，所以整体复杂度是$O(n^2)$。&lt;/p&gt;

&lt;p&gt;但是，不能光看时间复杂度，来回忆一下在上一篇文章里，阶乘代码是怎么写的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BigIntSimple fac(int start, int n) {
    if (n &amp;lt; 16) {
        BigIntSimple s = 1;
        for (int i = start; i &amp;lt; start + n; ++i)
            s = BigIntSimple(i) * s;
        return s;
    }
    int m = (n + 1) / 2;
    return fac(start, m) * fac(start + m, n - m);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个写法丝毫没有减少&lt;code&gt;BigIntSimple&lt;/code&gt;之间做乘法的次数，但却比暴力乘法来的快，原因是什么？你有想过原因吗？&lt;/p&gt;

&lt;p&gt;假设有2n个小整数相乘，假设它们大小都在base附近，那么直接乘的话，那么小整数的乘法次数（即把大整数的乘法过程拆分来统计）就是&lt;/p&gt;

&lt;p&gt;$\sum\limits_{i=1}^{2n-1}{i} = n(2n-1) = 2n^2 - n$&lt;/p&gt;

&lt;p&gt;而我们分成两组，每组各n个先乘，再来做1次n位的乘法，那么总次数是&lt;/p&gt;

&lt;p&gt;$2\sum\limits_{i=1}^{n-1}{i} + n^2 = n(n-1) + n^2 = 2n^2 - n$&lt;/p&gt;

&lt;p&gt;完全没有差别！那再假设，它们的大小都在$\sqrt{base}$附近呢，那直接乘的话，是&lt;/p&gt;

&lt;p&gt;$\sum\limits_{i=1}^{2n-1}{\lceil\dfrac{i}{2}\rceil} = \dfrac{n(n-1)+n(n+1)}{2} = n^2$&lt;/p&gt;

&lt;p&gt;分组再乘是&lt;/p&gt;

&lt;p&gt;$2\sum\limits_{i=1}^{n-1}{\lceil\dfrac{i}{2}\rceil + (\dfrac{n}{2})^2} = \dfrac{n^2}{2} + \dfrac{n^2}{4} = \dfrac{3n^2}{4}$&lt;/p&gt;

&lt;p&gt;甚至直接分成n组，每组两两相乘&lt;/p&gt;

&lt;p&gt;$n + \sum\limits_{i=1}^{n-1}{i} = n + \dfrac{n(n-1)}{2} = \dfrac{n^2 + n}{2}$&lt;/p&gt;

&lt;p&gt;这回差别就产生了，也就是说，如果做多次小整数乘法（小整数的定义为小于base），那么通过分组便可以有效减少计算次数，而且，我们还可以进行递归分组来节省更多的时间，最终得到约$\dfrac{n^2}{2}$的计算量。而求阶乘正好满足这个条件，于是便有了这个求阶乘的优化代码，而且这个方法还可以拓展，用优先队列维护最小的两个，每次找最小的两个来相乘，用此法时间在那个阶乘题目里可以稍微减少到93ms。而且，转换成两个大整数相乘还能用上前面说的乘法优化节省更多的时间。&lt;/p&gt;

&lt;p&gt;那阶乘和这进制转换有啥关系啊？重新看看那个进制转换的循环过程，是不是有超多的小整数乘法？所以又可以分治了。&lt;/p&gt;

&lt;p&gt;找一个分割点n，且满足$n=2^k$，原输入分割为$a_1b^n+a_2$，其中$a_1,a_2$都是大整数，这样求出$b^n$只需要k次自乘，这样就把原输入分割为两小段，这两小段再分别做输入的进制转换，这就是一个递归。这k次自乘，相乘的两数必然是等长度的，可以非常好的利用乘法加速特性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    //分治进制转换输入
    BigIntSimple &amp;amp;_from_str(const std::string &amp;amp;s, int base) {
        //较短长度时直接计算，36^4 &amp;lt; 2^31，但取5就大于了，所以长度上限是4
        if (s.size() &amp;lt;= 4) {
            int v = 0;
            for (size_t i = 0; i &amp;lt; s.size(); ++i) {
                int digit = -1;
                if (s[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;9&#39;)
                    digit = s[i] - &#39;0&#39;;
                else if (s[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;Z&#39;)
                    digit = s[i] - &#39;A&#39; + 10;
                else if (s[i] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;z&#39;)
                    digit = s[i] - &#39;a&#39; + 10;
                v = v * base + digit;
            }
            return *this = v;
        }
        BigIntSimple m(base), h;
        size_t len = 1;
        //计算分割点
        for (; len * 3 &amp;lt; s.size(); len *= 2) {
            m = m * m;
        }
        h._from_str(s.substr(0, s.size() - len), base);
        _from_str(s.substr(s.size() - len), base);
        *this = *this + m * h;
        return *this;
    }
    //任意进制字符串输入（2~36进制）
    BigIntSimple &amp;amp;from_str(const char *s, int base = 10) {
        //特殊情况直接用原来的读入函数速度快
        if (base == 10) {
            set(s);
            return *this;
        }
        int vsign = 1, i = 0;
        while (s[i] == &#39;-&#39;) {
            ++i;
            vsign = -vsign;
        }
        _from_str(std::string(s + i), base);
        sign = vsign;
        return *this;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;任意进制输出&#34;&gt;任意进制输出&lt;/h2&gt;

&lt;p&gt;相信对于这个问题，如果那个数有n位，你不会考虑做n次除法吧，做n次除法的总时间复杂度是$O(n^3)$，一个一万位的大整数你要进制转换输出那你得计算到什么时候去。假设大整数类的基是base，要输出的进制是b，通过前一个输入的方案，你应该很容易想到做除法分割，这样下一次的长度就下降到n/2，即我们先求出分割点k，满足$log_{base}b^k \approx n/2$，原数是a的话，计算出$a_1=\lfloor\dfrac{a}{b^k}\rfloor, a_2=a\,mod\,b^k$，然后再分别对$a_1,a_2$做进制转换，最后$a_2$的结果视情况补充前导0后，与$a_1$的结果做字符串连接即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    //字符串输出
    std::string to_dec() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }
    //递归分治进制转换输出
    std::string _to_str(int base, int pack) const {
        std::string s;
        //长度只剩下2时可以直接算
        if (v.size() &amp;lt;= 2) {
            int d = v[0] + (v.size() &amp;gt; 1 ? v[1] : 0) * BIGINT_BASE;
            do {
                int g = d % base;
                if (g &amp;lt; 10) {
                    s += char(g + &#39;0&#39;);
                } else {
                    s += char(g + &#39;a&#39; - 10);
                }
                d /= base;
            } while (d);
            //填充前导0
            while (s.size() &amp;lt; pack)
                s += &#39;0&#39;;
            std::reverse(s.begin(), s.end());
            return s;
        }
        BigIntSimple m(base), h, l;
        size_t len = 1; //计算余数部分要补的前导0
        //计算分割点
        for (; m.v.size() * 3 &amp;lt; v.size(); len *= 2) {
            m = m * m;
        }
        h = div_mod(m, l); //算出分割后的高位h和低位l
        s = h._to_str(base, std::max(pack - (int)len, 0));
        return s + l._to_str(base, len);
    }
    //任意进制（2~36进制）字符串输出
    std::string to_str(int base = 10) const {
        if (base == 10) {
            return to_dec();
        }
        std::string s;
        BigIntSimple m(*this);
        m.sign = 1;
        s = m._to_str(base, 0);
        return sign &amp;gt;= 0 ? s : &amp;quot;-&amp;quot; + s;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法是有了，但问题是，这个方法并不够快，虽然复杂度确实下降到$O(n^2)$，但常数大，除法比乘法的常数大，而且除法不太好优化，但乘法的优化前面已经有了，有没有不需要除法的办法？有啊，考虑一下，既然输出是b进制，那么我们直接动态方式构造一个使用的base为$b^n$的大整数类，直接按前一个方法，把输出作为这个新大整数类的输入，这样输入完了再转了b进制输出不就只有乘法了。不过需要再另写一个类，这里不提供示例代码了，直接看项目代码吧，因为代码比较长。&lt;/p&gt;

&lt;p&gt;具体请参见&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger项目&lt;/a&gt;中BigIntBase的实现。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;最后，加上了乘法优化和任意进制输入输出的模板（用分治除法实现的输出）如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; // 1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) { *this = n; }
    //判断是否为0
    bool iszero() const { return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0; }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero()) sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size()) return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i]) return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //分治进制转换输入
    BigIntSimple &amp;amp;_from_str(const std::string &amp;amp;s, int base) {
        //较短长度时直接计算，36^4 &amp;lt; 2^31，但取5就大于了，所以长度上限是4
        if (s.size() &amp;lt;= 4) {
            int v = 0;
            for (size_t i = 0; i &amp;lt; s.size(); ++i) {
                int digit = -1;
                if (s[i] &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;9&#39;)
                    digit = s[i] - &#39;0&#39;;
                else if (s[i] &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;Z&#39;)
                    digit = s[i] - &#39;A&#39; + 10;
                else if (s[i] &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; s[i] &amp;lt;= &#39;z&#39;)
                    digit = s[i] - &#39;a&#39; + 10;
                v = v * base + digit;
            }
            return *this = v;
        }
        BigIntSimple m(base), h;
        size_t len = 1;
        //计算分割点
        for (; len * 3 &amp;lt; s.size(); len *= 2) {
            m = m * m;
        }
        h._from_str(s.substr(0, s.size() - len), base);
        _from_str(s.substr(s.size() - len), base);
        *this = *this + m * h;
        return *this;
    }
    //任意进制字符串输入（2~36进制）
    BigIntSimple &amp;amp;from_str(const char *s, int base = 10) {
        //特殊情况直接用原来的读入函数速度快
        if (base == 10) {
            set(s);
            return *this;
        }
        int vsign = 1, i = 0;
        while (s[i] == &#39;-&#39;) {
            ++i;
            vsign = -vsign;
        }
        _from_str(std::string(s + i), base);
        sign = vsign;
        return *this;
    }
    //字符串输出
    std::string to_dec() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }
    //递归分治进制转换输出
    std::string _to_str(int base, int pack) const {
        std::string s;
        //长度只剩下2时可以直接算
        if (v.size() &amp;lt;= 2) {
            int d = v[0] + (v.size() &amp;gt; 1 ? v[1] : 0) * BIGINT_BASE;
            do {
                int g = d % base;
                if (g &amp;lt; 10) {
                    s += char(g + &#39;0&#39;);
                } else {
                    s += char(g + &#39;a&#39; - 10);
                }
                d /= base;
            } while (d);
            //填充前导0
            while (s.size() &amp;lt; pack)
                s += &#39;0&#39;;
            std::reverse(s.begin(), s.end());
            return s;
        }
        BigIntSimple m(base), h, l;
        size_t len = 1; //计算余数部分要补的前导0
        //计算分割点
        for (; m.v.size() * 3 &amp;lt; v.size(); len *= 2) {
            m = m * m;
        }
        h = div_mod(m, l); //算出分割后的高位h和低位l
        s = h._to_str(base, std::max(pack - (int)len, 0));
        return s + l._to_str(base, len);
    }
    //任意进制（2~36进制）字符串输出
    std::string to_str(int base = 10) const {
        if (base == 10) {
            return to_dec();
        }
        std::string s;
        BigIntSimple m(*this);
        m.sign = 1;
        s = m._to_str(base, 0);
        return sign &amp;gt;= 0 ? s : &amp;quot;-&amp;quot; + s;
    }

    bool operator&amp;lt;(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return sign &amp;gt; 0 ? absless(b) : b.absless(*this);
        } else {
            return sign &amp;lt; 0;
        }
    }

    bool operator==(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return !absless(b) &amp;amp;&amp;amp; !b.absless(*this);
        }
        return false;
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty()) v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign) return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size()) r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }

    BigIntSimple &amp;amp;offset_add(const BigIntSimple &amp;amp;b, int offset) {
        //填充高位
        if (v.size() &amp;lt; b.v.size() + offset) v.resize(b.v.size() + offset);
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += v[i + offset] + b.v[i] - BIGINT_BASE;
            v[i + offset] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size() + offset; carry &amp;amp;&amp;amp; i &amp;lt; v.size(); ++i) {
            carry += v[i] - BIGINT_BASE;
            v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) v.push_back(carry);
        return *this;
    }

    BigIntSimple mul(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        return r;
    }

    BigIntSimple &amp;amp;fastmul(const BigIntSimple &amp;amp;a, const BigIntSimple &amp;amp;b) {
        //小于某个阈值就直接用暴力乘法
        if (std::min(a.v.size(), b.v.size()) &amp;lt;= 300) {
            return *this = a.mul(b);
        }
        BigIntSimple ah, al, bh, bl, h, m;
        //计算分割点
        size_t split = std::max(                            //
            std::min((a.v.size() + 1) / 2, b.v.size() - 1), //
            std::min((b.v.size() + 1) / 2, a.v.size() - 1));
        //按分割点拆成4个数
        al.v.assign(a.v.begin(), a.v.begin() + split);
        ah.v.assign(a.v.begin() + split, a.v.end());
        bl.v.assign(b.v.begin(), b.v.begin() + split);
        bh.v.assign(b.v.begin() + split, b.v.end());
        //按公式递归计算
        fastmul(al, bl);
        h.fastmul(ah, bh);
        m.fastmul(al + ah, bl + bh);
        m.subtract(*this + h);
        v.resize(a.v.size() + b.v.size());

        offset_add(m, split);
        offset_add(h, split * 2);
        trim();
        return *this;
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        r.fastmul(*this, b);
        r.sign = sign * b.sign;
        return r;
    }

    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0) return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }

    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                   (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const { return *this - *this / b * b; }
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算——有趣的实现</title>
      <link>/post/20210305-bigint_fun/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210305-bigint_fun/</guid>
      <description>&lt;p&gt;这里收录一些有意思的实现，不过我都有进行改编以更方便使用，不过千万不要指望这性能有多高。收录的条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持四则运算，必须包含除法及求余&lt;/li&gt;
&lt;li&gt;支持字符串输入输出&lt;/li&gt;
&lt;li&gt;代码不长&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;small-biginteger-library-for-contest&#34;&gt;small biginteger library for contest&lt;/h2&gt;

&lt;p&gt;代码原作者Jane Alam Jan，你可以在Google上直接搜索&lt;code&gt;small_biginteger_library_for_contest.pdf&lt;/code&gt;并下载到原始说明文档及代码，这里提供一份代码，改动不多，增加了int的构造函数和其它不等号的重载，且增加输出到string而不直接输出终端，以便在其它场合使用更方便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Bigint {
    // representations and structures
    std::string a; // to store the digits
    int sign;      // sign = -1 for negative numbers, sign = 1 otherwise
    // constructors
    Bigint() {}                            // default constructor
    Bigint(std::string b) { (*this) = b; } // constructor for string
    Bigint(int v) {
        char buf[30];
        sprintf(buf, &amp;quot;%d&amp;quot;, v);
        (*this) = buf;
    }
    // some helpful methods
    int size() { return a.size(); } // returns number of digits
    Bigint inverseSign() {
        sign *= -1;
        return (*this);
    }
    Bigint normalize(int newSign) { // removes leading 0, fixes sign
        for (int i = a.size() - 1; i &amp;gt; 0 &amp;amp;&amp;amp; a[i] == &#39;0&#39;; i--)
            a.erase(a.begin() + i);
        sign = (a.size() == 1 &amp;amp;&amp;amp; a[0] == &#39;0&#39;) ? 1 : newSign;
        return (*this);
    }
    // assignment operator
    void operator=(std::string b) { // assigns a string to Bigint
        a = b[0] == &#39;-&#39; ? b.substr(1) : b;
        reverse(a.begin(), a.end());
        this-&amp;gt;normalize(b[0] == &#39;-&#39; ? -1 : 1);
    }
    // conditional operators
    bool operator&amp;lt;(const Bigint &amp;amp;b) const { // less than operator
        if (sign != b.sign) return sign &amp;lt; b.sign;
        if (a.size() != b.a.size()) return sign == 1 ? a.size() &amp;lt; b.a.size() : a.size() &amp;gt; b.a.size();
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            if (a[i] != b.a[i]) return sign == 1 ? a[i] &amp;lt; b.a[i] : a[i] &amp;gt; b.a[i];
        return false;
    }
    bool operator==(const Bigint &amp;amp;b) const { return a == b.a &amp;amp;&amp;amp; sign == b.sign; }
    // mathematical operators
    Bigint operator+(Bigint b) { // addition operator overloading
        if (sign != b.sign) return (*this) - b.inverseSign();
        Bigint c;
        for (int i = 0, carry = 0; i &amp;lt; a.size() || i &amp;lt; b.size() || carry; i++) {
            carry += (i &amp;lt; a.size() ? a[i] - 48 : 0) + (i &amp;lt; b.a.size() ? b.a[i] - 48 : 0);
            c.a += (carry % 10 + 48);
            carry /= 10;
        }
        return c.normalize(sign);
    }
    Bigint operator-(Bigint b) { // subtraction operator overloading
        if (sign != b.sign) return (*this) + b.inverseSign();
        int s = sign;
        sign = b.sign = 1;
        if ((*this) &amp;lt; b) return ((b - (*this)).inverseSign()).normalize(-s);
        Bigint c;
        for (int i = 0, borrow = 0; i &amp;lt; a.size(); i++) {
            borrow = a[i] - borrow - (i &amp;lt; b.size() ? b.a[i] : 48);
            c.a += borrow &amp;gt;= 0 ? borrow + 48 : borrow + 58;
            borrow = borrow &amp;gt;= 0 ? 0 : 1;
        }
        return c.normalize(s);
    }
    Bigint operator*(Bigint b) { // multiplication operator overloading
        Bigint c(&amp;quot;0&amp;quot;);
        for (int i = 0, k = a[i] - 48; i &amp;lt; a.size(); i++, k = a[i] - 48) {
            while (k--)
                c = c + b;                // ith digit is k, so, we add k times
            b.a.insert(b.a.begin(), &#39;0&#39;); // multiplied by 10
        }
        return c.normalize(sign * b.sign);
    }
    Bigint operator/(Bigint b) { // division operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;), d;
        for (int j = 0; j &amp;lt; a.size(); j++)
            d.a += &amp;quot;0&amp;quot;;
        int dSign = sign * b.sign;
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b, d.a[i]++;
        }
        return d.normalize(dSign);
    }
    Bigint operator%(Bigint b) { // modulo operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;);
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b;
        }
        return c.normalize(sign);
    }
    std::string to_str() const {
        std::string s;
        if (sign == -1) s += &#39;-&#39;;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            s += a[i];
        return s;
    }
    bool operator&amp;gt;(const Bigint &amp;amp;b) const { return b &amp;lt; *this; }
    bool operator&amp;lt;=(const Bigint &amp;amp;b) const { return !(b &amp;lt; *this); }
    bool operator&amp;gt;=(const Bigint &amp;amp;b) const { return !(*this &amp;lt; b); }
    bool operator!=(const Bigint &amp;amp;b) const { return !(*this == b); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现使用string来实现大整数，于是缺点就非常明显了，就是性能低下，非常低，求个300阶乘都要1.5秒。不过，这代码里有不少写法是牺牲性能换代码长度，有的思路确实也不错。在同样代码长度级别下，我实现的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger/blob/main/bigint_tiny.h&#34; target=&#34;_blank&#34;&gt;BigIntTiny&lt;/a&gt;有着好得多的性能。或者来直接看以下这份更短的实现。&lt;/p&gt;

&lt;h2 id=&#34;一份60行不到的大整数实现&#34;&gt;一份60行不到的大整数实现&lt;/h2&gt;

&lt;p&gt;改编自&lt;a href=&#34;https://wu-kan.cn/_posts/2019-01-26-%E9%AB%98%E7%B2%BE%E5%BA%A6/&#34; target=&#34;_blank&#34;&gt;wu-kan&lt;/a&gt;以及&lt;a href=&#34;https://zhuanlan.zhihu.com/p/72730434&#34; target=&#34;_blank&#34;&gt;hqztrue&lt;/a&gt;的基于bitset实现的定长大整数，支持10进制输入输出，四则运算及位运算均支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;string&amp;gt;

#define BINT_MAXSIZE 2048
typedef typename std::bitset&amp;lt;BINT_MAXSIZE&amp;gt; Bint;
bool operator&amp;lt;(const Bint &amp;amp;a, const Bint &amp;amp;b) {
    for (int i = a.size() - 1; i &amp;gt;= 0; --i)
        if (a[i] != b[i]) return a[i] &amp;lt; b[i];
    return false;
}
bool operator&amp;gt;(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b &amp;lt; a; }
bool operator&amp;lt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(b &amp;lt; a); }
bool operator&amp;gt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(a &amp;lt; b); }
Bint operator+(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b.any() ? (a ^ b) + ((a &amp;amp; b) &amp;lt;&amp;lt; 1) : a; }
Bint &amp;amp;operator+=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a + b; }
Bint operator-(const Bint &amp;amp;a) { return Bint(1) + ~a; }
Bint operator-(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b.any() ? (a ^ b) - ((~a &amp;amp; b) &amp;lt;&amp;lt; 1) : a; }
Bint &amp;amp;operator-=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a - b; }
Bint operator*(Bint a, Bint b) {
    Bint r(0);
    for (; b.any(); b &amp;gt;&amp;gt;= 1, a &amp;lt;&amp;lt;= 1) if (b[0]) r += a;
    return r;
}
Bint &amp;amp;operator*=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a * b; }
std::pair&amp;lt;Bint, Bint&amp;gt; divide(Bint a, const Bint &amp;amp;b) {
    Bint c = 0;
    int i = 0;
    while (b &amp;lt;&amp;lt; (i + 1) &amp;lt;= a) ++i;
    for (; i &amp;gt;= 0; --i)
        if (a &amp;gt;= (b &amp;lt;&amp;lt; i)) a -= b &amp;lt;&amp;lt; i, c.set(i, 1);
    return std::make_pair(c, a);
}
Bint operator/(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).first; }
Bint &amp;amp;operator/=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a / b; }
Bint operator%(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).second; }
Bint &amp;amp;operator%=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a % b; }
Bint BintFromStr(const char *p) {
    Bint x = 0;
    int sign = 1;
    for (; *p == &#39;-&#39;; ++p) sign = -sign;
    for (; *p &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; *p &amp;lt;= &#39;9&#39;; ++p) x = (x &amp;lt;&amp;lt; 3) + (x &amp;lt;&amp;lt; 1) + (*p - &#39;0&#39;);
    return sign &amp;gt; 0 ? x : -x;
}
Bint BintFromInt(int i) {
    char buf[20];
    sprintf(buf, &amp;quot;%d&amp;quot;, i);
    return BintFromStr(buf);
}
std::string BintToStr(Bint x) {
    std::string out = x == 0 ? &amp;quot;0&amp;quot; : &amp;quot;&amp;quot;;
    std::vector&amp;lt;Bint&amp;gt; v;
    if (x[x.size() - 1]) out += &#39;-&#39;, x = -x;
    for (Bint y = 1; y &amp;lt;= x; y = (y &amp;lt;&amp;lt; 3) + (y &amp;lt;&amp;lt; 1)) v.push_back(y);
    for (int i = v.size() - 1; i &amp;gt;= 0; --i) {
        int t = 0;
        for (int l = 3; l &amp;gt;= 0; --l)
            if (x &amp;gt;= (v[i] &amp;lt;&amp;lt; l)) x -= v[i] &amp;lt;&amp;lt; l, t += 1 &amp;lt;&amp;lt; l;
        out += t + &#39;0&#39;;
    }
    return out;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现的代码就短到极致了，但性能同样也挺糟糕的，而且负数支持不佳（做除法会出错，需要自己转为正数做除法，或者可以自己写个类封装一下来解决这个问题），还有一个缺点是受bitset所限只能定长，不过在绝大部分情况下还能比前一份代码来得快不少，比如说求阶乘，长度设置为2048，求300的阶乘，这份代码只要0.01秒，前一份代码却要1.5秒，相差上百倍。要是改成求1000阶乘，设置长度为16384，计算时间为0.3秒（事实上这里面大部分时间花在了转出时转换到10进制，实际计算时间不到0.1秒），而前一份代码用时55秒。所以如果真要临时用用大整数，还是这个好，又短又不至于太慢。&lt;/p&gt;

&lt;h2 id=&#34;其它的github库实现&#34;&gt;其它的Github库实现&lt;/h2&gt;

&lt;p&gt;以下是我在Github找到的平均性能表现较好的一些小型实现，已经按平均性能进行排序（优先按1万位以内的乘法和除法运算性能进行排序&lt;del&gt;，才没有打广告&lt;/del&gt;）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;Baobaobear/MiniBigInteger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kedixa/klibcpp&#34; target=&#34;_blank&#34;&gt;kedixa/klibcpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ron4fun/BigIntegerCPP&#34; target=&#34;_blank&#34;&gt;ron4fun/BigIntegerCPP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square1001/bigint-library&#34; target=&#34;_blank&#34;&gt;square1001/bigint-library&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个只能在x64平台且只能用支持AT&amp;amp;T内联汇编编译器(如GCC/clang)的实现 &lt;a href=&#34;https://github.com/calebsander/bigint&#34; target=&#34;_blank&#34;&gt;calebsander/bigint&lt;/a&gt;，它的加减法和小规模乘法速度确实飞快，比前面列举到的都快，但受编译环境限制较大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算1——基础算法</title>
      <link>/post/20210228-bigint1/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210228-bigint1/</guid>
      <description>&lt;p&gt;最近在编写大整数库的过程中，踩到不少的坑，于是把一些有用的细节准备写成文章做整理。如果你只是想直接查找并使用一个大整数库，那直接上GMP即可，如果是用在比赛，那直接用我的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger项目&lt;/a&gt;，如果你是想学习个中细节，那你可以坐下来细品。&lt;/p&gt;

&lt;p&gt;所谓大整数，又叫高精度运算，就是运算对象是上千位甚至到百万位，总之远远超过内置数据类型的表示范围，这类数字都叫大整数。而C/C++的标准库里目前并没有大整数库，于是这个轮子被反复制造了无数个，不过在github上比较有质量的轮子并没有很多。本文除了介绍基础实现，主要还是介绍优化方法。&lt;/p&gt;

&lt;h2 id=&#34;大整数的表示&#34;&gt;大整数的表示&lt;/h2&gt;

&lt;p&gt;大整数的表示方法最常见的有4种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接使用string&lt;/li&gt;
&lt;li&gt;使用定长数组(仅适用于竞赛)&lt;/li&gt;
&lt;li&gt;使用链表&lt;/li&gt;
&lt;li&gt;使用变长线性表例如vector&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;直接用string的方式适合初学者，输入输出直观，但缺点也非常明显，因为计算时需要在字符与数值之间来回转换，浪费太多不必要的时间，效率会非常差。不过如果你是初学者，先用string表示法来写未尝不是个好主意。但有个细节就是，如果想要效率高，最好把string前后倒置调整为低位在前再做运算，这样速度和实现难度都会低一些。&lt;/p&gt;

&lt;p&gt;至于使用链表，好处是变长容易，变短也不难，但性能比用string的更差还更难写，这里就不谈了，以下介绍使用数组的表示法&lt;/p&gt;

&lt;p&gt;为了在数组里表示一个大整数，如果我们采用10进制，表示&lt;code&gt;123456789&lt;/code&gt;，那很简单，例如这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int a[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即&lt;code&gt;a[0]&lt;/code&gt;表示个位，&lt;code&gt;a[1]&lt;/code&gt;表示十位，如此类推。之所以这样做，是希望同一个位置的元素的含义是固定的，这样能简化后面的算法编写。&lt;/p&gt;

&lt;p&gt;但是，对于计算机来说，这样表示实在是太浪费空间和时间，我们还可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int a[] = {6789, 2345, 1};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，采用10000进制，那么这个10000叫做&lt;code&gt;基数&lt;/code&gt;或&lt;code&gt;base&lt;/code&gt;。我们还可以视情况使用其它的基数，例如使用$2^{16}$或$2^{32}$等等。对于这种我们原始进制是b的情况，但通过更大的基数$b^n$来表示的方法，叫做&lt;code&gt;压位高精度&lt;/code&gt;，n就是压的位数。压位高精度的运算效率远超非压位。&lt;/p&gt;

&lt;p&gt;以下我们用万进制来做一步步的演示，首先定义出这个类，在这里我用vector来保存（没有必要采用定长数组，因为效率没啥区别，除非你的OJ就不给加&lt;code&gt;O2&lt;/code&gt;优化例如某谷或参加某些信息竞赛）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; //1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是这里有一个问题，0怎么表示？在这里规定0的sign为1，且v的长度为1，这种约定可以在后期简化一些代码。当然你也可以规定v的长度为0，你怎么约定就怎么写代码即可。&lt;/p&gt;

&lt;h2 id=&#34;大整数的基本运算&#34;&gt;大整数的基本运算&lt;/h2&gt;

&lt;p&gt;实现一个功能还算得上完整的大整数，需要的基本运算有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;比较运算&lt;/li&gt;
&lt;li&gt;字符串输入&lt;/li&gt;
&lt;li&gt;字符串输出&lt;/li&gt;
&lt;li&gt;加法&lt;/li&gt;
&lt;li&gt;减法&lt;/li&gt;
&lt;li&gt;乘法&lt;/li&gt;
&lt;li&gt;除法及求余&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-比较运算&#34;&gt;1. 比较运算&lt;/h3&gt;

&lt;p&gt;大整数的比较很简单，先判断符号，符号不同再看位数，位数不同再从最高位一位一位比就行。但是我们其实更需要一个按绝对值比较的函数（后面的运算会需要它），那么先写一个无视符号的比较版本，再在运算符重载处判断符号即可。&lt;/p&gt;

&lt;h3 id=&#34;2-字符串输入输出&#34;&gt;2. 字符串输入输出&lt;/h3&gt;

&lt;p&gt;对于输入输出的字符串进制与该大整数的基相同时，输入输出直接映射转换即可，对于不同进制的输入输出在后面再做介绍，以下是实现了输入输出及一些基础功能的版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; //1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) {
        *this = n;
    }
    //判断是否为0
    bool iszero() const {
        return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0;
    }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero())
            sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size())
            return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i])
                    return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //字符串输出
    std::string to_str() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0)
            s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty())
            v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下文的介绍为了不重复，就不带上以上的代码了&lt;/p&gt;

&lt;h3 id=&#34;3-加法和减法&#34;&gt;3. 加法和减法&lt;/h3&gt;

&lt;p&gt;加法和减法都挺简单，核心思想就是模拟手工竖式，手工怎么算它就怎么算。要注意的点就是符号的处理。&lt;/p&gt;

&lt;p&gt;另外，还有一些小优化，加法进位的时候，这个if是可以简单省略掉的，用求模和除法运算即可。即当前位是&lt;code&gt;sum % base&lt;/code&gt;，进位是&lt;code&gt;sum / base&lt;/code&gt;。示例代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i];
            r.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但减法就没这么简单了，这时候还可以利用位运算来区分正负，比如，我们用当前位是&lt;code&gt;sum - (sum &amp;gt;&amp;gt; 31) * base&lt;/code&gt;，因为如果sum是负数，那么&lt;code&gt;sum &amp;gt;&amp;gt; 31&lt;/code&gt;在sum是int时就等于-1，相当于&lt;code&gt;sum + base&lt;/code&gt;；而如果sum是非负数，那么&lt;code&gt;sum &amp;gt;&amp;gt; 31&lt;/code&gt;就是0，结果就相当于&lt;code&gt;sum&lt;/code&gt;，这样就成功实现了&lt;code&gt;sum&amp;lt;0 ? sum+base : sum&lt;/code&gt;的逻辑。而这种方法同样可以用在加法上。另外，在较新的CPU上除法的性能比较高的时候，加法这种改进写法就会被淘汰。&lt;/p&gt;

&lt;p&gt;其它的细节在以下代码的注释中有标注&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign)
            return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size())
            r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry)
            r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign)
            return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-乘法&#34;&gt;4. 乘法&lt;/h3&gt;

&lt;p&gt;本文不区分高精度乘以低精度，和高精度乘以高精度，下文的除法也一样，因为实在没有这个必要分开写，以下直接介绍的是高精度乘以高精度。&lt;/p&gt;

&lt;p&gt;乘法可以看成在加法外面再套一层循环，内循环相比加法多了一个偏移和一个乘法。但是由于进位的值不会只是1，所以那个位运算方法在这里不能使用，只能用求模了。以下直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        //r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; //m用来缓存乘数
            //carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        r.sign = sign * b.sign;
        return r;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-除法和求余&#34;&gt;5. 除法和求余&lt;/h3&gt;

&lt;p&gt;除法是高精度的基础算法里面变化最多的，也是基础算法里面最难的，网上也有很多不同的写法，顺带说一说一些误区，同时这里提供一个我自己的写法，不过此法有限制条件，但在限制条件内应该是模拟手工的方法里面速度较快的。&lt;/p&gt;

&lt;p&gt;第一种就是暴力整体二分，然后做乘法验证（或者利用二进制一位一位来确定，但却不使用移位减法，而使用整体相乘），这时候，设是2n位除以n位，那么二分的次数就是n，然后一次乘法是n^2，所以整体复杂度是$O(n^3)$，这是一个非常糟糕的方法，虽然写起来似乎更简单，但时间上还不如直接模拟，千万不要做整体二分。类似地还有二分开方，也是$O(n^3)$。&lt;/p&gt;

&lt;p&gt;在模拟手工除法时，最关键的就是试商的部分，试商方法有很多，最简单的方式是用减法，先判断余数是不是大于等于除数，如果是，就做一次减法。这个写法确实容易，但问题是效率低下，除非你用的基数特别小，比如不压位10进制，这样速度还能看，甚至乎你用的是$2^n$进制，直接每个位枚举。&lt;/p&gt;

&lt;p&gt;那我们来个二分呢？如果在每一位上分别二分，那在基数较大的时候比做减法好一些，但还是不够好，我们还需要更快的方案，进一步减少试商次数。&lt;/p&gt;

&lt;p&gt;假设被除数有4个位，是$a_4,a_3,a_2,a_1$，除数有3个位，是$b_3,b_2,b_1$，那么我们只要试一位的商（多个位就是一位的写法加个循环），假如我们用$\dfrac{a_4 base+a_3}{b_3}$来试商，结果一定大于等于实际的商，但同时这会有一个问题，就是假如b2等于&lt;code&gt;base-1&lt;/code&gt;，那会导致试商与实际的商误差非常大，例如&lt;code&gt;9999,0000&lt;/code&gt;除以&lt;code&gt;1,9999&lt;/code&gt;，直接用高位除得到9999，但这远超过实际商了，修正商的代价也不小。于是，我们想到，在&lt;code&gt;base&lt;/code&gt;不太大的情况下，我们可以通过增加位数来估商，这样误差就会小得多。比如说我们用$\dfrac{a_4 base^2 + a_3 base + a_2}{b_3 base + b_2}$来试商，精度确实会大为提高，而且商的误差最多只有1，但缺点是，$a_4 base^2$的结果超出int的范围了，不过我们还可以用double。注意到，上式中a2对结果并没有任何影响，所以可以变形为$\dfrac{a_4 base + a_3}{b_3 + b_2/base}$。另外，我不希望这个估商总比实际商大，我们希望是小于等于实际商，这样在试后一位的时候，这个结果能自然得到修正，就增加了试商的效率，于是可以把式子改为$\dfrac{a_4 base + a_3}{b_3 + (b_2+1)base^{-1}}$，但这个+1导致误差增大，与实际商的误差最大达到2，那解决方法很简单，我们再增加1位的精度，得到式子$\dfrac{a_4 base + a_3}{b_3 + b_2 base^{-1} + (b_1+1)base^{-2}}$，于是便得到接下来在代码中所使用的算法。由于误差不超过1，如果估小了，那在下一位的估商时候就会产生补回去的效果，于是不必重复试商。这个方法要求&lt;code&gt;base&amp;lt;=32768&lt;/code&gt;以避免各种溢出，在满足此条件下，因为每个位均只需要估一次，那么其时间常数与乘法相比，和减法与加法常数比是几乎相同的。&lt;/p&gt;

&lt;p&gt;但是，有一个非常极端的情况，既然商最大误差是1，那么相当于余数的最大误差就等于除数，那如果除数特别大呢？举个例子，求&lt;code&gt;9999,9999,9999,9999/9999,9999,9999&lt;/code&gt;，用上面的方法，高一位的试商结果是0，次一位的试商是9999（实际商是10000），相减得到余数&lt;code&gt;1,0000,0000,9998&lt;/code&gt;，结果最高位并没有减到0，于是不能继续移位，需要在同一位再一次试商。但虽然在同一位试商两次，但后一位就不用做减法了，均摊还是n次。&lt;/p&gt;

&lt;p&gt;算法有了，该处理细节了，除法需要一个减法函数，不过这个函数对借位的处理和之前的减法可不一样，因为可能一次借n个，那就产生了一个问题：对负数求模。负数求模的结果和正数很不一样，所以如果还是要避免if做判断处理，那就要再换个方法，我承认我很菜，花了很久时间才想到这个法子，实现如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0)
            return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码关键点就是这两行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;核心思想是通过减去base统一在负数段求模后，再加上base回来，这样也达到避免if，避免if的写法比带if的写法时间上可以节省一半，不清楚有没有性能更好的做法。以下为除法及求余的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                    (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        div_mod(b, r);
        return r;
        //return *this - *this / b * b;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;求余就不说了，有求商之后代码仅一行&lt;code&gt;return *this - *this / b * b&lt;/code&gt;，而且这样写与C语言规则一致，模与被除数符号相同。当然以上代码实现的&lt;code&gt;div_mod&lt;/code&gt;函数本身就把商和余数同时求出，就可以直接调用而少了乘法和减法。&lt;/p&gt;

&lt;p&gt;但是，现在系统几乎都是64位的，于是在64位下我们就应该考虑更大的base，例如说使用亿进制，最大限度利用64位带来的性能提升。但是，如果我们使用大的base，那么考虑到double的精度，前面的试商法就失效了，甚至于连base的平方都超出double能精确表示的范围，那这时候应该怎么办呢？为了方便描述，这里我们假设用的是$2^{n}$进制，且n&amp;gt;=18，而double的尾数是53位，于是$log_2base^3=3n=54&amp;gt;53$，这就是令原问题失效的边界。但是，我们真的需要3n长度的尾数吗？确实并不需要，我们的base的精度是n位，只需要再增加k位，只要n+k到53还有一些距离就行，把这个数看成是浮点数，同样地，把被除数和除数都看成浮点数，那我们的除数如何进行+1操作呢？比如说除数表示为$b_3b_2b_1$，那我们让$b_3$右移n+k位加上去，不就相当于+1了。这个方法需要考虑到下一个数估商超过base大小的情况，所以要注意base不能超过$2^{30}$，如果你要使用$2^{32}$，那又得换一个办法了。在实际操作中，我令k=n/2，这样操作起来更为方便，具体请参阅我的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;MiniBigInteger&lt;/a&gt;项目。&lt;/p&gt;

&lt;h2 id=&#34;完整模板&#34;&gt;完整模板&lt;/h2&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; // 1表示正数，-1表示负数
    std::vector&amp;lt;int&amp;gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) { *this = n; }
    //判断是否为0
    bool iszero() const { return v.size() == 1 &amp;amp;&amp;amp; v.back() == 0; }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;amp;&amp;amp; v.size() &amp;gt; 1)
            v.pop_back();
        if (iszero()) sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &amp;gt;= v.size()) return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &amp;lt; v.size(); --i)
                if (v[i] != b.v[i]) return v[i] &amp;lt; b.v[i];
            return false;
        } else {
            return v.size() &amp;lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == &#39;-&#39;)
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - &#39;0&#39;);
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &amp;lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &amp;lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //字符串输出
    std::string to_str() const {
        std::string s;
        for (size_t i = 0; i &amp;lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &amp;lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + &#39;0&#39;;
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &amp;gt; 1 &amp;amp;&amp;amp; s.back() == &#39;0&#39;)
            s.pop_back();
        //补符号
        if (sign &amp;lt; 0) s += &#39;-&#39;;
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }

    bool operator&amp;lt;(const BigIntSimple &amp;amp;b) const {
        if (sign == b.sign) {
            return sign &amp;gt; 0 ? absless(b) : b.absless(*this);
        } else {
            return sign &amp;lt; 0;
        }
    }

    BigIntSimple &amp;amp;operator=(int n) {
        v.clear();
        sign = n &amp;gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty()) v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;amp;operator=(const std::string &amp;amp;s) {
        set(s.c_str());
        return *this;
    }

    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign) return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &amp;lt; b.v.size()) r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &amp;lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;amp;&amp;amp; i &amp;lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &amp;gt;&amp;gt; 31);
            carry = (carry &amp;gt;&amp;gt; 31) + 1;
        }
        //处理升位进位
        if (carry) r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;amp;subtract(const BigIntSimple &amp;amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &amp;gt;&amp;gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }

    BigIntSimple operator*(const BigIntSimple &amp;amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &amp;lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        r.sign = sign * b.sign;
        return r;
    }

    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;amp;sub_mul(const BigIntSimple &amp;amp;b, int mul, int offset) {
        if (mul == 0) return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &amp;lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }

    BigIntSimple div_mod(const BigIntSimple &amp;amp;b, BigIntSimple &amp;amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&amp;lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&amp;lt;=131072时可用（受double的精度限制）
        //能保证估计结果q&#39;与实际结果q的关系满足q&#39;&amp;lt;=q&amp;lt;=q&#39;+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                   (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &amp;lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &amp;lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;amp;b) const {
        return *this - *this / b * b;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;经测试，这个实现在1秒内可以计算出30000阶乘，而计算10000阶乘不到0.1秒，附上求阶乘的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BigIntSimple fac(int start, int n) {
    if (n &amp;lt; 16) {
        BigIntSimple s = 1;
        for (int i = start; i &amp;lt; start + n; ++i)
            s = BigIntSimple(i) * s;
        return s;
    }
    int m = (n + 1) / 2;
    return fac(start, m) * fac(start + m, n - m);
}

int main() {
    int n;
    while (cin &amp;gt;&amp;gt; n) {
        cout &amp;lt;&amp;lt; fac(1, n).to_str() &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在hdu oj 1042上，&lt;a href=&#34;https://vjudge.net/solution/29867142&#34; target=&#34;_blank&#34;&gt;以171ms通过&lt;/a&gt;，在提交记录里面，超过了大部分其它提交。当然这还不是极限。&lt;/p&gt;

&lt;p&gt;对于除法，2n/n所需要时间与n*n所需时间比大约是1.5（n是位数），不同编译器这个比值稍有不同。&lt;/p&gt;

&lt;p&gt;本基础篇就介绍到这里，后文将介绍乘法和除法的优化。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
