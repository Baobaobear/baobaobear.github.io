<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>排序 | Baobaobear</title>
    <link>/tags/%E6%8E%92%E5%BA%8F/</link>
      <atom:link href="/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" />
    <description>排序</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 21 Oct 2019 17:32:00 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>排序</title>
      <link>/tags/%E6%8E%92%E5%BA%8F/</link>
    </image>
    
    <item>
      <title>Quick sort(快速排序)杂谈 3</title>
      <link>/post/20191019-qsort-talk-3/</link>
      <pubDate>Mon, 21 Oct 2019 17:32:00 +0800</pubDate>
      <guid>/post/20191019-qsort-talk-3/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;/post/20191007-qsort-talk-2/&#34;&gt;上一篇&lt;/a&gt;我们介绍了快排的各种优化，最后得到了一个超越VS的STL std::sort实现的版本，这回我们来讲讲怎么折磨gcc的std::sort。&lt;/p&gt;

&lt;h2 id=&#34;gcc的实现&#34;&gt;GCC的实现&lt;/h2&gt;

&lt;p&gt;这个我直接给个&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/gcc-8-branch/libstdc++-v3/include/bits/stl_algo.h#L1896&#34; target=&#34;_blank&#34;&gt;github来源&lt;/a&gt;，链接里是gcc8分支的实现源码，我已经通过链接标记出第1896行，那里就是&lt;code&gt;__unguarded_partition&lt;/code&gt;函数的实现，就是快排的划分函数，而在后面几个函数就是快排的本体了。为了避免它代码更新导致位置变化，我把相关代码复制过来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
  template&amp;lt;typename _Iterator, typename _Compare&amp;gt;
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
                           _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
        {
          if (__comp(__b, __c))
            std::iter_swap(__result, __b);
          else if (__comp(__a, __c))
            std::iter_swap(__result, __c);
          else
            std::iter_swap(__result, __a);
        }
      else if (__comp(__a, __c))
        std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
        std::iter_swap(__result, __c);
      else
        std::iter_swap(__result, __b);
    }

  /// This is a helper function...
  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
                          _RandomAccessIterator __last,
                          _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
        {
          while (__comp(__first, __pivot))
            ++__first;
          --__last;
          while (__comp(__pivot, __last))
            --__last;
          if (!(__first &amp;lt; __last))
            return __first;
          std::iter_swap(__first, __last);
          ++__first;
        }
    }

  /// This is a helper function...
  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
                                _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                                  __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline void
    __partial_sort(_RandomAccessIterator __first,
                   _RandomAccessIterator __middle,
                   _RandomAccessIterator __last,
                   _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }

  /// This is a helper function for the sort routine.
  template&amp;lt;typename _RandomAccessIterator, typename _Size, typename _Compare&amp;gt;
    void
    __introsort_loop(_RandomAccessIterator __first,
                     _RandomAccessIterator __last,
                     _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first &amp;gt; int(_S_threshold))
        {
          if (__depth_limit == 0)
            {
              std::__partial_sort(__first, __last, __last, __comp);
              return;
            }
          --__depth_limit;
          _RandomAccessIterator __cut =
            std::__unguarded_partition_pivot(__first, __last, __comp);
          std::__introsort_loop(__cut, __last, __depth_limit, __comp);
          __last = __cut;
        }
    }

  // sort

  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Compare __comp)
    {
      if (__first != __last)
        {
          std::__introsort_loop(__first, __last,
                                std::__lg(__last - __first) * 2,
                                __comp);
          std::__final_insertion_sort(__first, __last, __comp);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;吐槽一句，连gcc源代码也把tab和空格混合使用我也是醉了，源代码的tab在这里已替换为空格以保证版面一致&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;这里我们并不需要关注太多东西，在上一篇我们讲到过，快排最大的弱点正在于它的划分元素选择上，所以我们只需要看这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  template&amp;lt;typename _RandomAccessIterator, typename _Compare&amp;gt;
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
                                _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                                  __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数从&lt;code&gt;__first + 1&lt;/code&gt;, &lt;code&gt;__mid&lt;/code&gt;, &lt;code&gt;__last - 1&lt;/code&gt;三个数里面，取一个中位数交换到&lt;code&gt;__first&lt;/code&gt;的位置，知道这个就能想办法生成对抗数据了。为了让它运行缓慢，那么只要让它这个函数每次都选到&lt;strong&gt;第二小&lt;/strong&gt;的元素放最左边，这样每次调用&lt;code&gt;__unguarded_partition&lt;/code&gt;的结果，就是把划分点划分到了&lt;code&gt;__first + 2&lt;/code&gt;的位置上，即每次只划分两个元素，这就是它的最坏情况。&lt;/p&gt;

&lt;p&gt;构造这个东西需要一些技巧，我们要模拟std::sort的过程，但为了复杂性降低，我们令最右边元素值最大，那么中位数必定在&lt;code&gt;__first + 1&lt;/code&gt;与&lt;code&gt;__mid&lt;/code&gt;中选出，这样在partition过程中就能保证不会动到最后的元素，只会在这两个之间换来换去。然后我们只模拟出交换的结果，而不必去遍历，否则你生成的复杂度就$O(n^2)$了。&lt;/p&gt;

&lt;p&gt;另外，还要注意的一点是，它使用的是&lt;code&gt;intro sort&lt;/code&gt;来实现，也就是说深度到一定程度后，会转化为堆排序，而堆排序的最坏情况是乱序数组，我们不必一直这么做，否则堆排序时间并不是最长的，我们只要弄深度150的就够用了。我们来看看生成的数据在8000000长度下，使用mingw64-gcc8编译参数-O3的实测结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;evil&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;intro_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;76&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;82&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;509&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;510&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;510&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;282&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;92&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;94&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;473&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;487&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1650&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;480&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::heap&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;584&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;369&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;421&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1436&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1467&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1499&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;962&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;第4、5列是随机打乱的数据，作为对比组，而evil列就是生成的对抗数据，我把&lt;code&gt;heap sort&lt;/code&gt;及前一篇的&lt;code&gt;intro_sort&lt;/code&gt;实现放上来做比较，可以看出在这组数据下，&lt;code&gt;std::sort&lt;/code&gt;必然地比堆排序还要慢，是乱序数据的3.5倍左右，当然这个时间完全取决于堆排序的时间。&lt;/p&gt;

&lt;p&gt;附上生成代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct save_index
{
    int val;
    int index;

    save_index(int i = 0, int v = -1)
        : val(v)
        , index(i)
    {}
    void swap(save_pos&amp;amp; p)
    {
        int t = p.val;
        p.val = val;
        val = t;
    }
    bool operator &amp;lt; (const save_index&amp;amp; p) const
    {
        return index &amp;lt; p.index;
    }
};

void qsort_sim_gcc(save_index * beg, save_index * end, int max_round)
{
    int cur_num = 0;
    if ((end-1)-&amp;gt;val == -1)
    {
        (end - 1)-&amp;gt;val = (end - beg) * 2;
    }
    while (beg + 1 &amp;lt; end &amp;amp;&amp;amp; --max_round &amp;gt; 0)
    {
        save_index *l = beg + 1, *r = end - 1, *m = beg + (end - beg) / 2;

        if (l-&amp;gt;val == -1)
            l-&amp;gt;val = ++cur_num;
        if (r-&amp;gt;val == -1)
            r-&amp;gt;val = ++cur_num;
        if (m-&amp;gt;val == -1)
            m-&amp;gt;val = ++cur_num;

        if (l-&amp;gt;val &amp;gt; m-&amp;gt;val)
        {
            if (m-&amp;gt;val &amp;gt; r-&amp;gt;val)
                std::swap(*beg, *m);
            else if (l-&amp;gt;val &amp;gt; r-&amp;gt;val)
                std::swap(*beg, *r);
            else
                std::swap(*beg, *l);
        }
        else
        {
            if (m-&amp;gt;val &amp;lt; r-&amp;gt;val)
                std::swap(*beg, *m);
            else if (l-&amp;gt;val &amp;gt; r-&amp;gt;val)
                std::swap(*beg, *l);
            else
                std::swap(*beg, *r);
        }
        if (l-&amp;gt;val &amp;lt; beg-&amp;gt;val &amp;amp;&amp;amp; l-&amp;gt;val != -1)
            ;
        else if (m-&amp;gt;val &amp;lt; beg-&amp;gt;val &amp;amp;&amp;amp; m-&amp;gt;val != -1)
            std::swap(*l, *m);
        beg += 2;
    }
}

void anti_qsort_gen_gcc(std::vector&amp;lt;save_index&amp;gt;&amp;amp; vec, size_t len, int max_round)
{
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        vec.push_back(save_index((int)i));
    }
    qsort_sim_gcc(&amp;amp;*vec.begin(), &amp;amp;*vec.begin() + len, max_round);
    int cnt = 0;
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        if (vec[i].val == -1)
            ++cnt;
    }
    std::vector&amp;lt;int&amp;gt; val_list(cnt);
    for (int i = 0; i &amp;lt; cnt; ++i)
    {
        val_list[i] = i + len - cnt;
    }
    // 以下 random_shuffle 实现需要自己实现，如果你用的是mingw
    // 不能使用std::random_shuffle，注意
    random_shuffle(val_list.begin(), val_list.end());
    for (int i = 0, j = 0; i &amp;lt; len; ++i)
    {
        if (vec[i].val == -1)
        {
            vec[i].val = val_list[j++];
        }
    }
    std::sort(vec.begin(), vec.end());
}

void anti_qsort_gen_gcc(sort_element_t arr[], size_t len)
{
    std::vector&amp;lt;save_index&amp;gt; vec;
    anti_qsort_gen_gcc(vec, len, 150);
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        arr[i] = vec[i].val;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中注释的random_shuffle问题参见&lt;a href=&#34;../20191006-mingw-bug/&#34;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后总结，老实加个rand比啥都强，至少大大增加构造evil数据的难度，也大大降低遇到最坏情况的可能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Quick sort(快速排序)杂谈 2</title>
      <link>/post/20191019-qsort-talk-2/</link>
      <pubDate>Sat, 19 Oct 2019 00:57:00 +0800</pubDate>
      <guid>/post/20191019-qsort-talk-2/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;/post/20191007-qsort-talk-1/&#34;&gt;上一篇&lt;/a&gt;我们介绍了四种不同的划分算法，现在我们来针对&lt;a href=&#34;/post/20191007-qsort-talk-1/#3-hoare-partition-scheme&#34;&gt;Hoare partition scheme&lt;/a&gt;来讲解一些优化和注意的问题。&lt;/p&gt;

&lt;h2 id=&#34;最坏时间复杂度的优化&#34;&gt;最坏时间复杂度的优化&lt;/h2&gt;

&lt;p&gt;在前一篇的示例代码里面，只是最简单地选择的最开头或最后面的元素作为划分，这对于乱序的数据还好，对于有序的数据这么做，时间复杂度就直接变成$O(n^2)$了，那么怎么解决？第一个要解决的反而不是划分元素的选择上，而是改成&lt;code&gt;intro sort&lt;/code&gt;，记录递归深度或类似的办法，到达限制条件的时候改而使用堆排序，这属于混合排序，先让排序的最坏时间复杂度降下来是第一要务。所以可以改写出以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    sort_element_t *l = beg, *r = end - 1;
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}

void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 1)
        return;

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    intro_sort_recursive(p + 1, end, depth - 1);
}

void intro_sort(sort_element_t * beg, sort_element_t * end)
{
    int depth = (int)(log(end - beg) * 2.5);
    intro_sort_recursive(beg, end, depth);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，这份代码使用的分割结果是&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;左&lt;/th&gt;
&lt;th&gt;中&lt;/th&gt;
&lt;th&gt;右&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;至于为什么选择这种划分结果，与后面的优化有关系。&lt;/p&gt;

&lt;h2 id=&#34;划分元素的选择&#34;&gt;划分元素的选择&lt;/h2&gt;

&lt;p&gt;好，我们从这个代码开始重新谈一下分割元素的选取，网上常见有以下方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;固定选择最开头或最后一个&lt;/li&gt;
&lt;li&gt;固定选择中间的元素&lt;/li&gt;
&lt;li&gt;随机选择元素&lt;/li&gt;
&lt;li&gt;在开头、中间、末尾固定三个数里选择一个中位数&lt;/li&gt;
&lt;li&gt;在更多的数里面找中位数，同样是固定选择&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，我们能显然地排除第一个，它对已排序或接近排序完成的数据效率特别低，所以，接下来我们的思路就是分别针对这些选择方案看看有哪些情况让它们特别低效。&lt;/p&gt;

&lt;p&gt;那么按这个思路，我样再来考虑一下，如果要排序的数据重复元素特别的多，甚至于所有元素都相等呢？这时候你会发现不管哪种选取方案都没有用，都会陷入最坏情况，所以我们接下来在继续研究分割元素的选取之前，先考虑重复元素的问题。&lt;/p&gt;

&lt;h2 id=&#34;重复元素的过滤&#34;&gt;重复元素的过滤&lt;/h2&gt;

&lt;p&gt;之所以分割方式使用上文那种，为的就是能更方便地过滤重复元素，大于等于分割元素的，都一定在分割位置的右边，所以&lt;code&gt;intro_sort_recursive&lt;/code&gt;函数可以这样改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 1)
        return;

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    for (++p; p &amp;lt; end &amp;amp;&amp;amp; !(p[-1] &amp;lt; *p || *p &amp;lt; p[-1]); )
        ++p;
    intro_sort_recursive(p, end, depth - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;!(p[-1] &amp;lt; *p || *p &amp;lt; p[-1])&lt;/code&gt;就是判断&lt;code&gt;p[-1] == *p&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样修改后，在所有元素相等的情况下，时间复杂度能达到$O(n)$&lt;/p&gt;

&lt;h2 id=&#34;再次考虑划分元素的选择&#34;&gt;再次考虑划分元素的选择&lt;/h2&gt;

&lt;p&gt;这次我们把方案一个个来列举优缺点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;固定选择中间的元素，速度快，对有序或逆序的数据分割效率最高，但在中间附近元素都是数据里最大的数据的时候，即遇到最坏情况，会快速退化成堆排序&lt;/li&gt;
&lt;li&gt;在开头、中间、末尾固定三个数里选择一个中位数，这个是也gcc的STL实现，但能构造出让它遇到最坏情况的数据，比乱序数据慢4倍甚至更多&lt;/li&gt;
&lt;li&gt;在更多的数里面找中位数，同样是固定选择，VS的STL实现就是在9个数里面取，但同样能构造出让它遇到最坏情况的数据，比乱序数据慢4倍甚至更多&lt;/li&gt;
&lt;li&gt;随机选择元素，遇到最坏情况机率极低，但对于有序或逆序的数据时间比前三种都会慢一些&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事实上，任何的固定选取方案理论上都能构造出固定的使其遇到最坏的情况，而我们的目标当然是让它减少遇到的机率，所以我推荐增加随机选择在里面，但单纯的随机选择虽然并不太优秀，但已足够实用，而且我们并不需要真的搞什么复杂的随机数，所以我们先来实现这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    static int s_rnd = 0x123456;
    sort_element_t *l = beg, *r = end - 1;
    sort_element_swap(r, l + (++s_rnd % (end - beg)));
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要一个静态的计数器作为随机数其实就足够了，把选中的元素交换到最右边即可。&lt;/p&gt;

&lt;p&gt;那我们还是要考虑优化的话怎么弄呢？那我们结合着来，在三个数里取中位数，不过还要带上随机，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline void make_mid_pivot(sort_element_t* l, sort_element_t* mid, sort_element_t* r)
{
    if (*r &amp;lt; *mid)
    {
        if (*mid &amp;lt; *l)
            return;
        sort_element_swap(mid, r);
    }
    if (*mid &amp;lt; *l)
    {
        sort_element_swap(mid, l);
        if (*r &amp;lt; *mid)
            sort_element_swap(mid, r);
    }
}

sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    static int s_rnd = 0x123456;
    sort_element_t *l = beg, *r = end - 1;
    int half = (end - beg) / 2;
    make_mid_pivot(l + s_rnd % half, l + half, r - s_rnd % half);
    ++s_rnd;
    sort_element_swap(r, l + half);
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这个阶段，这个实现已经能和VS版本的std::sort平起平坐了，接下我们就要超越它&lt;/p&gt;

&lt;h2 id=&#34;小数据优化&#34;&gt;小数据优化&lt;/h2&gt;

&lt;p&gt;当需要排序的数据长度较小的时候，快速排序其实并不快，我们改用插入排序，在16个元素或以下的时候使用。修改的那部分代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 16)
    {
        insert_sort(beg, end);
        return;
    }

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    for (++p; p &amp;lt; end &amp;amp;&amp;amp; !(p[-1] &amp;lt; *p || *p &amp;lt; p[-1]); )
        ++p;
    intro_sort_recursive(p, end, depth - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，已经能比VS的std::sort快了&lt;/p&gt;

&lt;h2 id=&#34;运行测试&#34;&gt;运行测试&lt;/h2&gt;

&lt;p&gt;我们来看在VS2005下对4500000个int排序的测试结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;intro_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;38&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;43&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;282&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;281&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;60&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;103&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;269&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;116&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;327&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;331&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;72&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;85&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;317&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;139&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再看mingw64-gcc9下使用&lt;code&gt;-O3&lt;/code&gt;参数编译，对4500000个int排序的测试结果&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;intro_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;41&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;274&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;281&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;67&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;105&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;266&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;118&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;std::sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;45&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;55&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;254&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;255&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;98&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;82&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;106&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;248&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;125&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看到几乎在所有的测试数据里都比VS的实现快。不过尽管这个比VS的实现快，但比起gcc的实现还是稍差一点点，但已经足够好。&lt;/p&gt;

&lt;p&gt;本篇就介绍到这里了，最后把优化后的完整代码给出，更多优化请看下一篇文章&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline void make_mid_pivot(sort_element_t* l, sort_element_t* mid, sort_element_t* r)
{
    if (*r &amp;lt; *mid)
    {
        if (*mid &amp;lt; *l)
        {
            return;
        }
        sort_element_swap(mid, r);
    }
    if (*mid &amp;lt; *l)
    {
        sort_element_swap(mid, l);
        if (*r &amp;lt; *mid)
            sort_element_swap(mid, r);
    }
}

sort_element_t* intro_sort_partition(sort_element_t * beg, sort_element_t * end)
{
    static int s_rnd = 0x123456;
    sort_element_t *l = beg, *r = end - 1;
    int half = (end - beg) / 2;
    make_mid_pivot(l + s_rnd % half, l + half, r - s_rnd % half);
    ++s_rnd;
    sort_element_swap(r, l + half);
    sort_element_t pivot = *r;
    while (1)
    {
        while (l &amp;lt; r &amp;amp;&amp;amp; *l &amp;lt; pivot)
            ++l;
        while (l &amp;lt; r &amp;amp;&amp;amp; !(*r &amp;lt; pivot))
            --r;
        if (l &amp;gt;= r)
            break;
        sort_element_swap(l++, r);
    }
    sort_element_swap(l, end - 1);
    return l;
}

void intro_sort_recursive(sort_element_t * beg, sort_element_t * end, int depth)
{
    if (end - beg &amp;lt;= 16)
    {
        insert_sort(beg, end);
        return;
    }

    if (depth &amp;lt;= 0)
    {
        heap_sort(beg, end);
        return;
    }

    sort_element_t *p = intro_sort_partition(beg, end);

    intro_sort_recursive(beg, p, depth - 1);
    for (++p; p &amp;lt; end &amp;amp;&amp;amp; !(p[-1] &amp;lt; *p || *p &amp;lt; p[-1]); )
        ++p;
    intro_sort_recursive(p, end, depth - 1);
}

void intro_sort(sort_element_t * beg, sort_element_t * end)
{
    int depth = (int)(log(end - beg) * 2.5);
    intro_sort_recursive(beg, end, depth);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>smooth sort与weakheap sort实现</title>
      <link>/post/20191017-weakheapsort/</link>
      <pubDate>Thu, 17 Oct 2019 17:14:00 +0800</pubDate>
      <guid>/post/20191017-weakheapsort/</guid>
      <description>&lt;p&gt;本篇补充&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;，不打算做太多介绍，&lt;del&gt;因为自己太菜不会讲，&lt;/del&gt;只作为笔记来记录一下实现代码。&lt;code&gt;smooth sort&lt;/code&gt;在接近排序完成的情况下的动态图&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Smoothsort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/a/a5/Smoothsort.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;smooth-sort&#34;&gt;smooth sort&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// http://www.keithschwarz.com/smoothsort/
static const unsigned int leonardo[] =
{
   1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973,
   3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049, 242785,
   392835, 635621, 1028457, 1664079, 2692537, 4356617, 7049155, 11405773,
   18454929, 29860703, 48315633, 78176337, 126491971, 204668309, 331160281,
   535828591, 866988873, 1402817465, 2269806339u, 3672623805u,
};

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void smooth_sort_fix(RandomAccessIterator arr, size_t current_heap, int level_index, int levels[], Comp compare)
{
    while (level_index &amp;gt; 0)
    {
        size_t prev_heap = current_heap - leonardo[levels[level_index]];
        if (compare(arr[current_heap], arr[prev_heap]))
        {
            if (levels[level_index] &amp;gt; 1)
            {
                size_t child_heap2 = current_heap - 1;
                size_t child_heap1 = child_heap2 - leonardo[levels[level_index] - 2];
                if (compare(arr[prev_heap], arr[child_heap1])
                    || compare(arr[prev_heap], arr[child_heap2]))
                    break;
            }
            std::swap(arr[current_heap], arr[prev_heap]);
            current_heap = prev_heap;
            level_index -= 1;
        }
        else
            break;
    }

    int current_level = levels[level_index];
    while (current_level &amp;gt; 1)
    {
        size_t max_child = current_heap;
        size_t child_heap2 = current_heap - 1;
        size_t child_heap1 = child_heap2 - leonardo[current_level - 2];

        if (compare(arr[max_child], arr[child_heap1])) max_child = child_heap1;
        if (compare(arr[max_child], arr[child_heap2])) max_child = child_heap2;
        if (max_child == child_heap1)
        {
            std::swap(arr[current_heap], arr[child_heap1]);
            current_heap = child_heap1;
            current_level -= 1;
        }
        else if (max_child == child_heap2)
        {
            std::swap(arr[current_heap], arr[child_heap2]);
            current_heap = child_heap2;
            current_level -= 2;
        }
        else break;
    }
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void smooth_sort(RandomAccessIterator arr, size_t size, Comp compare)
{
    int levels[64] = { 1 };
    int toplevel = 0;

    for (size_t i = 1; i &amp;lt; size; ++i)
    {
        if (toplevel &amp;gt; 0 &amp;amp;&amp;amp; levels[toplevel - 1] - levels[toplevel] == 1)
        {
            toplevel -= 1;
            levels[toplevel] += 1;
        }
        else if (levels[toplevel] != 1)
        {
            toplevel += 1;
            levels[toplevel] = 1;
        }
        else
        {
            toplevel += 1;
            levels[toplevel] = 0;
        }
        smooth_sort_fix(arr, i, toplevel, levels, compare);
    }

    for (size_t i = size - 2; i &amp;gt; 0; --i)
    {
        if (levels[toplevel] &amp;lt;= 1)
        {
            toplevel -= 1;
        }
        else
        {
            levels[toplevel] -= 1;
            levels[toplevel + 1] = levels[toplevel] - 1;
            toplevel += 1;

            smooth_sort_fix(arr, i - leonardo[levels[toplevel]], toplevel - 1, levels, compare);
            smooth_sort_fix(arr, i, toplevel, levels, compare);
        }
    }
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void smooth_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        smooth_sort(&amp;amp;*beg, (size_t)(end - beg), compare);
    }
}

template&amp;lt;typename RandomAccessIterator&amp;gt;
void smooth_sort(RandomAccessIterator beg, RandomAccessIterator end)
{
    smooth_sort(beg, end, std::less&amp;lt;typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;weakheap-sort&#34;&gt;weakheap sort&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;unsigned char weakheap_getflag(unsigned char *r, size_t index)
{
    return (r[index &amp;gt;&amp;gt; 3] &amp;gt;&amp;gt; (index &amp;amp; 7)) &amp;amp; 1;
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void weakheap_merge(unsigned char flags[], RandomAccessIterator beg, RandomAccessIterator i, RandomAccessIterator j, Comp compare)
{
    if (compare(*i, *j))
    {
        flags[(j - beg) &amp;gt;&amp;gt; 3] ^= 1 &amp;lt;&amp;lt; ((j - beg) &amp;amp; 7);
        std::swap(*i, *j);
    }
}

template&amp;lt;typename RandomAccessIterator, class Comp&amp;gt;
void weakheap_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        size_t n = (size_t)(end - beg);
        unsigned char * flags = new unsigned char[(n + 7) / 8];
        for (size_t i = 0; i &amp;lt; n / 8; ++i)
            flags[i] = 0;
        for (size_t i = n - 1; i &amp;gt; 0; --i)
        {
            size_t j = i;
            while ((j &amp;amp; 1) == weakheap_getflag(flags, j &amp;gt;&amp;gt; 1))
                j &amp;gt;&amp;gt;= 1;
            weakheap_merge(flags, beg, beg + (j &amp;gt;&amp;gt; 1), beg + i, compare);
        }
        for (size_t i = n - 1; i &amp;gt; 1; --i)
        {
            std::swap(*beg, *(beg + i));
            size_t j = 1, k;
            while ((k = 2 * j + weakheap_getflag(flags, j)) &amp;lt; i)
                j = k;
            while (j &amp;gt; 0)
            {
                weakheap_merge(flags, beg, beg, beg + j, compare);
                j &amp;gt;&amp;gt;= 1;
            }
        }
        std::swap(*beg, *(beg + 1));
        delete[] flags;
    }
}

template&amp;lt;typename RandomAccessIterator&amp;gt;
void weakheap_sort(RandomAccessIterator beg, RandomAccessIterator end)
{
    weakheap_sort(beg, end, std::less&amp;lt;typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>堆排序优化思路</title>
      <link>/post/20191015-sorting-3/</link>
      <pubDate>Tue, 15 Oct 2019 20:52:52 +0800</pubDate>
      <guid>/post/20191015-sorting-3/</guid>
      <description>&lt;p&gt;堆排序其实是最不好优化的一个，在数据结构都确定的情况下，优化空间太小，除非优化数据结构本身，但那样就不叫做堆排序了。类似堆排序的还有&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;，有兴趣可以自己查找相关资料。&lt;/p&gt;

&lt;h2 id=&#34;堆排序原理&#34;&gt;堆排序原理&lt;/h2&gt;

&lt;p&gt;堆排序其实是选择排序的优化变种，选择排序是把最大或最小的元素放到最边上，然后不断重复以上过程，堆排序也是如此，只不过堆排序通过构建数据结构，让查找最大或最小元素并放到最边上的速度比选择排序快得多。&lt;/p&gt;

&lt;p&gt;首先我们先来介绍什么是堆。堆只是个缩写，全名是二叉堆，是一种完全二叉树，它的特点是二叉堆的父节点元素不小于子节点的元素，以下为二叉堆例图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
30--&amp;gt;29
30--&amp;gt;28
29--&amp;gt;24
29--&amp;gt;25
28--&amp;gt;26
28--&amp;gt;22
24--&amp;gt;21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根节点是最大值的时候，就叫做最大堆，反之叫做最小堆。之所以使用完全二叉堆，是为了它能直接放到数组里，例如上图放数组里的结果是：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看出，就是按层序遍历的结果。这样表示的好处是，可以通过下标的简单运算得到子节点的下标，我们通过简单找规律就能发现，下标k的子节点是2k+1和2k+2，所以我们能直接在数组里组织一个二叉堆。而且堆的根节点就是最值，找最值的时间复杂度是O(1)&lt;/p&gt;

&lt;p&gt;那么假如堆结构已经组织好了，我们接下来看怎么排序，还是以刚刚的数组作为例子，下标0就是最大值，那么我们就把它拿出来，与最右边元素交换，得到&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;30&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指针&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下标7的是已经排好的，后面不管它。这时候堆的性质破坏了，我们要去修正，指针r的子结点分别是a和b，在r,a,b中找出最大的元素a与r交换，得到&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;再继续操作&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这时候，指针r已经没有子结点，这时候堆就修正好了。这个过程由于是从根向叶子的操作，叫做shiftdown，还有一种相反的过程叫做shiftup，就是从叶子向根的方向操作。以上就是一轮完整的操作，包括交换最值，修正堆两步。不断循环以上操作直到所有元素有序即可。&lt;/p&gt;

&lt;p&gt;排序方法说完了，我们回头来说怎么构建堆。用shiftup法描述起来比较简单，一开始，只看下标0，那一个元素就肯定是堆。然后添加一个元素在最末，然后shiftup，修改新添加的元素，如此循环。伪代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;makeheap(arr, len)
    for i in (1, len)
        shiftup(arr, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而使用shiftdown的话，原理一样，只是换一个方向&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;makeheap(arr, len)
    for i in (len / 2, 1)
        shiftdown(arr, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下为完整动态图演示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Heapsort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;堆排序基本实现&#34;&gt;堆排序基本实现&lt;/h2&gt;

&lt;p&gt;以下shiftdown实现的函数名是max_heapify&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void max_heapify(sort_element_t arr[], size_t index, size_t length)
{
    size_t child;
    sort_element_t temp = arr[index];
    for (; (child = 2 * index + 1) &amp;lt; length; index = child)
    {
        if (child + 1 &amp;lt; length &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1])
            ++child;
        if (temp &amp;lt; arr[child])
            arr[index] = arr[child];
        else
            break;
    }
    arr[index] = temp;
}

void heap_sort(sort_element_t arr[], size_t length)
{
    if (length &amp;gt; 1)
    {
        for (size_t i = length / 2; i-- &amp;gt; 0; )
            max_heapify(arr, i, length);
        for (size_t i = length - 1; i &amp;gt; 0; --i)
        {
            sort_element_swap(&amp;amp;arr[0], &amp;amp;arr[i]);
            max_heapify(arr, 0, i);
        }
    }
}

void heap_sort(sort_element_t* beg, sort_element_t* end)
{
    heap_sort(beg, end - beg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;堆排序-优化&#34;&gt;堆排序&amp;rdquo;优化&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;我们来重新看原来的表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里下标k的子节点是2k+1和2k+2，运算起来麻烦，那我们如果把所有的下标加1，得到&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这时候，下标k的子节点是2k和2k+1，能减少一步加法运算&lt;/p&gt;

&lt;p&gt;所以可以得到以下模板代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void max_heapify(RandomAccessIterator arr, size_t index, size_t last, Comp compare)
{
    typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type temp = arr[index];
    size_t child;
    for (; (child = index &amp;lt;&amp;lt; 1) &amp;lt;= last; index = child)
    {
        if (child &amp;lt; last &amp;amp;&amp;amp; compare(*(arr + child), *(arr + child + 1)))
            ++child;
        if (compare(temp, *(arr + child)))
            *(arr + index) = *(arr + child);
        else
            break;
    }
    *(arr + index) = temp;
}

template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void heap_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        size_t length = (size_t)(end - beg);
        RandomAccessIterator parr = beg - 1;
        for (size_t i = length / 2; i &amp;gt; 0; --i)
            max_heapify_1(parr, i, length, compare);
        for (size_t i = length - 1; i &amp;gt; 0; --i)
        {
            std::swap(*beg, *(beg + i));
            max_heapify_1(parr, 1, i, compare);
        }
    }
}

template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void heap_sort(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    heap_sort(beg, end, compare);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，还是那句但是，这些所谓的优化到了不同编译器的手上结果可能会和你想象的不一样。这个在VS上是有效果的，但不幸的是这份代码在GCC下跑得并没有比原来的快，不过在GCC上办法还是有的，就是把下标操作全部换成指针，见代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void max_heapify_p(RandomAccessIterator first, RandomAccessIterator target, RandomAccessIterator last, Comp compare)
{
    typename std::iterator_traits&amp;lt;RandomAccessIterator&amp;gt;::value_type temp = *target;
    --first;
    RandomAccessIterator son;
    for (; (son = target + (target - first)) &amp;lt;= last; target = son)
    {
        if (son &amp;lt; last &amp;amp;&amp;amp; compare(*son, *(son + 1)))
            ++son;
        if (compare(temp, *son))
            *target = *son;
        else
            break;
    }
    *target = temp;
}

template &amp;lt;class RandomAccessIterator, class Comp&amp;gt;
void heap_sort_p(RandomAccessIterator beg, RandomAccessIterator end, Comp compare)
{
    if (end - beg &amp;gt; 1)
    {
        for (RandomAccessIterator i = beg + (end - beg) / 2; i &amp;gt;= beg; --i)
            max_heapify_p(beg, i, end - 1, compare);
        for (; --end &amp;gt; beg; )
        {
            std::swap(*beg, *end);
            max_heapify_p(beg, beg, end - 1, compare);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这份代码比GCC STL中的make_heap/sort_heap实现来得快一些。完整实现可以参见我的&lt;a href=&#34;https://github.com/Baobaobear/sort&#34; target=&#34;_blank&#34;&gt;sort项目&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;堆排序其它注意问题&#34;&gt;堆排序其它注意问题&lt;/h2&gt;

&lt;p&gt;堆排序在特殊情况下是能以O(n)复杂度完成的，就是当几乎所有元素或所有元素都相等的时候，是可以很快完成的。但是VS和GCC的STL中的堆排序实现面对这种情形时却花费较多的时间，原因是对相等元素的处理上，我们拿最前面的代码作为例子，我们如果改成这样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void max_heapify(sort_element_t arr[], size_t index, size_t length)
{
    size_t child;
    sort_element_t temp = arr[index];
    for (; (child = 2 * index + 1) &amp;lt; length; index = child)
    {
        if (child + 1 &amp;lt; length &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1])
            ++child;
        if (temp &amp;lt;= arr[child]) // 小于改小于等于
            arr[index] = arr[child];
        else
            break;
    }
    arr[index] = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void max_heapify(sort_element_t arr[], size_t index, size_t length)
{
    size_t child;
    sort_element_t temp = arr[index];
    for (; (child = 2 * index + 1) &amp;lt; length; index = child)
    {
        if (child + 1 &amp;lt; length &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1])
            ++child;
        if (arr[child] &amp;lt; temp) // 小于才跳出，与前一个等价
            break;
        arr[index] = arr[child];
    }
    arr[index] = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样导致的后果是不存在最优情况下O(n)的时间复杂度。最后再来回应开头的问题，什么很少听说&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;呢？单从时间复杂度其实看不出来不用它们的理由，但真正的问题是时间常数的问题，对普通的乱序数组，&lt;code&gt;smooth sort&lt;/code&gt;和&lt;code&gt;weakheap sort&lt;/code&gt;比&lt;code&gt;heap sort&lt;/code&gt;慢，而且实现更复杂。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>插入排序与希尔排序优化思路</title>
      <link>/post/20191009-sorting-2/</link>
      <pubDate>Thu, 10 Oct 2019 20:52:52 +0800</pubDate>
      <guid>/post/20191009-sorting-2/</guid>
      <description>&lt;p&gt;本篇针对插入排序和希尔排序来讲优化思路，有部分内容因为前一篇文章已经有交代，这里不重复，如果你还没有看，请先看&lt;a href=&#34;../20191008-sorting-1&#34;&gt;前一篇&lt;/a&gt;。我们来看插入排序的动图演示&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Insertion_sort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://github.com/heray1990/AlgorithmVisualization/blob/master/images/insertion_sort_50samples_fps30_dpi50.gif?raw=true&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;插入排序保证前面一块是有序的情况下，新增的一个元素通过向前交换到合适的位置，所以叫做插入排序。&lt;/p&gt;

&lt;h2 id=&#34;插入排序基本实现&#34;&gt;插入排序基本实现&lt;/h2&gt;

&lt;p&gt;我们先来看插入排序的基本实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void insert_sort(sort_element_t * beg, sort_element_t * end)
{
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        sort_element_t val = *i;
        sort_element_t* j = i;
        for (; j &amp;gt; beg &amp;amp;&amp;amp; val &amp;lt; j[-1]; --j)
        {
            *j = j[-1];
        }
        *j = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入排序即使不做任何优化，效率也明显高于上篇所说的冒泡排序和选择排序。那么按照惯例，先上双向看看效果&lt;/p&gt;

&lt;h3 id=&#34;插入排序优化-双向插入&#34;&gt;插入排序优化，双向插入&lt;/h3&gt;

&lt;p&gt;不过双向版本的插入排序可能并不是你想象中那么好写，甚至于有点不太好懂&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void double_insert_sort(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        for (sort_element_t* i = beg + 1, *j = end - 1; ; )
        {
            sort_element_t val = *i;
            sort_element_t* t = i;
            for (; t &amp;gt; beg &amp;amp;&amp;amp; val &amp;lt; t[-1]; --t)
            {
                *t = t[-1];
            }
            *t = val;

            if (++i &amp;gt; j)
            {
                if (*i &amp;lt; *j)
                    ++j;
                else
                    break;
            }

            val = j[-1];
            t = j;
            for (; t &amp;lt; end &amp;amp;&amp;amp; *t &amp;lt; val; ++t)
            {
                t[-1] = *t;
            }
            t[-1] = val;

            if (i &amp;gt; --j)
            {
                if (*j &amp;lt; j[-1])
                    --i;
                else
                    break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;我们来看看测试结果，在 VS2015 下对 45000 个int排序&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;insert2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;376&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;165&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;174&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;176&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;177&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;114&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;insert&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;359&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;165&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;174&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;177&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;192&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;115&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;575&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1259&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1224&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;532&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;855&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;568&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1252&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1474&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1537&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1611&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;642&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;813&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;733&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1068&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;809&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1076&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1082&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1073&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1072&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1074&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1073&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1065&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;939&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1192&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2190&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2220&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2193&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;832&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1376&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2159&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2174&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2157&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2137&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2166&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2160&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2155&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2149&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2146&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2138&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2154&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个优化效果非常不明显，有种吃力不讨好的感觉。那么，我们换个方法，来试试加大步长吧，这个变动让算法有了另一个名字&lt;/p&gt;

&lt;h2 id=&#34;希尔排序&#34;&gt;希尔排序&lt;/h2&gt;

&lt;p&gt;希尔排序的坑特别深，你需要有心理准备。希尔排序和梳排序类似，都是通过使用较大的步长让元素更快速地到达正确位置附近&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Shellsort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过在步长的选择上，希尔排序与梳排序差别巨大。首先梳排序的步长选择较为简单，每次乘以0.8即可，这个数字就不要管怎么来的了，我也不知道。梳排序的研究资料较少，但希尔排序则不一样，步长选择的研究非常多，也就是说光是步长的选择就是一门学问，这就是一个大坑，而且这个步长选择对性能的影响十分明显。我们先来看最早的希尔排序版本，最早的版本使用步长每次乘以0.5。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort_0_5(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        size_t incre = (size_t)(end - beg) / 2;
        for (; incre &amp;gt;= 1; incre /= 2)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后来，Pratt 与 Knuth 改进了新的&lt;a href=&#34;https://oeis.org/A003462&#34; target=&#34;_blank&#34;&gt;步长序列&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;1, 4, 13, 40, 121, ...&lt;/code&gt;&lt;br /&gt;
得到以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        size_t incre = 1;
        while (incre &amp;lt; (size_t)(end - beg - 1) / 3)
            incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973
        for (; incre &amp;gt;= 1; incre /= 3)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多关于步长的研究可以参考&lt;a href=&#34;https://en.wikipedia.org/wiki/Shellsort&#34; target=&#34;_blank&#34;&gt;维基百科&lt;/a&gt;，本篇不对步长做讲解。后文的优化将使用这个版本的代码&lt;/p&gt;

&lt;h3 id=&#34;希尔排序优化-运用带哨兵的插入排序&#34;&gt;希尔排序优化，运用带哨兵的插入排序&lt;/h3&gt;

&lt;p&gt;带哨兵的插入排序是什么东西？其实就是指以下这样的插入排序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void unguarded_insert_sort(sort_element_t * beg, sort_element_t * end)
{
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        sort_element_t val = *i;
        sort_element_t* j = i;
        for (; val &amp;lt; j[-1]; --j)
        {
            *j = j[-1];
        }
        *j = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和前面的插入排序的区别在哪？就是少了&lt;code&gt;j &amp;gt; beg &amp;amp;&amp;amp;&lt;/code&gt;，不做边界判断。不做边界判断确实能运行得更快，但不会越界吗？我们来考虑以下这种情况&lt;br /&gt;
&lt;code&gt;int arr[8] = {-1, 8, 9, 4, 5, 6, 1, 6};&lt;/code&gt;&lt;br /&gt;
然后我们排序的时候写&lt;code&gt;unguarded_insert_sort(arr + 1, arr + 8);&lt;/code&gt;它就能正确排序而且不会发生越界，因为最前面存在比需要排序的元素都要小的数，而那个数就是哨兵，它充当着让内循环退出的作用，也就是说，在调用这个函数的时候，只要保证beg的左边存在比右边都要小的元素就行了。&lt;/p&gt;

&lt;p&gt;有了这个能怎么优化呢？我们把步长1的部分单独拆出来，写成下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort_o1(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        size_t incre = 1;
        while (incre &amp;lt; (size_t)(end - beg - 1) / 3)
            incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973
        for (; incre &amp;gt; 1; incre /= 3)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
        insert_sort(beg, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个能理解吧，步长1的时候完全就是插入排序，但真正厉害的在下面这步，要注意到这种写法在变为步长1之前，它的步长是4，我们可以证明整个数组的最小值一定在前4个数中，即前一个步长的范围内。这里不给出具体证明，有兴趣你可以自己试试证明。有了这个结论，前4个元素用插入排序排好了后，后面的就可以使用&lt;code&gt;unguarded_insert_sort&lt;/code&gt;了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shell_sort_o2(sort_element_t * beg, sort_element_t * end)
{
    if (end - beg &amp;gt; 10)
    {
        size_t incre = 1;
        while (incre &amp;lt; (size_t)(end - beg - 1) / 3)
            incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973
        for (; incre &amp;gt; 1; incre /= 3)
        {
            sort_element_t * bound = beg + incre;
            for (sort_element_t * i = bound; i &amp;lt; end; ++i)
            {
                sort_element_t * p = i;
                sort_element_t val = *i;
                for (; p &amp;gt;= bound &amp;amp;&amp;amp; val &amp;lt; *(p - incre); p -= incre)
                    *p = *(p - incre);
                *p = val;
            }
        }
        insert_sort(beg, beg + 4);
        unguarded_insert_sort(beg + 4, end);
    }
    else
    {
        insert_sort(beg, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个哨兵技巧在其它的排序里面甚至别的问题里同样也会存在。除了这个还有没有别的优化空间呢？例如，shellsort的最优情况下的时间复杂度还是&lt;code&gt;O(nlogn)&lt;/code&gt;，那有没有办法使得最优情况时间复杂度下降到&lt;code&gt;O(n)&lt;/code&gt;呢？确实有办法，如果在某一轮发现没有数进行交换，那么就立即转成带次数限制的插入排序进行尝试，具体请参阅我的&lt;a href=&#34;https://github.com/Baobaobear/sort&#34; target=&#34;_blank&#34;&gt;sort项目&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;测试结果&#34;&gt;测试结果&lt;/h2&gt;

&lt;p&gt;以下是在 VS2015 上对 4,500,000 个int排序的测试&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bao_shell&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;373&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;368&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;148&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;350&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;147&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shell_o2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;68&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;553&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;540&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;187&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;59&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;106&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;216&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shell_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;54&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;563&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;547&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;190&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;67&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;59&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;509&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;222&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shell_0_5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;89&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;606&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;601&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;236&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;82&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;89&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;143&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;572&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;261&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;comb_sort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;166&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;161&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;180&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;492&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;477&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;214&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;171&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;169&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;223&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;478&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;273&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;code&gt;bao_shell&lt;/code&gt;是我在&lt;a href=&#34;https://github.com/Baobaobear/sort&#34; target=&#34;_blank&#34;&gt;sort项目&lt;/a&gt;中写的希尔排序，使用了更优的步长序列，里面包含更多的优化技巧，本篇就不一一介绍了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>选择和冒泡排序优化思路</title>
      <link>/post/20191008-sorting-1/</link>
      <pubDate>Tue, 08 Oct 2019 13:15:36 +0800</pubDate>
      <guid>/post/20191008-sorting-1/</guid>
      <description>&lt;p&gt;本篇针对两种最基本的排序（冒泡、选择）来讲优化思路。越是简单的东西反而可能存在你越想不到的优化点。但是在开始之前，先给不了解的人讲一个设计原则的问题，我们在设计排序接口的时候，最为常见的有&lt;br /&gt;
&lt;code&gt;void sort(type arr[], int len)&lt;/code&gt;&lt;br /&gt;
也许你也见过&lt;br /&gt;
&lt;code&gt;void sort(iter beg, iter end)&lt;/code&gt;&lt;br /&gt;
这时候问题就来了，很多人会错误地把end认为是最后一个元素，其实不然，这两接口可以相互转换，例如我们可以写 &lt;code&gt;sort(arr, arr + len)&lt;/code&gt; ，这样写很自然对不对，但如果你认为end是最后一个元素，那你就不得不改成 &lt;code&gt;sort(arr, arr + len - 1)&lt;/code&gt; 。事实上，这类的接口我们需要一个统一的原则，就是左闭右开区间原则，即beg就是首个元素，而end是最后一个元素+1，即end是作为结束标志，不应该把end算在范围内。接下来下面所有的接口写法，都是以&lt;br /&gt;
&lt;code&gt;void sort(iter beg, iter end)&lt;/code&gt;&lt;br /&gt;
这种方式写的，至于这样写有什么好处，接下来我们就看示例。&lt;/p&gt;

&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/heray1990/AlgorithmVisualization/master/images/selection_sort_50samples_fps30_dpi50.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本实现&#34;&gt;基本实现&lt;/h3&gt;

&lt;p&gt;我们先来看选择排序，因为它编写简单，而且最不容易出错，我们来看以下两种不同的接口写法，我们定义要排序的数据类型名字是&lt;code&gt;sort_element_t&lt;/code&gt;，定义交换函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void sort_element_swap(sort_element_t *x, sort_element_t *y)
{
    sort_element_t t = *x;
    *x = *y;
    *y = t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void select_sort(sort_element_t arr[], size_t len) //方式1
{
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        size_t head = i;
        for (size_t j = i + 1; j &amp;lt; len; ++j)
        {
            if (arr[j] &amp;lt; arr[head])
                head = j;
        }
        sort_element_swap(arr + i, arr + head);
    }
}

void select_sort(sort_element_t * beg, sort_element_t * end) //方式2
{
    for (; beg &amp;lt; end; ++beg)
    {
        sort_element_t* head = beg;
        for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; *head)
                head = i;
        }
        sort_element_swap(beg, head);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就这么一眼看过去，看起来还真差不多，这样，我们再细分一下，选择排序的中间那步，其实就是找一个最小的元素，我们单独提取成一个独立函数再来看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//方式1
size_t find_min(sort_element_t arr[], size_t beg, size_t len)
{
    size_t head = beg;
    for (size_t j = beg + 1; j &amp;lt; len; ++j)
    {
        if (arr[j] &amp;lt; arr[head])
            head = j;
    }
    return head;
}

void select_sort(sort_element_t arr[], size_t len)
{
    for (size_t i = 0; i &amp;lt; len; ++i)
    {
        sort_element_swap(arr + i, arr + find_min(arr, i, len));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//方式2
sort_element_t* find_min(sort_element_t * beg, sort_element_t * end)
{
    sort_element_t* head = beg;
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        if (*i &amp;lt; *head)
            head = i;
    }
    return head;
}

void select_sort(sort_element_t * beg, sort_element_t * end)
{
    for (; beg &amp;lt; end; ++beg)
    {
        sort_element_swap(beg, find_min(beg, end));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细观察一下，是不是第二种写法函数参数统一，而且参数数量少，而且也少了很多不必要的加法运算（像方法一需要写&lt;code&gt;arr + i&lt;/code&gt;这类）。如果你说方法一的find_min参数也可以只写两个，写成&lt;code&gt;find_min(sort_element_t arr[], size_t len)&lt;/code&gt;，那么你在调用的地方将不得不写成&lt;code&gt;find_min(arr + i, len - i)&lt;/code&gt;，这种又加又减在遇到更复杂的情况的时候，更容易把你弄晕出Bug。总之结论是最好把参数写成两个指针（或两个迭代器）的形式，不建议使用数组加长度的形式，STL的接口也全使用迭代器的形式。&lt;/p&gt;

&lt;p&gt;对于这个排序要注意的一点是，有人会写成类似下面的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void select_sort(sort_element_t arr[], size_t len)
{
	for (size_t j = 0; j &amp;lt; len; ++j)
	{
		for (size_t i = j + 1; i &amp;lt; len; ++i)
		{
			if (arr[j] &amp;gt; arr[i])
			{
				sort_element_t t = arr[j];
				arr[j] = arr[i];
				arr[i] = t;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上这种叫做劣化版的选择排序，在大多数的情况下会比前一个方法慢，极端条件下甚至会慢1倍甚至更多&lt;/p&gt;

&lt;p&gt;那说完劣化再讲优化，选择排序的时间复杂度是$O(n^2)$，而且运行时间与原来的排列完全无关。以上的选择排序总是选择小的，那大小一起选呢？能不能起到优化的作用？如果你单纯的多写一个find_max变成双向选择来做，在VS2005下是没有优化效果的，我测试过了。那应该怎么样呢？确实还是双向选择，不过具体实现稍有点不同。&lt;/p&gt;

&lt;h3 id=&#34;优化1-双向选择&#34;&gt;优化1，双向选择&lt;/h3&gt;

&lt;p&gt;这里的实现是一个函数里同时把最大最小一起找，这样减少了一次遍历的过程，时间能减半之余，还有一个非常有用的优化，就是当你发现最大值等于最小值的时候能提前跳出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* find_min_max(
    sort_element_t * beg,
    sort_element_t * end,
    sort_element_t** head_max)
{
    sort_element_t* head = beg;
    *head_max = beg;
    for (sort_element_t* i = beg + 1; i &amp;lt; end; ++i)
    {
        if (*i &amp;lt; *head)
            head = i;
        else if (**head_max &amp;lt; *i)
            *head_max = i;
    }
    return head;
}

void double_select_sort(sort_element_t * beg, sort_element_t * end)
{
    while (end - beg &amp;gt; 1)
    {
        sort_element_t * head_max, * head = find_min_max(beg, end, &amp;amp;head_max);
        if (head_max != head)
        {
            if (head_max == beg)
                head_max = head;
            sort_element_swap(beg++, head);
            sort_element_swap(--end, head_max);
        }
        else
        {
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与选择排序的运行时间比较如下，排序45000个int，编译环境是VS2015，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;834&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1113&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1141&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;981&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2213&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2227&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2241&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2260&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;合理运用双向，效果也往往不错，但是千万要注意，环境不同会导致测试结果不相同，例如你换到mingw上使用-O3编译那么将会是select比select2快，所以上面数据只供参考，具体结果请自己做测试。&lt;/p&gt;

&lt;h3 id=&#34;优化2-数据结构&#34;&gt;优化2，数据结构&lt;/h3&gt;

&lt;p&gt;选择排序的优化主要是在find_min上面，find_min的时间复杂度是$O(n)$，那如果我们通过一些数据结构的组织，例如二叉堆，那么找最大或最小值时间将变成$O(1)$，而维护这个数据结构的代价是$O(logn)$的话，总体时间复杂度将变为$O(nlogn)$，这比起选择排序的$O(n^2)$就是一个巨大的变化，具体内容在之后的 &lt;a href=&#34;/post/20191015-sorting-3/&#34;&gt;堆排序&lt;/a&gt; 篇具体讲解。&lt;/p&gt;

&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/5/54/Sorting_bubblesort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;基本实现-1&#34;&gt;基本实现&lt;/h3&gt;

&lt;p&gt;冒泡排序是我们课本必然介绍的一个排序，相对于选择排序，这种在编写的时候更容易出现逻辑错误，我们先来看典型的实现（双迭代器实现）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(sort_element_t * beg, sort_element_t * end)
{
    for (; beg &amp;lt; end; --end)
    {
        for (sort_element_t * i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-1])
                sort_element_swap(i - 1, i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冒泡排序这种写法，铁定的$O(n^2)$时间没跑，不过好在冒泡排序的优化方法也不少。&lt;/p&gt;

&lt;h3 id=&#34;优化1-提前跳出&#34;&gt;优化1，提前跳出&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(sort_element_t * beg, sort_element_t * end)
{
    for (; beg &amp;lt; end; --end)
    {
        int sorted = 1;
        for (sort_element_t * i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (sorted)
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过sorted变量记录某一轮是不是存在交换，如果没有交换则表明数据已经是有序的，可以提前退出循环。有这个优化对于已经有序的数据，冒泡排序将运行得特别快，即最优情况时间复杂度只有$O(n)$&lt;/p&gt;

&lt;h3 id=&#34;优化2-鸡尾酒排序&#34;&gt;优化2，鸡尾酒排序&lt;/h3&gt;

&lt;p&gt;前面的冒泡写法是单向冒泡，把最大值向最右边移，这回我们做成双向，一边把最大值右移，一边把最小值左移，不过这种方法有另一个命名，叫做鸡尾酒排序&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cocktail_shaker_sort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_anim.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void cocktail_sort(sort_element_t * beg, sort_element_t * end)
{
    while (beg &amp;lt; end)
    {
        int sorted = 1;
        for (sort_element_t * i = beg + 1; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (sorted)
            break;
        --end;

        sorted = 1;
        for (sort_element_t * i = end - 1; i &amp;gt; beg; --i)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (sorted)
            break;
        ++beg;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那改成双向就真的有提升了吗？我们看实测，排序45000个int，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1313&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1502&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1614&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1674&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;836&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;761&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2286&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2329&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2332&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;871&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1459&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1052&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中第4组是乱序无重复数值的数据，最有代表性的一列。从中可以看到，cocktail比起bubble能节省30%的时间&lt;/p&gt;

&lt;p&gt;让我们再脑洞大开，除了可以双向，还有一种对CPU执行有利的优化方式&lt;/p&gt;

&lt;h3 id=&#34;优化3-奇偶排序&#34;&gt;优化3，奇偶排序&lt;/h3&gt;

&lt;p&gt;这种排序的排序方式见下表，假设有8个数，奇数轮比较(1,2), (3,4), (5,6), (7,8)，偶数轮比较(2,3), (4,5), (6,7)，如此循环，直到没有交换为止&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;轮次&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;具体实现代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void odd_even_sort(sort_element_t * beg, sort_element_t * end)
{
    int sorted = 0, last_sorted = 0;
    while (sorted == 0)
    {
        last_sorted = sorted;
        sorted = 1;
        for (sort_element_t * i = beg + 1; i &amp;lt; end; i += 2)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (last_sorted &amp;amp;&amp;amp; sorted)
            break;

        last_sorted = sorted;
        sorted = 1;
        for (sort_element_t * i = beg + 2; i &amp;lt; end; i += 2)
        {
            if (*i &amp;lt; i[-1])
            {
                sort_element_swap(i - 1, i);
                sorted = 0;
            }
        }
        if (last_sorted &amp;amp;&amp;amp; sorted)
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们再脑洞大开，除了比较方向，好像我们有一个条件没有考虑上，就是冒泡排序总是相邻元素的比较，那么如果不相邻地比较呢？&lt;/p&gt;

&lt;h3 id=&#34;优化4-梳排序&#34;&gt;优化4，梳排序&lt;/h3&gt;

&lt;p&gt;通过一开始设置较大的步长，让元素能较快移动，然后逐步减少步长，直到1变成普通的冒泡排序为止。这个方法的优点，就是快，相对前面的方法来说飞快。当然，最后一步你也可以选择不调用冒泡排序，而改调用&lt;code&gt;cocktail_sort&lt;/code&gt;或&lt;code&gt;odd_even_sort&lt;/code&gt;都可以，差别不明显。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Comb_sort&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/46/Comb_sort_demo.gif&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void comb_sort(sort_element_t * beg, sort_element_t * end)
{
    const double shrink_factor = 0.8;
    ptrdiff_t gap = end - beg;
    while (gap &amp;gt; 1)
    {
        if (gap &amp;gt; 1)
        {
            gap = (ptrdiff_t)(gap * shrink_factor);
            if (gap == 10 || gap == 9)
                gap = 11;
        }
        for (sort_element_t * i = beg + gap; i &amp;lt; end; ++i)
        {
            if (*i &amp;lt; i[-gap])
                sort_element_swap(i, i - gap);
        }
    }
    bubble_sort(beg, end);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完整测试&#34;&gt;完整测试&lt;/h2&gt;

&lt;p&gt;在完整测试里你会发现一些和你想象中完全不一样的情况，可不要以为你的“优化”一定就是优化&lt;/p&gt;

&lt;h3 id=&#34;vs2005下的运行时间比较-按avg平均值排序&#34;&gt;VS2005下的运行时间比较（按Avg平均值排序）&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;combsort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;574&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1315&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1315&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1222&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;557&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;878&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;586&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1313&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1502&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1614&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1674&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;836&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;761&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;834&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1113&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1124&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1141&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;981&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2286&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2329&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2332&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;871&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1459&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1052&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2213&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2227&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2241&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2245&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2260&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2238&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果你只测试随机数据，那么排序应该是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;combsort &amp;lt;&amp;lt; select2 &amp;lt; odd_even &amp;lt; cocktail &amp;lt; select &amp;lt; bubble&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;在mingw64-gcc8-下使用-o3-编译-最大优化-的运行时间比较&#34;&gt;在mingw64(gcc8)下使用&lt;code&gt;-O3&lt;/code&gt;编译（最大优化）的运行时间比较&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;combsort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;497&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;497&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;434&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;501&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;501&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;501&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;503&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;502&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;493&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;564&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1311&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1264&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1217&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;562&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;882&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;580&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1242&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1515&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1610&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1677&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;669&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;837&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;755&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;837&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1112&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1113&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1112&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1114&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;974&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1247&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2312&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2332&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2338&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;951&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1455&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1063&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;你可以发现，找最小值过程在mingw64下被特别照顾了一下，结果它比其它的明显要快，你可以从中得知，如果你想在mingw下写出运行得快的双向选择排序，如果你的想法是再写一个&lt;code&gt;find_max&lt;/code&gt;函数，那对不起，这样是没有优化效果的。但这不是全部，还有让你更大跌眼镜的情况。&lt;/p&gt;

&lt;h3 id=&#34;在mingw64-gcc8-下使用-o1-编译-基本优化-的运行时间比较&#34;&gt;在mingw64(gcc8)下使用&lt;code&gt;-O1&lt;/code&gt;编译（基本优化）的运行时间比较&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Avg&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;combsort&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;263&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;375&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;260&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;258&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;255&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;254&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;531&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;255&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;270&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;odd_even&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;597&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1287&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1256&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1204&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1368&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;780&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;649&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cocktail&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1244&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1504&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1594&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1656&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1081&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;815&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;789&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bubble&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1241&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2091&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2117&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2115&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;685&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1247&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;949&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2233&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2233&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2232&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2231&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2232&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2224&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2229&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2225&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2232&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2230&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在双向选择不但最快，而且还比&lt;code&gt;-O3&lt;/code&gt;下的快得多。老实说，会造成这种奇怪的结果，&lt;code&gt;-O1&lt;/code&gt;比&lt;code&gt;-O3&lt;/code&gt;还快的原因还真不要问我，找开发gcc/mingw的开发者。&lt;/p&gt;

&lt;p&gt;最后还是忠告一句，千万不要在一个编译器某个编译参数上看到有优化效果，就以为是事实，优化的坑远比你想象的要来得深，并不是你以为优化了它就一定变快了，编译器和编译参数以及运行环境才是你的老大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Quick sort(快速排序)杂谈 1</title>
      <link>/post/20191007-qsort-talk-1/</link>
      <pubDate>Mon, 07 Oct 2019 14:18:22 +0800</pubDate>
      <guid>/post/20191007-qsort-talk-1/</guid>
      <description>&lt;p&gt;我们现在使用的排序，很大比例在使用quick sort，因为它是平均速度最快的排序，但与此同时它可能也是坑最深的排序，现在我们就来讨论讨论它，因为内容较多，我计划写多篇，本篇是第一篇。&lt;/p&gt;

&lt;h2 id=&#34;快排的思路&#34;&gt;快排的思路&lt;/h2&gt;

&lt;p&gt;我们先来介绍一下快排的思路。快排的思路其实很简单，在数组中选一个元素，我们就称呼这个元素为pivot，通过与这个元素的比较，把数组划分成不比pivot大的在一边，不比pivot小的在另一边，于是就分成了两个更小的数据，对它们分别再排序就行了。但是，这个描述特别的含糊，首先是怎么选中间元素，这里面有很多不同的做法。然后就是划分了，这个划分方法非常的多，水也特别深，这里主要介绍最为常见的划分方法。&lt;/p&gt;

&lt;h2 id=&#34;划分结果分类&#34;&gt;划分结果分类&lt;/h2&gt;

&lt;p&gt;首先，就是划分的结果，划分的结果有什么好讲的呢？其实算法的描述只说了划分成不比pivot大的在一边，不比pivot小的在另一边，并没有说等于的数怎么办。事实上，关键就在等于的数怎么处理，你既可以划在其中一边，也可以两边都有，也可以划成3分，中间那块就是等于pivot的，左边是小于等于，右边是大于等于，三种划分结果都是可以的。但是，不能容许的一种情况是划分后只有一块，例如你选的pivot正好是最小的数，于是划分后，整个数组就一块，全是大于等于pivot的，这样很可能导致无限递归，这次划分也白干了。&lt;/p&gt;

&lt;p&gt;所以很多人单凭算法思路来实现的时候，往往陷入栈溢出异常，其实就是划分结果上出了问题，并没有保证每次划分后，至少划分成两块。&lt;/p&gt;

&lt;h2 id=&#34;划分手段分类&#34;&gt;划分手段分类&lt;/h2&gt;

&lt;p&gt;划分手段的典型方法至少有5种，本篇介绍其中的4种&lt;/p&gt;

&lt;h3 id=&#34;1-lomuto-partition-scheme&#34;&gt;1. Lomuto partition scheme&lt;/h3&gt;

&lt;p&gt;首先我们来看以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t * partition(
    sort_element_t * beg,
    sort_element_t * end)
{
    sort_element_t pivot = *beg;
    sort_element_t * p = beg;
    for (sort_element_t * i = beg + 1; i &amp;lt; end; i++)
    {
        if (*i &amp;lt; pivot)
        {
            sort_element_swap(++p, i);
        }
    }
    sort_element_swap(p, beg);
    return p;
}

void quick_sort_recursive(
    sort_element_t * beg,
    sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        sort_element_t * p = partition(beg, end);
        quick_sort_recursive(beg, p);
        quick_sort_recursive(p + 1, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种划分方法wiki上有描述，叫做 &lt;a href=&#34;https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Lomuto partition scheme&lt;/code&gt;&lt;/a&gt; 它的思路挺好理解，首先p就是划分边界，一开始&lt;code&gt;p = left&lt;/code&gt;，遍历数组，发现比pivot小的，就交换到p的位置，并且p++，那么p左边的就全是比p要小的。而在最后面，把pivot交换到p的位置，所以这个方法期望把数组划分成三块，小于pivot的，等于pivot的，大于等于pivot的，而且能保证至少划分出两块（中间那块等于pivot的一定存在，不过只有一个元素）。这个方法的优点是可以通过简单的修改就变成3路划分（小于、等于、大于三块），缺点是它这种划分方法速度最慢，交换次数较多。&lt;/p&gt;

&lt;h3 id=&#34;2-不知名字的方法&#34;&gt;2. 不知名字的方法&lt;/h3&gt;

&lt;p&gt;这种方法来源不明，如果你知道请告诉我，在我看来有点像 Hoare partition scheme 的变种，来看代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* partition(
    sort_element_t * first,
    sort_element_t * last)
{
    sort_element_t pivot = *first;
    while (first &amp;lt; last)
    {
        while (first &amp;lt; last &amp;amp;&amp;amp; pivot &amp;lt; *last)
            last--;
        *first = *last;
        while (first &amp;lt; last &amp;amp;&amp;amp; pivot &amp;gt;= *first)
            first++;
        *last = *first;
    }
    *first = pivot;
    return first;
}

void quick_sort_recursive(
    sort_element_t * beg,
    sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        sort_element_t* p = partition(beg, end - 1);
        quick_sort_recursive(beg, p);
        quick_sort_recursive(p + 1, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法通过在右边寻找应该放在左边的元素，与pivot交换，然后在左边寻找应该放在右边的元素，再次与pivot交换，这样pivot通过多数交换换到划分位置上。不过上面代码做了一个简单优化，通过赋值而不是直接交换以减少赋值的次数，这种方法在网上非常常见。&lt;/p&gt;

&lt;h3 id=&#34;3-hoare-partition-scheme&#34;&gt;3. Hoare partition scheme&lt;/h3&gt;

&lt;p&gt;后来有个叫做 C.A.R. Hoare 的人发明了这种划分方法，见代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;sort_element_t* partition(
    sort_element_t * first,
    sort_element_t * last)
{
    sort_element_t * begin = first;
    sort_element_t pivot = *first;
    while (first &amp;lt; last)
    {
        while (first &amp;lt; last &amp;amp;&amp;amp; *last &amp;gt;= pivot)
            --last;
        while (first &amp;lt; last &amp;amp;&amp;amp; pivot &amp;gt;= *first)
            ++first;
        if (first &amp;lt; last)
            sort_element_swap(first, last);
    }
    sort_element_swap(first, begin);
    return first;
}

void quick_sort_recursive(
    sort_element_t * beg,
    sort_element_t * end)
{
    if (end - beg &amp;gt; 1)
    {
        sort_element_t* p = partition(beg, end - 1);
        quick_sort_recursive(beg, p);
        quick_sort_recursive(p + 1, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意的是，这个写法和 &lt;a href=&#34;https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme&#34; target=&#34;_blank&#34;&gt;wiki&lt;/a&gt; 上的略有差别。这个方法与前一个的不同点是，通过在左边寻找应该放在右边的元素，而在右边寻找应该放在左边的元素，然后交换。这个方法是以上三种里面速度最快的，但与此同时是坑最多的。例如，原描述是左边找小于，右边找大于的交换，而上面代码的实现是左边找小于等于，右边找大于等于；原描述是先找左边再找右边，上面实现是先找右边再找左边。也就是说，取不取等于号有4种组合，再乘以先左或先右两种，共8种组合，这8种有一些要求pivot取最左边，有一些要求pivot取最右边，有些左右都行，有些pivot任意位置都行。所以当你写这种划分方法的时候，看起来没什么区别的代码，偏偏出现栈溢出各种问题，其实就隐藏在这些细节上。如果你想练习调试的本领，就把这8种组合的划分全写出来，你肯定收获不少。至于哪种组合最佳，我不知道，但我知道最差的组合，就是两边都取等于号的那两种。&lt;/p&gt;

&lt;p&gt;这个写法还有一个四路划分的变种，即先划分成以下这样&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;=&lt;/td&gt;
        &lt;td&gt;&lt;&lt;/td&gt;
        &lt;td&gt;&gt;&lt;/td&gt;
        &lt;td&gt;=&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;划分好后再把两端的相等元素交换到中间得到&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;&lt;/td&gt;
        &lt;td&gt;=&lt;/td&gt;
        &lt;td&gt;&gt;&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;这里不具体展开，有兴趣可以自行实现&lt;/p&gt;

&lt;h3 id=&#34;4-vs-partition-scheme&#34;&gt;4. VS partition scheme&lt;/h3&gt;

&lt;p&gt;之所以这么叫是因为我目前只看到在Visual Studio系列STL的&lt;code&gt;std::sort&lt;/code&gt;是这么写的，这个写成代码有点长，但思路和上面说的四路划分有点类似，这里简单讲讲它的思路。首先pivot选择在中间，形成这样的状态&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;&lt;/td&gt;
        &lt;td&gt;?&lt;/td&gt;
        &lt;td&gt;=&lt;/td&gt;
        &lt;td&gt;?&lt;/td&gt;
        &lt;td&gt;&gt;&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;找到等于的元素就交换到等于那块的旁边扩大它就行了，核心思想就这样，还有很多其它的细节，这里不展开。这种方法网上几乎没有人这么写，因为写起来确实挺麻烦的。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;本篇先介绍到这里，大家写快排练习建议使用 &lt;code&gt;Hoare partition scheme&lt;/code&gt; ，如果你觉得你的能力更好，那你可以写 &lt;code&gt;VS partition scheme&lt;/code&gt; 自己琢磨一下细节问题，相信你是能写出来的。那么下一篇会介绍优化的部分。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
