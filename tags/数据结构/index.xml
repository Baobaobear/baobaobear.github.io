<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 | Baobaobear</title>
    <link>/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <atom:link href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <description>数据结构</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 11 Jan 2021 00:00:00 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>数据结构</title>
      <link>/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    </image>
    
    <item>
      <title>Dancing Links 跳舞链</title>
      <link>/post/20210111-dlx/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210111-dlx/</guid>
      <description>&lt;p&gt;Dancing Links缩写为DLX，其实在竞赛中并不常见，这次会讲这个是因为前一阵子搞拼图写了这个数据结构就顺便写(&lt;del&gt;水&lt;/del&gt;)博客。&lt;/p&gt;

&lt;p&gt;DLX的发明者是高德纳（Donald Knuth），就是那个传说中的《计算机程序设计艺术》（TAOCP）系列书的作者，这里对这个算法做一些比较直观的解释。&lt;/p&gt;

&lt;h2 id=&#34;dlx面向的问题&#34;&gt;DLX面向的问题&lt;/h2&gt;

&lt;p&gt;DLX面向的问题是精确覆盖问题。何谓精确覆盖呢，来看以下这个表格，每一行是一个数组，数组有4个元素，每行的第一列是这个数组的名字&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们的目标是，在这些集合里，挑出几个，例如我们挑a,b,c，那对应位置上的元素相加，于是得到 &lt;code&gt;2 1 0 2&lt;/code&gt;。而我们的目标是，找到一个挑选的方法，使得相加得到 &lt;code&gt;1 1 1 1&lt;/code&gt; 全是1。&lt;/p&gt;

&lt;p&gt;例如说，选 d和g，那么相加正好得到 &lt;code&gt;1 1 1 1&lt;/code&gt; ，这就是其中一个解，这就是精确覆盖问题的直观感知。&lt;/p&gt;

&lt;h2 id=&#34;朴素算法的构思&#34;&gt;朴素算法的构思&lt;/h2&gt;

&lt;p&gt;我们来一把朴素DFS，例如说，先选择了集合a，而集合a在第4列是个1，那么，其它在第4列同样是1的集合之后就不用再看了，把这些行统统删除，在剩下的行中再选取一行，如此递归进行。我们会发现，怎么选取那一行，以及怎么样高效删除和恢复列，对这个搜索过程的效率有着关键性的影响。&lt;/p&gt;

&lt;h2 id=&#34;dlx的数据结构&#34;&gt;DLX的数据结构&lt;/h2&gt;

&lt;p&gt;在学习稀疏矩阵的时候，我们有一个表示稀疏矩阵的数据结构，就是十字链表，十字链表的优点是可以快速删除一行或一列。DLX就是使用十字链表表示这个矩阵。然后就是行的选取方式上，随便选一行目标性不佳。你如果玩过数独，那你可能会感觉这有点像数独，如果某一列，只有一个1，那么对应的含1的行，就确定一定是它了。而如果没有这种情况，我们就去找某一列只有两个1的。换句话来说，我们会从某一列中，含有最少的1的个数的列，来选择含有1的行。&lt;/p&gt;

&lt;p&gt;为了能快速知道某一列的1的数量，那必须增加一个头部记录这个信息。再者，某些列删除后，我们也需要快速找到还没有删除的列，所以之前的表格可以换成以下的表示：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;head&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中，head那一行包含在十字链表内，但不参与覆盖计算，仅用于索引还没有删除的列。而size是一个数组，不在十字链表内。所以列有表头，但行没有，head行是双向链表不循环，末尾元素的right指向空，其它的每一行是一个双向循环链表，而列是双向链表不循环，最底下的元素的down指向空。&lt;/p&gt;

&lt;h2 id=&#34;dlx具体应用之拼图&#34;&gt;DLX具体应用之拼图&lt;/h2&gt;

&lt;p&gt;所谓的精确覆盖其实是一类问题，具体问题有像8皇后问题，伤脑筋13块，智慧珠游戏，数独游戏都是典型的精确覆盖问题。为了方便说明，我们简化成以下问题：&lt;/p&gt;

&lt;p&gt;有一块1x2和2x2的方块，怎么拼成一个3x2的矩形&lt;/p&gt;

&lt;p&gt;这个怎么用DLX来解呢，首先我们要先对这个3x2的矩形编号：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后，给1x2这个方块编号7，2x2这个方块编号8，所以我们有8列。然后穷举每个块可以摆放的位置，每一种情况就作为一行，那位置覆盖的矩形编号就对应十字链表中的列：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;sz&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;前7行就是1x2这个块的所有情况，8和9行就是2x2这个块的所有情况。&lt;/p&gt;

&lt;p&gt;表格做出来了，解法也很简单，看，第8列1的个数最少，那先选第8行，然后删除第8行上是1的所有列，然后只剩下第7行，于是找到第一个解{7,8}。然后第8列如果选另一行，即第9行，然后删除第9行上是1的所有列，然后只剩下第5行，于是找到第二个解{5,9}。于是所有解就都找到了。&lt;/p&gt;

&lt;h2 id=&#34;dlx应用之n皇后问题&#34;&gt;DLX应用之n皇后问题&lt;/h2&gt;

&lt;p&gt;在棋盘上任意位置放一个皇后，相当于同时覆盖了棋盘这一行、这一列、相应的/斜线、相应的\斜线。而n*n的棋盘，有n行n列和2n-1条斜线，所以做成表格将有6n-2列，n^2行，每行恰有4个1。具体表示这里不写了，因为页面宽度不够。&lt;/p&gt;

&lt;h2 id=&#34;dlx应用之数独问题&#34;&gt;DLX应用之数独问题&lt;/h2&gt;

&lt;p&gt;和n皇后问题类似，考虑在某个格子写了一个数k，那么相当于同时覆盖了这一行的数字k，列数字k，这个3x3区域的数字k，所以表格列数是&lt;code&gt;9*9*3&lt;/code&gt;，表格行数是&lt;code&gt;9*9*9&lt;/code&gt;，每一行都恰有3个1。初始化这个表格后，数独问题本身有一些初始数字，我们就根据这些数字，找到它所属的行，把这些行有1的列统统删掉，再执行搜索即可。&lt;/p&gt;

&lt;h2 id=&#34;dlx的剪枝&#34;&gt;DLX的剪枝&lt;/h2&gt;

&lt;p&gt;剪枝有两类，一种是看实际问题需求产生的剪枝，另一类是与具体问题无关可以在DLX上通用的剪枝。&lt;/p&gt;

&lt;h3 id=&#34;通用剪枝&#34;&gt;通用剪枝&lt;/h3&gt;

&lt;p&gt;假如不存在某一行全是1（99.9%的问题都不应该有吧），那这个剪枝就可以使用。在开始DFS搜索之前，我们如果先选定一行，然后把它有1的列删除，然后看有没有列的1的数量为0，如果有，那么这一行一定不可能在解里面，那么就可以把这一行从链表里直接删除干净，这样直到没有这样的无效行再去启动搜索即可。这个剪枝对于规模更大的问题求所有解时，加速效果明显。&lt;/p&gt;

&lt;h3 id=&#34;特定问题的剪枝&#34;&gt;特定问题的剪枝&lt;/h3&gt;

&lt;p&gt;对于矩形拼图，有个很明显的点，就是当你随便发现一个解时，那它翻转、旋转便会得到另外7个解，我们希望可以去掉这些镜像解，只保留本质不同的解。那么，我们可以记录四角的编号，例如矩形是3*3时，它的编号就是1,3,7,9，另外再增加一个字段，记录覆盖这一列的时候是选取的哪一行。这样当我们在搜索的过程中覆盖到这些列的时候，就可以启动单调性剪枝，我们定义1号用的行最小，3号比7号要小，如果与定义的不同，那就可以直接return，这样不但搜索时间减少不少，而且得到本质解的数量，一举两得。&lt;/p&gt;

&lt;h2 id=&#34;原始dlx算法的局限&#34;&gt;原始DLX算法的局限&lt;/h2&gt;

&lt;p&gt;原始DLX算法最害怕的东西有两个，一是有大量的行极相似，二是有大量的行上面1的数量太少（&amp;lt;=2），这对应于具体问题是什么情况呢，例如说我之前博文的Orz14拼图，它不是精确覆盖，但可以转为精确覆盖问题，只需要补上17个1x1方块即可，但是这样的话，DLX的搜索时间是完全不可接受的，这个拼图同时满足了前面的两个条件，因为有大量的块形状完全一样，那么生成的行每行都有另外13行与之极相似，会导致相同的覆盖方式重复搜索，重复量级约 $14!$ ，好像不是特别多，其实要这么想，如果去重复后计算时间要1秒，那不去重复就需要 $14! = 87178291200$ 秒或者说2700多年。另外由于要补上的1x1方块非常多，而这些1x1方块在每一行只有2个1，同样也产生了 $17!$ 的重复，所以原始算法不适合解决这种问题，必须对其进行改进，或更换其它搜索方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>回文树</title>
      <link>/post/20200416-pam/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0800</pubDate>
      <guid>/post/20200416-pam/</guid>
      <description>&lt;p&gt;回文树（EER Tree，Palindromic Tree），有点类似Trie，但它并不是匹配字符串的，很多人称之为回文自动机，但它一点也不像自动机，不过我还是按习惯的来，使用PAM为简称。为了表示一个回文，我们只表示一边的一个单链即可，这时就类似Trie。但不同之处是，回文区分奇数长度和偶数长度，所以这里我们使用两个根，分别来表示奇数长度和偶数长度。所以，在奇数根里，链ba表示aba，而在偶数根里的ba表示abba。&lt;/p&gt;

&lt;p&gt;首先我们来直观地看看PAM的图形化，以下是字符串&lt;code&gt;abcbbc&lt;/code&gt;的PAM&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node0
0--&amp;gt;6((bb))
6--&amp;gt;7((cbbc))
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
4--&amp;gt;5((bcb))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
6-.-&amp;gt;3
5-.-&amp;gt;3
7-.-&amp;gt;4
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实线方向就是子节点方向，虚线是fail指针，指向这个节点最长的回文后缀节点。图有点乱，但又不希望画得过于简单导致说不清楚，将就一下吧。&lt;/p&gt;

&lt;p&gt;为了能顺利构造，每个节点上面要存储以下必要数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;next: 类似Trie，表示子结点的指针，即图上实线&lt;/li&gt;
&lt;li&gt;fail: fail指针，即图上虚线&lt;/li&gt;
&lt;li&gt;len: 这个节点所表示的回文串的长度&lt;/li&gt;
&lt;li&gt;cnt: 这个节点所表示的回文串在原串中出现的次数&lt;/li&gt;
&lt;li&gt;num: 这个节点所表示的回文串中，有多少个后缀也是回文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;构造方法有点类似AC自动机或SAM，它用增量式构造，假设前k个字符已经构造好，最后构造的节点假设是&lt;code&gt;aba&lt;/code&gt;，新加的字符是&lt;code&gt;c&lt;/code&gt;，那么我们通过那个节点，获取长度是3，于是判断一下原字符串在&lt;code&gt;aba&lt;/code&gt;的前面的字符看是不是和新字符一样，如果是，就在它下面新加入节点，否则，就跳到它的fail节点再做相同的判断，其实这个比SAM简单多了。&lt;/p&gt;

&lt;h2 id=&#34;pam构造过程模拟&#34;&gt;PAM构造过程模拟&lt;/h2&gt;

&lt;p&gt;我们使用字符串&lt;code&gt;abcbbc&lt;/code&gt;作为开始，首先先把abc都插入&lt;/p&gt;

&lt;h3 id=&#34;1-插入abc&#34;&gt;1 插入abc&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-再插入b&#34;&gt;2 再插入b&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
4--&amp;gt;5((bcb))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
5-.-&amp;gt;3
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新增加的b构成bcb回文，于是加在c后面，而fail指针的查找，就是从c的fail节点开始，判断那个节点对称的位置是不是新增加的字符b，是的话连上，不是的话再向上一层的fail节点继续找。&lt;/p&gt;

&lt;h3 id=&#34;3-再插入b&#34;&gt;3 再插入b&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
linkStyle default interpolate basis
subgraph root
0-.-&amp;gt;1[-1]
end
subgraph node0
0--&amp;gt;6((bb))
end
subgraph node1
1--&amp;gt;2((a))
1--&amp;gt;3((b))
1--&amp;gt;4((c))
4--&amp;gt;5((bcb))
end
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;0
6-.-&amp;gt;3
5-.-&amp;gt;3
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而最后插入a后的结果和开头的图是相同的，这里不重复了&lt;/p&gt;

&lt;h2 id=&#34;关于节点计数&#34;&gt;关于节点计数&lt;/h2&gt;

&lt;p&gt;这个节点计数，就是前面所说的cnt，即此节点所表示的回文在整个串中出现次数，但这个并不是一次性统计好的，要分两步。首先，在创建回文树过程中的节点计数，然后就是从叶子开始，把自己的cnt数值加到它的fail节点上，为什么是做加法呢，例如节点&lt;code&gt;ababa&lt;/code&gt;，它的fail节点表示的必然是&lt;code&gt;aba&lt;/code&gt;，那么在构建的过程中，每次遇到&lt;code&gt;ababa&lt;/code&gt;的左侧三个字母的时候，就会把cnt加到&lt;code&gt;aba&lt;/code&gt;节点上，而缺少的另一半，正是节点&lt;code&gt;ababa&lt;/code&gt;的出现次数。另外有的博客说cnt是本质不同的回文字符串数量，这是不正确的。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct PAM
{
    struct node
    {
        map&amp;lt;char, int&amp;gt; next;
        int fail, len, cnt, num;
        node(int l = 0) : len(l), fail(0), cnt(0), num(0) {}
    };
    vector&amp;lt;char&amp;gt; s;
    vector&amp;lt;node&amp;gt; nodes;
    int match_p;
    void init(int size)
    {
        s.clear();
        s.reserve(size + 1);
        s.push_back(&#39;\200&#39;);
        nodes.push_back(node());
        nodes.push_back(node(-1));
        nodes[0].fail = 1;
        match_p = 0;
    }
    int getfail(int x)
    {
        while (s[s.size() - nodes[x].len - 2] != s.back())
            x = nodes[x].fail;
        return x;
    }
    void extend(char c)
    {
        s.push_back(c);
        int p = getfail(match_p);
        if (!nodes[p].next.count(c))
        {
            int ch = nodes.size();
            nodes.push_back(node(nodes[p].len + 2));
            nodes[ch].fail = nodes[getfail(nodes[p].fail)].next[c];
            nodes[p].next[c] = ch;
            nodes[ch].num = nodes[nodes[ch].fail].num + 1;
        }
        match_p = nodes[p].next[c];
        nodes[match_p].cnt++;
    }
    void done()
    {
        for (int i = nodes.size() - 1; i &amp;gt; 0; i--)
            nodes[nodes[i].fail].cnt += nodes[i].cnt;
    }
    void build(const char* s)
    {
        init(strlen(s));
        for (;*s;++s) extend(*s);
        done();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接调用build即可，得到的nodes就是回文树&lt;/p&gt;

&lt;h2 id=&#34;pam应用&#34;&gt;PAM应用&lt;/h2&gt;

&lt;h3 id=&#34;1-求字符串中所有本质不同的回文子串的数量&#34;&gt;1 求字符串中所有本质不同的回文子串的数量&lt;/h3&gt;

&lt;p&gt;生成PAM统计非根的节点数量即可&lt;/p&gt;

&lt;h3 id=&#34;2-求字符串中所有回文子串的数量&#34;&gt;2 求字符串中所有回文子串的数量&lt;/h3&gt;

&lt;p&gt;生成PAM后，对除了根外的所有节点的cnt累加就行了&lt;/p&gt;

&lt;h3 id=&#34;3-求公共回文子串数量&#34;&gt;3 求公共回文子串数量&lt;/h3&gt;

&lt;p&gt;对两个字符串都生成PAM后，同时dfs遍历其相同的节点，累加两边节点的cnt的乘积即可&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>后缀自动机SAM</title>
      <link>/post/20200220-sam/</link>
      <pubDate>Thu, 20 Feb 2020 20:00:00 +0800</pubDate>
      <guid>/post/20200220-sam/</guid>
      <description>&lt;p&gt;后缀自动机（SAM），可以结合前文的AC自动机一起理解，所谓后缀自动机，就是把一个字符串的所有后缀构造AC自动机，即只匹配其后缀的自动机。但是作为一个字符串的所有后缀，与一般的AC自动机有些不一样的性质，直接构造AC自动机，节点数是 $O(n^2)$，而SAM则对重复的节点合并了，可以让节点数大幅下降到 $O(n)$。&lt;/p&gt;

&lt;p&gt;首先我们来直观地看看SAM的图形化，以下是字符串&lt;code&gt;abcac&lt;/code&gt;的SAM&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4
4--c--&amp;gt;5((5))
0--c--&amp;gt;6(1)

0--b--&amp;gt;2
1--c--&amp;gt;5
6--a--&amp;gt;4

4-.-&amp;gt;1
5-.-&amp;gt;6
3-.-&amp;gt;6

1-.-&amp;gt;0
2-.-&amp;gt;0
6-.-&amp;gt;0
style 0 fill:#f9f
style 5 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实线方向就是匹配方向，虚线与AC自动机中的失败指针非常像，在SAM里称为link指针。&lt;/p&gt;

&lt;p&gt;咱们这里就不从理论上做解释，把构造过程简单模拟一遍，如果你需要证明，那么可以在oiwiki上找到。&lt;/p&gt;

&lt;h2 id=&#34;sam构造过程模拟&#34;&gt;SAM构造过程模拟&lt;/h2&gt;

&lt;p&gt;我们使用字符串&lt;code&gt;abcac&lt;/code&gt;作为开始，SAM的构造是一个在线算法，可以一个个字符添加构造。另一点说明，节点编号等于与从根开始出发到该节点的最大深度。&lt;/p&gt;

&lt;h3 id=&#34;1-插入a&#34;&gt;1 插入a&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1((1))

1-.-&amp;gt;0
style 0 fill:#f9f
style 1 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-插入b&#34;&gt;2 插入b&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2((2))

0--b--&amp;gt;2

1-.-&amp;gt;0
2-.-&amp;gt;0
style 0 fill:#f9f
style 2 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在b添加到主链后，要找2的父节点1的link指针指的节点，命名为p，1. 如果它的下一个不存在字符&lt;code&gt;b&lt;/code&gt;，那么再令&lt;code&gt;p = p-&amp;gt;link&lt;/code&gt;，并再次判断本情况，2. 如果某个p的next存在当前的字符，那就让节点2的link指向&lt;code&gt;p-&amp;gt;next[char]&lt;/code&gt;节点，3. 如果p已经到达根，那么从根连接一条实边到节点2，同时节点2的link指向根。这里就属于情况3。&lt;/p&gt;

&lt;h3 id=&#34;3-插入c&#34;&gt;3 插入c&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3

0--b--&amp;gt;2
0--c--&amp;gt;3((3))

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
style 0 fill:#f9f
style 3 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-插入a&#34;&gt;4 插入a&lt;/h3&gt;

&lt;p&gt;这个步骤稍微多一点，先添加到主链，即在&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/code&gt;上，得到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4((4))

0--b--&amp;gt;2
0--c--&amp;gt;3

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
style 0 fill:#f9f
style 4 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后找4的父节点3的link指针指的节点，它的下一个存在字符&lt;code&gt;a&lt;/code&gt;，那么指向它，属于前面说的情况2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4((4))

0--b--&amp;gt;2
0--c--&amp;gt;3

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;1
style 0 fill:#f9f
style 4 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-插入c&#34;&gt;5 插入c&lt;/h3&gt;

&lt;p&gt;此步更为复杂 ，首先还是先加入主链&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4
4--c--&amp;gt;5((5))

0--b--&amp;gt;2
0--c--&amp;gt;3

1-.-&amp;gt;0
2-.-&amp;gt;0
3-.-&amp;gt;0
4-.-&amp;gt;1
style 0 fill:#f9f
style 5 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从节点4开始找到节点1，它的next没有当前字符，再找到节点0，节点0的next存在当前字符，即找到节点3，但我们不能直接让节点5的link连接到节点3，因为连接到3的父节点0，它们的的深度不是连续的关系，这时候我们需要做拆点，把原来的节点3复制一个，即next是一样的，link也是一样，然后再让节点0直接连向它（如果不是节点0，那除了它之外，还有它的link节点的next有包含当前字符的，都要指向复制节点），节点3和新插入的节点5的link都指向这个复制节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--a--&amp;gt;1
1--b--&amp;gt;2
2--c--&amp;gt;3
3--a--&amp;gt;4
4--c--&amp;gt;5((5))
0--c--&amp;gt;6(1)

0--b--&amp;gt;2
1--c--&amp;gt;5
6--a--&amp;gt;4

4-.-&amp;gt;1
5-.-&amp;gt;6
3-.-&amp;gt;6

1-.-&amp;gt;0
2-.-&amp;gt;0
6-.-&amp;gt;0
style 0 fill:#f9f
style 5 fill:#f9f
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;构造步骤总结&#34;&gt;构造步骤总结&lt;/h2&gt;

&lt;p&gt;一些说明，节点p有数据&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;link&lt;/code&gt;、&lt;code&gt;maxlen&lt;/code&gt;，&lt;code&gt;next&lt;/code&gt;就是匹配的转移表，&lt;code&gt;link&lt;/code&gt;连接到p所表示的字符串的最长后缀，可以当成fail指针理解，而&lt;code&gt;maxlen&lt;/code&gt;表示从根到节点p的最大深度&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;上一次插入主链的节点命名为&lt;code&gt;last&lt;/code&gt;，新插入节点到主链，命名为&lt;code&gt;cur&lt;/code&gt;，当前要插入的字符命名为&lt;code&gt;c&lt;/code&gt;，进入步骤2&lt;/li&gt;
&lt;li&gt;令&lt;code&gt;p = last&lt;/code&gt;看看&lt;code&gt;p-&amp;gt;link-&amp;gt;next&lt;/code&gt;有没有&lt;code&gt;c&lt;/code&gt;，没有的话再令&lt;code&gt;p = p-&amp;gt;link&lt;/code&gt;直到&lt;code&gt;p-&amp;gt;link-&amp;gt;next&lt;/code&gt;有&lt;code&gt;c&lt;/code&gt;跳到步骤3。如果p到根仍然找不到，那么令&lt;code&gt;cur-&amp;gt;link = root&lt;/code&gt;结束&lt;/li&gt;
&lt;li&gt;令节点&lt;code&gt;p-&amp;gt;next[c]&lt;/code&gt;为&lt;code&gt;ch&lt;/code&gt;，判断&lt;code&gt;ch-&amp;gt;maxlen&lt;/code&gt;和&lt;code&gt;p-&amp;gt;maxlen+1&lt;/code&gt;是不是相等，如果是，令&lt;code&gt;cur-&amp;gt;link = p-&amp;gt;next[c]&lt;/code&gt;，结束。如果不是，到第4步&lt;/li&gt;
&lt;li&gt;对节点&lt;code&gt;ch&lt;/code&gt;进行分拆操作，先复制，复制节点命名为&lt;code&gt;p2&lt;/code&gt;，更新&lt;code&gt;p2&lt;/code&gt;的最大深度，再判断如果满足&lt;code&gt;p-&amp;gt;next[c] == ch&lt;/code&gt;，则令&lt;code&gt;p-&amp;gt;next[c] = p2&lt;/code&gt;，再令&lt;code&gt;p = p-&amp;gt;link&lt;/code&gt;重复前一步&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于节点p的&lt;code&gt;minlen&lt;/code&gt;，可以通过 &lt;code&gt;p-&amp;gt;link-&amp;gt;maxlen + 1&lt;/code&gt; 得到&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SAM
{
    struct node
    {
        map&amp;lt;char, int&amp;gt; next;
        int link;
        int len_max;
        node() : link(0), len_max(0) { }
    };
    vector&amp;lt;node&amp;gt; nodes;
    int last;
    void init(int size = 1024)
    {
        nodes.clear();
        nodes.reserve(size);
        nodes.push_back(node());
        last = 0;
        nodes[0].link = -1;
    }
    int size() const
    {
        return (int)nodes.size();
    }
    int len_max(int p)
    {
        return nodes[p].len_max;
    }
    int len_min(int p)
    {
        if (p == 0) return 0;
        return nodes[nodes[p].link].len_max + 1;
    }
    void extend(char c)
    {
        int cur = (int)nodes.size();
        nodes.push_back(node());
        nodes[cur].len_max = nodes[last].len_max + 1;
        int p = last; last = cur;

        while (p != -1 &amp;amp;&amp;amp; !nodes[p].next.count(c))
        {
            nodes[p].next[c] = cur;
            p = nodes[p].link;
        }

        if (p == -1)
        {
            nodes[cur].link = 0;
        }
        else
        {
            int ch = nodes[p].next[c];
            if (nodes[p].len_max + 1 == nodes[ch].len_max)
            {
                nodes[cur].link = ch;
            }
            else // split ch
            {
                int p2 = (int)nodes.size();
                nodes.push_back(nodes[ch]);
                nodes[p2].len_max = nodes[p].len_max + 1;
                while (p != -1 &amp;amp;&amp;amp; nodes[p].next[c] == ch)
                {
                    nodes[p].next[c] = p2;
                    p = nodes[p].link;
                }
                nodes[ch].link = nodes[cur].link = p2;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sam应用&#34;&gt;SAM应用&lt;/h2&gt;

&lt;h3 id=&#34;1-多模式匹配&#34;&gt;1 多模式匹配&lt;/h3&gt;

&lt;p&gt;给你一个字符串集S以及字符串T，判断T有哪些子串属于S&lt;/p&gt;

&lt;p&gt;先对T求SAM，然后对S的每一个字符串走一遍，如果能走到底，那么这个串在T中出现了&lt;/p&gt;

&lt;h3 id=&#34;2-不同的子串数量&#34;&gt;2 不同的子串数量&lt;/h3&gt;

&lt;p&gt;因为对于SAM任何一个节点u，从根到这个节点的路线有 $maxlen(u) - minlen(u) + 1$ 条，而这条路线则表示原字符串的一个子串，且各不相同，所以对所有的节点求和，即 $\sum{(maxlen(u) - minlen(u) + 1)}$&lt;/p&gt;

&lt;h3 id=&#34;3-字符串的最小表示&#34;&gt;3 字符串的最小表示&lt;/h3&gt;

&lt;p&gt;这个很简单，对于原串s，长度为k，生成关于&lt;code&gt;s+s&lt;/code&gt;串的SAM后，找最小的next节点走k步即可&lt;/p&gt;

&lt;h3 id=&#34;4-最长公共子串&#34;&gt;4 最长公共子串&lt;/h3&gt;

&lt;p&gt;给出串A和B，对B求SAM，然后把这个SAM仿照KMP给A做匹配，令&lt;code&gt;l&lt;/code&gt;表示最大匹配长度，如果next有对应字符就转移，且&lt;code&gt;l++&lt;/code&gt;，如果没有则跳转到link所指的节点u，令&lt;code&gt;l = maxlen(u)&lt;/code&gt;并再次匹配，l的最大值就是答案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AC自动机</title>
      <link>/post/20200210-ac/</link>
      <pubDate>Mon, 10 Feb 2020 22:00:00 +0800</pubDate>
      <guid>/post/20200210-ac/</guid>
      <description>&lt;p&gt;听到AC自动机很多人第一次听到的反应往往是很兴奋的。但其实并不是你们想的那种东西。它的全称是Aho-Corasick algorithm，另外，自动机的英文是Automaton，所以AC自动机即 AC Automaton。为了解释这个算法，首先我们来回顾KMP，你需要很理解KMP的原理，不然看后面的内容就会变得&lt;del&gt;妙不可读&lt;/del&gt;。&lt;/p&gt;

&lt;h2 id=&#34;kmp自动机&#34;&gt;KMP自动机&lt;/h2&gt;

&lt;p&gt;本质上KMP其实就是一种自动机。这次我们改用自动机的形式来理解。所谓自动机，一般指的是确定有限状态自动机，你可以看作一个黑箱，每次输入一个数据，它就会改变它的内部状态，并有相应的输出。如果你知道Trie，那么它其实就是一个典型的自动机。我们还是拿字符串&lt;code&gt;abacabab&lt;/code&gt;作为例子，如果是生成next数组，结果如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;\0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;next&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;为了方便变成自动机的方式理解，我们把这个改成有向图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
1--a--&amp;gt;2[3]
2--c--&amp;gt;3[4]
3--a--&amp;gt;4[5]
4--b--&amp;gt;5[6]
5--a--&amp;gt;6[7]
6--b--&amp;gt;7[8]
00-.-&amp;gt;0
1-.-&amp;gt;0
2-.-&amp;gt;00
3-.-&amp;gt;0
4-.-&amp;gt;00
5-.-&amp;gt;1
6-.-&amp;gt;2
%%7[b]-.-&amp;gt;3[c]
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上图中，实箭头表示匹配，虚箭头表示不匹配要返回的前面的节点，紫色节点表示起止节点。首先我们的状态只要一个指针，先指向start，在匹配的时候，如果与它的下一个字符匹配，那么指针就沿实箭头移动；如果与下一个字符不匹配，在有虚线的情况下，那就沿虚线走一步，然后再尝试一次匹配。以下我们模拟一下匹配&amp;rdquo;ababa&amp;rdquo;的过程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化指向start，start的下一个是&lt;code&gt;a&lt;/code&gt;，匹配第1个字符，指针移动到节点1&lt;/li&gt;
&lt;li&gt;节点1的下一个是&lt;code&gt;b&lt;/code&gt;，匹配第2个字符，指针移动到节点2&lt;/li&gt;
&lt;li&gt;节点2的下一个是&lt;code&gt;a&lt;/code&gt;，匹配第3个字符，指针移动到节点3&lt;/li&gt;
&lt;li&gt;节点3的下一个是&lt;code&gt;c&lt;/code&gt;，不匹配第4个字符，回退到节点1，这时候匹配，指针移动到节点2&lt;/li&gt;
&lt;li&gt;节点2的下一个是&lt;code&gt;a&lt;/code&gt;，匹配第5个字符，指针移动到节点3&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上的虚线箭头就是fail指针的指向&lt;/p&gt;

&lt;h2 id=&#34;kmp自动机的生成&#34;&gt;KMP自动机的生成&lt;/h2&gt;

&lt;p&gt;这个的生成规则其实非常简单，首先建立start，然后向右添加字符，用实箭头连接，第一个节点就虚箭头直接指回start&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00-.-&amp;gt;0
style 0 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后插入第二个字符，第二个字符的虚箭头看它的父节点的虚箭头所指向的节点的子节点是不是与第二个字符相等，这个描述有点绕，假设当前节点是c，父节点是p，其虚箭头所指节点是&lt;code&gt;fail[x]&lt;/code&gt;，那么看的是&lt;code&gt;fail[p]&lt;/code&gt;的子节点是否等于c的值，如果等于，那么&lt;code&gt;fail[c] = fail[p]-&amp;gt;next&lt;/code&gt;，如果不等于，那么令&lt;code&gt;p=fail[p]&lt;/code&gt;再次判断其子节点，直到&lt;code&gt;p=start&lt;/code&gt;，于是加入第二节点时，它的fail指针指向start&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
00-.-&amp;gt;0
1-.-&amp;gt;0
style 0 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到第3个字符a的时候，它的父节点的fail指向start，而start的子节点也是a，所以它的a就指向第1个字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
1--a--&amp;gt;2[3]
00-.-&amp;gt;0
1-.-&amp;gt;0
2-.-&amp;gt;00
style 0 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后讲一下插入最后的字符b的时候，首先它的父节点的fail指向第3个节点a，但那个节点的下一个字符并不是b，所以用它的父节点的fail替代，然后再看第3个节点的fail，指向第1个节点，而第1个节点的下一个字符是b，所以要指向第2个节点，得到下图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0[Start]--a--&amp;gt;00[1]
00--b--&amp;gt;1[2]
1--a--&amp;gt;2[3]
2--c--&amp;gt;3[4]
3--a--&amp;gt;4[5]
4--b--&amp;gt;5[6]
5--a--&amp;gt;6[7]
6--b--&amp;gt;7[8]
00-.-&amp;gt;0
1-.-&amp;gt;0
2-.-&amp;gt;00
3-.-&amp;gt;0
4-.-&amp;gt;00
5-.-&amp;gt;1
6-.-&amp;gt;2
7-.-&amp;gt;1
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在弄懂以上过程后，我们来正式介绍AC自动机&lt;/p&gt;

&lt;h2 id=&#34;ac自动机与trie&#34;&gt;AC自动机与Trie&lt;/h2&gt;

&lt;p&gt;AC自动机的本质，就是在Trie上套KMP，就这一句话。我们怎么理解呢，其实Trie能匹配字符串的前缀，但如果我们需要匹配任意位置，又不希望回溯，那就依照KMP的方法，在匹配失败的时候，跳转到&lt;strong&gt;假如回溯能匹配到的Trie的位置&lt;/strong&gt;。为了更好说明，这里我们使用&lt;code&gt;he&lt;/code&gt;,&lt;code&gt;she&lt;/code&gt;,&lt;code&gt;the&lt;/code&gt;,&lt;code&gt;there&lt;/code&gt;,&lt;code&gt;here&lt;/code&gt;来演示生成过程。&lt;/p&gt;

&lt;p&gt;先生成Trie&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
0--s--&amp;gt;5
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
0--t--&amp;gt;8
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后做BFS，第一层的fail都指向0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
0--s--&amp;gt;5
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
0--t--&amp;gt;8
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
1-.-&amp;gt;0
5-.-&amp;gt;0
8-.-&amp;gt;0
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，第二层，与KMP自动机的建立规则相同，另外为了让图形上的线不那么乱，虚线指向start的省略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
subgraph here
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
end
0--s--&amp;gt;5
subgraph she
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
end
0--t--&amp;gt;8
subgraph there
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
end
6-.-&amp;gt;1
9-.-&amp;gt;1
style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，第三层&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
subgraph here
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
end
0--s--&amp;gt;5
subgraph she
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
end
0--t--&amp;gt;8
subgraph there
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
end
6-.-&amp;gt;1
9-.-&amp;gt;1
7-.-&amp;gt;2
10-.-&amp;gt;2

style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构建完毕的图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
linkStyle default interpolate basis
0((0))--h--&amp;gt;1
subgraph here
1--e--&amp;gt;2((2))
2--r--&amp;gt;3
3--e--&amp;gt;4((4))
end
0--s--&amp;gt;5
subgraph she
5--h--&amp;gt;6
6--e--&amp;gt;7((7))
end
0--t--&amp;gt;8
subgraph there
8--h--&amp;gt;9
9--e--&amp;gt;10((10))
10--r--&amp;gt;11
11--e--&amp;gt;12((12))
end
6-.-&amp;gt;1
9-.-&amp;gt;1
7-.-&amp;gt;2
10-.-&amp;gt;2
11-.-&amp;gt;3
12-.-&amp;gt;4

style 0 fill:#f9f,stroke-dasharray: 5, 5
style 2 fill:#f9f,stroke-dasharray: 5, 5
style 4 fill:#f9f,stroke-dasharray: 5, 5
style 7 fill:#f9f,stroke-dasharray: 5, 5
style 10 fill:#f9f,stroke-dasharray: 5, 5
style 12 fill:#f9f,stroke-dasharray: 5, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是一个最简单的AC自动机，由于只能通过fail指针在失配时做转移，所以遇到匹配失败的时候不能一步到位，需要一个循环来找下一个位置，但在不少场合已足够使用。习题：&lt;a href=&#34;https://vjudge.net/problem/HDU-2896&#34; target=&#34;_blank&#34;&gt;HDU-2896&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;字典图&#34;&gt;字典图&lt;/h2&gt;

&lt;p&gt;前面刚说过，由于fail指针只有一个，所以遇到匹配失败的时候不能一步到位，那我们如果想一步到位呢？那事实上就成为了一个有向图，我们在跳转时不使用fail指针，而直接用next指针替代，每遇到一个字符就按next来跳转，这样状态转移时间非常稳定且速度更快，而且成为有向图有一个额外的好处，就是能变成图论问题来解，这个后面再来讨论。&lt;/p&gt;

&lt;p&gt;要实现字典图，fail指针还是需要的，但在构建的时候代码写起来反而更简单，因为fail的指向不再需要写循环，可以利用前面的结果一步到位，假设当前节点是c，要更新的字符是i，那分两种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果c的&lt;code&gt;next[i]&lt;/code&gt;非空，那么c的&lt;code&gt;next[i]&lt;/code&gt;节点的fail指针就指向 c的fail指针节点的&lt;code&gt;next[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果c的&lt;code&gt;next[i]&lt;/code&gt;为空，那么c的&lt;code&gt;next[i]&lt;/code&gt;节点就指向 c的fail指针节点的&lt;code&gt;next[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说，不管哪种，都是指向c的fail的&lt;code&gt;next[i]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;应用以下模板时，你很可能需要做的调整包括&lt;code&gt;charset&lt;/code&gt;的大小，以及&lt;code&gt;getindex&lt;/code&gt;函数的实现，这两部分你也可以通过template改写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const int charset = 26;
struct TrieGraph
{
    struct trie_node
    {
        int next[charset];
        int fail;
        int cnt;
        int end;
        trie_node() : end(0), fail(0), cnt(0) {}
        void init() { memset(next, 0, sizeof(next)); }
    };
    vector&amp;lt;trie_node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; bfs_q;
    vector&amp;lt;int&amp;gt; match_cnt;
    map&amp;lt;int, int&amp;gt; id2node;
    map&amp;lt;int, int&amp;gt; str_size;
    int match_p;
    void init(int size)
    {
        nodes.clear();
        nodes.reserve(size);
        nodes.push_back(trie_node());
        nodes.back().init();
        match_p = 0;
    }
    static inline int getindex(char c) { return c - &#39;a&#39;; }
    void insert(const char* s, int id)
    {
        const char* s0 = s;
        int p = 0;
        for (;*s; ++s)
        {
            if (nodes[p].next[getindex(*s)])
            {
                p = nodes[p].next[getindex(*s)];
            }
            else
            {
                int np = nodes.size();
                nodes[p].next[getindex(*s)] = np;
                nodes.push_back(trie_node());
                nodes.back().init();
                p = np;
            }
        }
        ++nodes[p].cnt;
        id2node[id] = p;
        str_size[id] = s - s0;
    }
    void build()
    {
        bfs_q.clear();
        bfs_q.reserve(nodes.size());
        queue&amp;lt;int&amp;gt; q;
        for (int i = 0; i &amp;lt; charset; ++i)
            if (nodes[0].next[i]) q.push(nodes[0].next[i]);
        while (!q.empty())
        {
            int p = q.front();
            q.pop();
            bfs_q.push_back(p);
            for (int i = 0; i &amp;lt; charset; ++i)
            {
                if (nodes[p].next[i])
                {
                    nodes[nodes[p].next[i]].fail = nodes[nodes[p].fail].next[i];
                    q.push(nodes[p].next[i]);
                }
                else nodes[p].next[i] = nodes[nodes[p].fail].next[i];
            }
        }
    }
    int match(char c)
    {
        match_p = nodes[match_p].next[getindex(c)];
        return match_p;
    }
    int query(const char* s) // 有多少个出现
    {
        int ret = 0;
        match_cnt.resize(nodes.size());
        for (int i = match_cnt.size() - 1; i &amp;gt;= 0; --i)
        {
            match_cnt[i] = nodes[i].cnt;
        }
        for (const char* ps = s; *ps; ps++)
        {
            for (int p = match(*ps); p &amp;amp;&amp;amp; ~match_cnt[p]; p = nodes[p].fail)
                ret += match_cnt[p], match_cnt[p] = -1;
        }
        return ret;
    }
    ll query_sum(const char* s, int wc[]) // 每个分别出现多少
    {
        vector&amp;lt;int&amp;gt; sum;
        sum.resize(nodes.size());
        match_p = 0;
        for (const char* ps = s; *ps; ps++)
        {
            for (int p = match(*ps); p; p = nodes[p].fail)
            {
                sum[p] += nodes[p].cnt;
            }
        }
        ll ret = 0;
        for (map&amp;lt;int, int&amp;gt;::iterator it = id2node.begin(); it != id2node.end(); ++it)
        {
            wc[it-&amp;gt;first] = sum[it-&amp;gt;second];
            ret += sum[it-&amp;gt;second];
        }
        return ret;
    }
    const char* find(const char* s, int&amp;amp; match_id)
    {
        match_p = 0;
        for (const char* ps = s; *ps; ps++)
        {
            for (int p = match(*ps); p; p = nodes[p].fail)
            {
                if (nodes[p].cnt == 0) continue;
                for (map&amp;lt;int, int&amp;gt;::iterator it = id2node.begin(); it != id2node.end(); ++it)
                {
                    if (it-&amp;gt;second == p)
                    {
                        match_id = it-&amp;gt;first;
                        break;
                    }
                }
                return ps - str_size[match_id] + 1;
            }
        }
        return 0;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方式，先调用&lt;code&gt;init&lt;/code&gt;预分配空间，然后调用&lt;code&gt;insert&lt;/code&gt;插入所有用到的字符串，注意字符串的id必须从1开始，再调用&lt;code&gt;build&lt;/code&gt;生成字典树，最后调用&lt;code&gt;query&lt;/code&gt;匹配目标字符串，如果只需要知道有多少个串在目标中出现，那么调用单个参数的，如果需要知道每个分别出现多少次，那么使用有wc参数的版本，通过参数wc返回的是原始字符串每一个的匹配数量，而如果只需要找最初匹配的位置，那用find函数。习题 &lt;a href=&#34;https://vjudge.net/problem/HYSBZ-3172&#34; target=&#34;_blank&#34;&gt;HYSBZ-3172&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;扩展-字符串生成的可能数量&#34;&gt;扩展：字符串生成的可能数量&lt;/h2&gt;

&lt;p&gt;典型题目为&lt;a href=&#34;https://vjudge.net/problem/POJ-2778&#34; target=&#34;_blank&#34;&gt;POJ-2778&lt;/a&gt;，即生成长度为n的字符串，且不包含给定的m个子串。这时候就要用上前面所构造的字典图，我们要先转成邻接矩阵，例如&lt;code&gt;m[i][j][c]&lt;/code&gt;如果为1，表示节点i能通过字符c连接到节点j，为0则不通。不过实际计算的时候，我们并不关心i和j之间通过什么连接，只关心连接数量，那累加&lt;code&gt;m[i][j][c]&lt;/code&gt;，c取字符集的范围，累加值写到矩阵&lt;code&gt;M = matrix[i][j]&lt;/code&gt;，然后我们只要计算$M&amp;rsquo; = M ^ n$，在矩阵&lt;code&gt;M&#39;&lt;/code&gt;中，&lt;code&gt;M&#39;[i][j]&lt;/code&gt;的值就表示从i到j恰好n步共有多少种走法。回到上面的题目，因为部分节点不能走，所以我们只要在生成矩阵的时候删除那些不能走的节点，求出&lt;code&gt;M&#39;&lt;/code&gt;后，累加&lt;code&gt;M&#39;[0][j]&lt;/code&gt;的结果就是答案，所以算法复杂度是 $O(Mlogn)$ ，其中M是一次矩阵乘法的时间复杂度，这个也是有向图里面求k步到达指定节点的路线数量所用的算法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>可持久化线段树</title>
      <link>/post/20191231-persistent_segtree/</link>
      <pubDate>Tue, 31 Dec 2019 08:26:00 +0800</pubDate>
      <guid>/post/20191231-persistent_segtree/</guid>
      <description>&lt;p&gt;可持久化权值线段树，wiki上指出引入者名字叫黃嘉泰，名字缩写正好是某位主席名字，所以又叫做主席树。而本篇先介绍可持久化线段树，阅读本篇前你需要先了解&lt;a href=&#34;/post/20191208-segtree/&#34;&gt;线段树&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;p&gt;所谓的可持久化，意思是你能得到所有的历史版本，为了达到这个效果，当然可以每次修改的时候，先整体复制再修改，结果自然就是会爆内存。而事实上，由于每次修改最多改一条链，而其它分支可以重用。我们先拿链表做例子，如果有个链表内容是 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 ，现在我们把3修改成6，得到 1-&amp;gt;2-&amp;gt;6-&amp;gt;4-&amp;gt;5 ，但是后面的元素没有改动，所以我们可以把后面的元素直接重叠在一起使用，如下图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
1--&amp;gt;2
2--&amp;gt;3
3--&amp;gt;4
4--&amp;gt;5
1&#39;--&amp;gt;2&#39;
2&#39;--&amp;gt;6
6--&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，完全可以当成两条不同的链表使用，同时节省空间。而可持久化线段树做法与这一样，就是没变的部分还使用原来节点，所以这个实现不能使用之前介绍的堆式储存，要和平衡树一样动态开节点。&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;p&gt;假设我们的数据是以下这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;构建线段树后结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冒号前面的两个数表示一条线段，冒号后表示的是数据，这个数据表示的是这个区间的和。&lt;/p&gt;

&lt;p&gt;然后我们要把第3个元素从5改为1，构造第二棵线段树，首先复制一个root，包括儿子的指向也复制，得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
1,4&#39;:8--&amp;gt;1,2:1
1,4&#39;:8--&amp;gt;3,4:7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，要更新的节点在右儿子那，所以把右儿子复制出来，得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
1,4&#39;:8--&amp;gt;1,2:1
1,4&#39;:8--&amp;gt;3,4&#39;:7
3,4&#39;:7--&amp;gt;3,3:5
3,4&#39;:7--&amp;gt;4,4:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在区间$[3,4]$要更新的节点在左儿子那，所以把左儿子复制出来，同时由于这是最后的节点，再从底向上更新sum，得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
1,4&#39;:4--&amp;gt;1,2:1
1,4&#39;:4--&amp;gt;3,4&#39;:3
3,4&#39;:3--&amp;gt;L3,3&#39;:1
3,4&#39;:3--&amp;gt;4,4:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上图中&lt;code&gt;L3,3&#39;:1&lt;/code&gt;是&lt;code&gt;3,4&#39;:3&lt;/code&gt;的左儿子。这样就是可持久化线段树的构造过程&lt;/p&gt;

&lt;h2 id=&#34;静态区间范围查询&#34;&gt;静态区间范围查询&lt;/h2&gt;

&lt;p&gt;现在给出区间$[L,R]$和范围$[a,b]$，求数组中在区间$[L,R]$里有多少个元素在范围$[a,b]$里。这种查询普通的线段树并不好办，那可持久化线段树有什么方法来解呢，首先我们先构造一棵空线段树，然后对数组元素做离散化，按大小映射到$[0,n-1]$，然后对离散化后的数组，按下标次序，一个一个加入到可持久化线段树里，例如数字2，那么我们就要在线段树里对2号元素+1，所以这就是可持久化权值线段树，即主席树。如此这般加入后，由于我们是按下标次序加入的，所以我们非常容易地得到表示区间$[0,R]$的线段树，那么在范围$[a,b]$里的元素数量，正好就是$[a,b]$区间和。但如果要求的是区间$[L,R]$里有多少个元素在范围$[a,b]$里，那我们除了要求出区间$[0,R]$，还要求出区间$[0,L-1]$，然后两者的$[a,b]$区间和的差，就是我们所要的答案&lt;/p&gt;

&lt;h2 id=&#34;基础模板&#34;&gt;基础模板&lt;/h2&gt;

&lt;p&gt;以下基础模板只支持区间求和，即求区间$[0,R]$里有多少个元素在范围$[a,b]$里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct persistent_seg_tree
{
    struct data
    {
        int sum;
        data() :sum(0) {}
    };
    struct node
    {
        int l, r;
        data d;
        node() :l(0), r(0) {}
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; roots;
    int sz;

    void up(int id)
    {
        nodes[id].d.sum = nodes[nodes[id].l].d.sum + nodes[nodes[id].r].d.sum;
    }
    int newnode(int cpy)
    {
        int id = (int)nodes.size();
        node tmp = nodes[cpy];
        nodes.push_back(tmp);
        return id;
    }
    int add(int tp, int tl, int tr, int i, int v)
    {
        int id = newnode(tp);
        if (tl + 1 &amp;gt;= tr)
        {
            nodes[id].d.sum += v;
            return id;
        }
        int tmid = (tl + tr) / 2;
        if (i &amp;lt; tmid)
        {
            int nid = add(nodes[id].l, tl, tmid, i, v);
            nodes[id].l = nid;
        }
        else
        {
            int nid = add(nodes[id].r, tmid, tr, i, v);
            nodes[id].r = nid;
        }
        up(id);
        return id;
    }
    int getsum(int tp, int tl, int tr, int l, int r)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return nodes[tp].d.sum;
        }
        int tmid = (tl + tr) / 2;
        int sum = 0;
        if (l &amp;lt; tmid)
        {
            sum += getsum(nodes[tp].l, tl, tmid, l, r);
        }
        if (r &amp;gt; tmid)
        {
            sum += getsum(nodes[tp].r, tmid, tr, l, r);
        }
        return sum;
    }
    // interface
    void init(int range, int root_size) // 数组大小[0, range)，操作次数
    {
        sz = range;
        nodes.clear();
        roots.clear();
        nodes.reserve(root_size * (int)(log(sz * 2.0) / log(2.0) + 1.01));
        nodes.push_back(node());
        roots.reserve(root_size + 1);
        roots.push_back(0);
    }
    void add(int pos, int v)
    {
        int last = roots.back();
        roots.push_back(add(last, 0, sz, pos, v));
    }
    int getsum(int t, int l, int r)
    {
        if (t &amp;lt;= 0) return 0;
        if (r &amp;lt; l) return 0;
        if (t &amp;gt;= (int)roots.size()) t = (int)roots.size() - 1;
        return getsum(roots[t], 0, sz, l, r + 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用说明，先调用init，参数分别是离散化后的值域大小，和数组大小（对应的就是操作完后根的个数，所以名字是&lt;code&gt;root_size&lt;/code&gt;），然后循环 &lt;code&gt;add(pos, 1)&lt;/code&gt;，最后查询时，调用&lt;code&gt;getsum(R, a, b) - getsum(L - 1, a, b)&lt;/code&gt;，LR就是区间，ab就是值域范围。&lt;/p&gt;

&lt;h2 id=&#34;静态区间第k大&#34;&gt;静态区间第k大&lt;/h2&gt;

&lt;p&gt;此问题解法较多，本篇主要介绍使用主席树的解法，同样也是先建立一棵可持久化权值线段树，对于查询区间为$[0,R]$的第k大，这个问题很简单，就是找出前缀和大于等于k的区间$[0,m]$所对应的最小的m值，所以只要对$[0,R]$所对应的线段树做查找，如果左子树的sum小于等于k，那么进入左子树查询k，否则进入右子树查询k-sum即可。但对于查询区间$[L,R]$，我们需要找出$[0,R]$和$[0,L-1]$这两棵线段树，它们的$[a,b]$区间和表示在$[L,R]$里有多少个数的值域在$[a,b]$之间，所以我们就同时对这两棵线段树做查找，设 $[0,R]$左子树的sum 减去 $[0,L-1]$左子树的sum 为S，那么如果S小于等于k，那么进入左子树查询k，否则进入右子树查询k-S，实现代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int kth(int tpl, int tpr, int tl, int tr, int k)
{
    if (tl + 1 &amp;gt;= tr) return tl;
    int tmid = (tl + tr) / 2;
    int num = nodes[nodes[tpr].l].d.sum - nodes[nodes[tpl].l].d.sum;
    if (k &amp;lt;= num) return kth(nodes[tpl].l, nodes[tpr].l, tl, tmid, k);
    else return kth(nodes[tpl].r, nodes[tpr].r, tmid, tr, k - num);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;区间第k大模板&#34;&gt;区间第k大模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct persistent_seg_tree
{
    struct data
    {
        int sum;
        data() :sum(0) {}
    };
    struct node
    {
        int l, r;
        data d;
        node() :l(0), r(0) {}
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; roots;
    int sz;

    void up(int id)
    {
        nodes[id].d.sum = nodes[nodes[id].l].d.sum + nodes[nodes[id].r].d.sum;
    }
    int newnode(int cpy)
    {
        int id = (int)nodes.size();
        node tmp = nodes[cpy];
        nodes.push_back(tmp);
        return id;
    }
    int add(int tp, int tl, int tr, int i, int v)
    {
        int id = newnode(tp);
        if (tl + 1 &amp;gt;= tr)
        {
            nodes[id].d.sum += v;
            return id;
        }
        int tmid = (tl + tr) / 2;
        if (i &amp;lt; tmid)
        {
            int nid = add(nodes[id].l, tl, tmid, i, v);
            nodes[id].l = nid;
        }
        else
        {
            int nid = add(nodes[id].r, tmid, tr, i, v);
            nodes[id].r = nid;
        }
        up(id);
        return id;
    }
    int kth(int tpl, int tpr, int tl, int tr, int k)
    {
        if (tl + 1 &amp;gt;= tr) return tl;
        int tmid = (tl + tr) / 2;
        int num = nodes[nodes[tpr].l].d.sum - nodes[nodes[tpl].l].d.sum;
        if (k &amp;lt;= num) return kth(nodes[tpl].l, nodes[tpr].l, tl, tmid, k);
        else return kth(nodes[tpl].r, nodes[tpr].r, tmid, tr, k - num);
    }
    // interface
    void init(int range, int root_size) // 数组大小[0, range)，操作次数
    {
        sz = range;
        nodes.clear();
        roots.clear();
        nodes.reserve(root_size * (int)(log(sz * 2.0) / log(2.0) + 1.01));
        nodes.push_back(node());
        roots.reserve(root_size + 1);
        roots.push_back(0);
    }
    void add(int i, int v)
    {
        int last = roots.back();
        roots.push_back(add(last, 0, sz, i, v));
    }
    int kth(int tpl, int tpr, int k)
    {
        return kth(roots[tpl - 1], roots[tpr], 0, sz, k);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它说明&#34;&gt;其它说明&lt;/h2&gt;

&lt;p&gt;其它的可持久化数据结构大同小异，如可持久化的trie，构造方法也是一样的&lt;/p&gt;

&lt;p&gt;以上只介绍了静态区间的范围查询和第k大查询，还不支持动态修改并查询，这个会在之后再做介绍。&lt;/p&gt;

&lt;p&gt;习题：静态区间范围查询&lt;a href=&#34;https://vjudge.net/problem/HDU-4417&#34; target=&#34;_blank&#34;&gt;hdu 4417&lt;/a&gt;，静态区间第k大&lt;a href=&#34;https://vjudge.net/problem/POJ-2104&#34; target=&#34;_blank&#34;&gt;POJ 2104&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>FHQ Treap</title>
      <link>/post/20191215-fhq-treap/</link>
      <pubDate>Sun, 15 Dec 2019 13:10:00 +0800</pubDate>
      <guid>/post/20191215-fhq-treap/</guid>
      <description>&lt;p&gt;讲完了&lt;a href=&#34;/post/20191211-treap-sbt/&#34;&gt;treap&lt;/a&gt;和&lt;a href=&#34;/post/20191213-tree-sequence/&#34;&gt;splaytree&lt;/a&gt;，接下来讲把这两的思想混合在一起的 FHQ Treap，据说作者是范浩强。&lt;/p&gt;

&lt;p&gt;splay其实还有两个操作split和merge没有介绍，我打算把这两放在这里一并介绍&lt;/p&gt;

&lt;h2 id=&#34;split和merge&#34;&gt;Split和Merge&lt;/h2&gt;

&lt;p&gt;Split就是把树按某个条件划分成两棵子树，如果是查找树，就按某个值划分为小于它的以及大于等于它的（等于号取哪边怎么好写怎么来就是），如果是序列维护，那就按照rank来划分。而merge操作则正好相反，把两棵子树合并成为一棵。所以，如果我们需要对某个区间做操作，那么我们就把那个区间Split出来，操作好了后（打懒惰标记，或取出结果）再Merge回去就行了，与splay操作的思路是差不多的。不过为了在split再merge后能间接对树的平衡性优化，我们不能简单地merge，要套用Treap的随机数法，我们先来看怎么split。&lt;/p&gt;

&lt;p&gt;先定义好接口&lt;code&gt;void split(int tp, int k, int &amp;amp;x, int &amp;amp;y)&lt;/code&gt;，x是返回的左子树，y是返回的右子树，接着我们需要递归split，如果划分点在左子树，那么y一定是根，反之划分点在右子树，那么x一定是根。确定了其中一个，在递归调用的时候，假如y确定了，于是还没确定的，就是x以及根节点的左子树的指向，所以把这两传参就行了，时间复杂度 $O(logn)$ ，具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 维护序列的实现
void split(int tp, int k, int &amp;amp;x, int &amp;amp;y)
{
    if (!tp) { x = y = 0; return; }
    pushdown(tp);
    if (k &amp;lt;= nodes[ch(tp, 0)].sz)
    {
        y = tp;
        split(ch(tp, 0), k, x, ch(tp, 0));
        update(y);
    }
    else
    {
        x = tp;
        split(ch(tp, 1), k - nodes[ch(tp, 0)].sz - 1, ch(tp, 1), y);
        update(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来讲讲merge，我们不能直接把右子树直接接在左子树的最后一个元素后，这样会导致树高度太大。在Treap里面，引入了一个随机值，来决定谁来做根节点，所以，我们就对比这个值，如果左子树的小，那么就让左子树的右儿子与右子树merge，否则就让右子树的左儿子与左子树merge，递归调用就是了，时间复杂度 $O(logn)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int merge(int tl, int tr)
{
    if (!tl) return tr;
    else if (!tr) return tl;
    if (nodes[tl].k &amp;lt; nodes[tr].k)
    {
        pushdown(tl);
        ch(tl, 1) = merge(ch(tl, 1), tr);
        return update(tl);
    }
    else
    {
        pushdown(tr);
        ch(tr, 0) = merge(tl, ch(tr, 0));
        return update(tr);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基本模板&#34;&gt;基本模板&lt;/h2&gt;

&lt;p&gt;这么快就给模板了？没错，你在理解了Treap以后，再去学习&lt;code&gt;FHQ-Treap&lt;/code&gt;那是相当简单的，最复杂的两个操作已经讲完了，相比Treap，它不需要旋转操作，而通过merge操作来让树平衡，而且这组操作让其它的操作相比Treap都来得简单，最不容易写出BUG，代码也是最短的一个，常数也比splaytree小，所有操作的期望时间复杂度都是 $O(logn)$ 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
struct FHQ_Treap
{
    struct data
    {
        T v;
        data(int _v = 0) :v(_v) {}
        data operator + (const data&amp;amp; d) const
        {
            data r;
            r.v = v + d.v;
            return r;
        }
        data operator * (int t) const
        {
            data r;
            r.v = v * t;
            return r;
        }
        operator bool() const { return v != 0; }
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], sz;
        unsigned k;
        data d, sum, lz_add;
        node(int z = 1) :sz(z), k(rnd()) { ch[0] = ch[1] = 0; }
        static unsigned rnd()
        {
            static unsigned r = 0x123;
            r = r * 69069 + 1;
            return r;
        }
    };
    vector&amp;lt;node&amp;gt; nodes;
    int root;
    int recyc;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    inline int&amp;amp; ch(int tp, int r) { return nodes[tp].ch[r]; }
    int new_node(const data&amp;amp; d)
    {
        int id = (int)nodes.size();
        if (recyc)
        {
            id = recyc;
            if (ch(recyc, 0) &amp;amp;&amp;amp; ch(recyc, 1))
                recyc = merge(ch(recyc, 0), ch(recyc, 1));
            else
                recyc = ch(recyc, 0) ? ch(recyc, 0) : ch(recyc, 1);
            nodes[id] = node();
        }
        else nodes.push_back(node());
        nodes[id].d = d;
        nodes[id].sum = d;
        return id;
    }
    int update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
        n.sum = n.d + nodes[n.ch[0]].sum + nodes[n.ch[1]].sum;
        return tp;
    }
    void add(int tp, const data&amp;amp; d)
    {
        node&amp;amp; n = nodes[tp];
        n.lz_add = n.lz_add + d;
        n.d = n.d + d;
        n.sum = n.sum + d * n.sz;
    }
    void pushdown(int tp)
    {
        node&amp;amp; n = nodes[tp];
        if (n.lz_add)
        {
            add(n.ch[0], n.lz_add); add(n.ch[1], n.lz_add);
            n.lz_add = 0;
        }
    }
    int merge(int tl, int tr)
    {
        if (!tl) return tr;
        else if (!tr) return tl;
        if (nodes[tl].k &amp;lt; nodes[tr].k)
        {
            pushdown(tl);
            ch(tl, 1) = merge(ch(tl, 1), tr);
            return update(tl);
        }
        else
        {
            pushdown(tr);
            ch(tr, 0) = merge(tl, ch(tr, 0));
            return update(tr);
        }
    }
    void split(int tp, int k, int &amp;amp;x, int &amp;amp;y)
    {
        if (!tp) { x = y = 0; return; }
        pushdown(tp);
        if (k &amp;lt;= nodes[ch(tp, 0)].sz)
        {
            y = tp;
            split(ch(tp, 0), k, x, ch(tp, 0));
            update(y);
        }
        else
        {
            x = tp;
            split(ch(tp, 1), k - nodes[ch(tp, 0)].sz - 1, ch(tp, 1), y);
            update(x);
        }
    }
    void remove(int&amp;amp; tp)
    {
        if (recyc == 0) recyc = tp;
        else recyc = merge(recyc, tp);
        tp = 0;
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        nodes.reserve((size = max(size, 15)) + 1);
        nodes.push_back(node(0));
        root = 0;
        recyc = 0; reserve_size = size + 1;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz; }
    int kth(int k)
    {
        int x, y, z;
        split(root, k, y, z); split(y, k - 1, x, y);
        int id = y;
        root = merge(merge(x, y), z);
        return id;
    }
    void insert(int k, data v)
    {
        int l, r;
        split(root, k - 1, l, r);
        int tp = new_node(v);
        root = merge(merge(l, tp), r);
    }
    void erase(int l, int r)
    {
        int x, y, z;
        split(root, r, y, z); split(y, l - 1, x, y);
        remove(y);
        root = merge(x, z);
    }
    void range_add(int l, int r, data v)
    {
        int x, y, z;
        split(root, r, y, z); split(y, l - 1, x, y);
        add(y, v);
        root = merge(merge(x, y), z);
    }
    T getsum(int l, int r)
    {
        int x, y, z;
        split(root, r, y, z); split(y, l - 1, x, y);
        T ret = nodes[y].sum;
        root = merge(merge(x, y), z);
        return ret;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是个支持区间加、区间删和区间求和的模板。除了LCT，都交给这个数据结构解决吧。&lt;/p&gt;

&lt;h2 id=&#34;其它问题&#34;&gt;其它问题&lt;/h2&gt;

&lt;p&gt;如果你要问为什么不一开始就介绍这个，而先解释其它的树结构，那是因为那是基础啊，基础搞好了，那再搞这个就很简单了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>平衡树与序列维护</title>
      <link>/post/20191213-tree-sequence/</link>
      <pubDate>Fri, 13 Dec 2019 13:10:00 +0800</pubDate>
      <guid>/post/20191213-tree-sequence/</guid>
      <description>&lt;p&gt;平衡树除了用来对存在偏序关系的数据进行维护，还能用于对序列维护，相当于一个数组。阅读本文你需要先看完上一篇关于&lt;a href=&#34;/post/20191211-treap-sbt/&#34;&gt;treap&lt;/a&gt;的文章。&lt;/p&gt;

&lt;h2 id=&#34;序列维护&#34;&gt;序列维护&lt;/h2&gt;

&lt;p&gt;在之前的文章，我们介绍过使用树状数组，以及线段树来维护一个序列，可以做区间操作及区间求和，但它们都存在一个缺点，不能动态插入数据。那我们怎么样才能通过平衡树来维护序列呢，之前我们有一个size字段能快速找第k大（或树的中序遍历第k个元素），而旋转操作并不会改变元素之间的相对顺序，那么我们就通过它直接插入到第k个元素的前面，这样我们插入的时候就不再通过要插入的值本身的大小关系，而需要多加一个参数k决定插入的位置。当平衡树用于维护序列的时候，就不用考虑元素相等的问题了。这样我们把元素相等处理的代码删除并修改基本操作的代码就能得到第一个能维护序列的基本模板，以下模板使用Treap修改得来。&lt;/p&gt;

&lt;h2 id=&#34;基本模板&#34;&gt;基本模板&lt;/h2&gt;

&lt;p&gt;以下模板我实现成真·模板，就几乎可以作为数组使用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt;
struct treap_seq
{
    struct data
    {
        T v;
        data(T _v = 0) :v(_v) {}
        operator bool() const { return v != 0; }
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], sz;
        unsigned k;
        data d;
        node(int z = 1) :sz(z), k(rnd()) { d = ch[0] = ch[1] = 0; }
        void clone(const node&amp;amp; n) { d = n.d; }
        static unsigned rnd()
        {
            static unsigned r = 0x123;
            r = r * 69069 + 1;
            return r;
        }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
    }
    int insert(int&amp;amp; tp, int k, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = insert(s, k - sz * r, d);
        update(s);
        if (nodes[s].k &amp;lt; n.k) rotate(tp, r);
        else update(tp);
        return ret;
    }
    void rotate(int&amp;amp; tp, int r)
    {
        node&amp;amp; n = nodes[tp];
        int s = n.ch[r];
        n.ch[r] = nodes[s].ch[r ^ 1];
        nodes[s].ch[r ^ 1] = tp;
        update(tp); update(s);
        tp = s;
    }
    int erasefind(int&amp;amp; tp, int k) // return deleted
    {
        if (tp == 0) return 0;
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        if (sz == k)
        {
            remove(tp);
            return 1;
        }
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = erasefind(s, k - sz * r);
        if (ret)
        {
            update(tp);
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int r = nodes[nodes[tp].ch[0]].k &amp;lt; nodes[nodes[tp].ch[1]].k;
            rotate(tp, r ^ 1);
            remove(nodes[tp].ch[r]);
            update(tp);
        }
    }
    int kth(int tp, int k) // return id
    {
        if (tp == 0) return tp;
        node n = nodes[tp];
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + 1 &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - 1);
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz; }
    int insert(int k, data v) { if (size() &amp;gt;= reserve_size) nodes.reserve((reserve_size *= 2) + 1); return insert(root, k, v); }
    int erase(int k) { return erasefind(root, k); }
    int kth(int k) { return kth(root, k); } // return id
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;动态版本线段树&#34;&gt;动态版本线段树&lt;/h2&gt;

&lt;p&gt;有了这个，我们就可以把它改成动态版本的线段树，就是每个根节点多维护一个sum字段，再加一个懒惰标记，就能实现区间加和区间求和。不过和线段树不同的是，线段树的子树的根只维护区间的结果，而平衡树的根本身就是一个元素，所以代码和线段树略有差别。以下我们实现一个支持区间加和区间求和且能动态增减数据的平衡树，实测与前面讲线段树文章的普通线段树模板，在解决同一问题的执行时间非常接近&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;typename T&amp;gt;
struct treap_seq
{
    struct data
    {
        T v;
        data(T _v = 0) :v(_v) {}
        data operator + (const data&amp;amp; d) const
        {
            data r;
            r.v = v + d.v;
            return r;
        }
        data operator * (int t) const
        {
            data r;
            r.v = v * t;
            return r;
        }
        operator bool() const { return v != 0; }
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], sz;
        unsigned k;
        data d;
        data sum;
        data lz_add;
        node(int z = 1) :sz(z), k(rnd()) { sum = lz_add = d = ch[0] = ch[1] = 0; }
        void clone(const node&amp;amp; n) { d = n.d; sum = n.sum; }
        static unsigned rnd()
        {
            static unsigned r = 0x123;
            r = r * 69069 + 1;
            return r;
        }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void _add(int tp, const data&amp;amp; d)
    {
        node&amp;amp; n = nodes[tp];
        n.lz_add = n.lz_add + d;
        n.d = n.d + d;
        n.sum = n.sum + d * n.sz;
    }
    void pushdown(int tp)
    {
        node&amp;amp; n = nodes[tp];
        if (n.lz_add)
        {
            _add(n.ch[0], n.lz_add);
            _add(n.ch[1], n.lz_add);
            n.lz_add = 0;
        }
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
        n.sum = n.d + nodes[n.ch[0]].sum + nodes[n.ch[1]].sum;
    }
    int insert(int&amp;amp; tp, int k, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            nodes[tp].sum = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        pushdown(tp);
        int sz = nodes[n.ch[0]].sz + 1;
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = insert(s, k - sz * r, d);
        update(s);
        if (nodes[s].k &amp;lt; n.k) rotate(tp, r);
        else update(tp);
        return ret;
    }
    void rotate(int&amp;amp; tp, int r)
    {
        node&amp;amp; n = nodes[tp];
        pushdown(tp);
        int s = n.ch[r];
        pushdown(s);
        n.ch[r] = nodes[s].ch[r ^ 1];
        nodes[s].ch[r ^ 1] = tp;
        update(tp); update(s);
        tp = s;
    }
    int erasefind(int&amp;amp; tp, int k) // return deleted
    {
        if (tp == 0) return 0;
        node&amp;amp; n = nodes[tp];
        pushdown(tp);
        int sz = nodes[n.ch[0]].sz + 1;
        if (sz == k)
        {
            remove(tp);
            return 1;
        }
        int r = sz &amp;lt; k;
        int&amp;amp; s = n.ch[r];
        int ret = erasefind(s, k - sz * r);
        if (ret)
        {
            update(tp);
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int r = nodes[nodes[tp].ch[0]].k &amp;lt; nodes[nodes[tp].ch[1]].k;
            rotate(tp, r ^ 1);
            remove(nodes[tp].ch[r]);
            update(tp);
        }
    }
    int kth(int tp, int k) // return id
    {
        if (tp == 0) return tp;
        node n = nodes[tp];
        pushdown(tp);
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + 1 &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - 1);
    }
    data getsum(int&amp;amp; tp, int l, int r)
    {
        if (tp == 0 || l &amp;gt;= r) return 0;
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        if (l &amp;lt;= 1 &amp;amp;&amp;amp; r &amp;gt; n.sz)
        {
            return n.sum;
        }
        else
        {
            pushdown(tp);
            data sum = 0;
            if (l &amp;lt;= sz &amp;amp;&amp;amp; sz &amp;lt; r)
            {
                sum = nodes[tp].d;
            }
            sum = sum + getsum(n.ch[0], l, min(sz, r));
            sum = sum + getsum(n.ch[1], max(1, l - sz), r - sz);
            return sum;
        }
    }
    void range_add(int&amp;amp; tp, int l, int r, const data&amp;amp; d)
    {
        if (tp == 0 || l &amp;gt;= r) return;
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz + 1;
        if (l &amp;lt;= 1 &amp;amp;&amp;amp; r &amp;gt; n.sz)
        {
            _add(tp, d);
        }
        else
        {
            //pushdown(tp);
            if (l &amp;lt;= sz &amp;amp;&amp;amp; sz &amp;lt; r)
            {
                nodes[tp].d = nodes[tp].d + d;
            }
            nodes[tp].sum = nodes[tp].sum + d * (r - l);
            range_add(n.ch[0], l, min(sz, r), d);
            range_add(n.ch[1], max(1, l - sz), r - sz, d);
        }
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz; }
    int insert(int k, data v) { reserve(); return insert(root, k, v); }
    int erase(int k) { return erasefind(root, k); }
    int kth(int k) { return kth(root, k); } // return id
    T getsum(int l, int r) { return getsum(root, l, r + 1); }
    void range_add(int l, int r, data v) { range_add(root, l, r + 1, v); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;splay-tree&#34;&gt;Splay tree&lt;/h2&gt;

&lt;p&gt;使用以上这个Treap的自由度还是不够好，有些操作还是不容易做，例如区间翻转，或者区间删除。所以我们需要一个功能更为强大的树，因为那个随机数的限制，不能任意节点都能当树根，而没有那个随机数字段的树，就是伸展树Splay tree，区别主要是三个地方，一是需要父节点字段，维护关系时常数更大，二是旋转，使用双旋，三是splay操作，作用是把节点提升到树根。这个splay操作就是神器，能把很多区间操作写得非常简单，代码也确实是目前介绍的树里面代码最少的。不过伸展树的缺点是编码理解难度稍大。&lt;/p&gt;

&lt;p&gt;和其它树的不同点是，为了保证区间操作代码简短，初始化的时候直接插入两个元素作为序列的一头一尾，于是实际操作区间是2到n+1，这个细节要注意，有了这两个元素可以减少很多特判操作。例如说，要找区间&lt;code&gt;[l,r]&lt;/code&gt;，那么只要让位置r+1的元素splay到根，然后再让位置l-1的元素splay到根的左边，那么l-1位的元素的右子树就是整个操作区间了，而为了让这个总是能做，所以才要预先加两个元素。这个技巧用在了几乎所有操作里面，包括插入，删除，所有的区间操作。splay操作的时间复杂度 $O(logn)$&lt;/p&gt;

&lt;p&gt;以下是序列维护用的基本splaytree模板，要改成支持区间求和什么的就自己改吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
struct splaytree_seq
{
    struct data
    {
        T v;
        data(int _v = 0) :v(_v) {}
        operator T() const { return v; }
    };
    struct node
    {
        int ch[2], fa, sz;
        data d;
        node(int z = 1) :sz(z) { ch[0] = ch[1] = fa = 0; }
    };
    vector&amp;lt;node&amp;gt; nodes;
    int root;
    int recyc;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    inline int&amp;amp; ch(int tp, int r) { return nodes[tp].ch[r]; }
    inline int&amp;amp; fa(int tp) { return nodes[tp].fa; }
    inline int rch(int tp) { return ch(fa(tp), 1) == tp; }
    int new_node()
    {
        int id = (int)nodes.size();
        if (recyc)
        {
            id = recyc;
            if (ch(recyc, 0) &amp;amp;&amp;amp; ch(recyc, 1))
                recyc = merge(ch(recyc, 0), ch(recyc, 1));
            else
                recyc = ch(recyc, 0) ? ch(recyc, 0) : ch(recyc, 1);
            fa(recyc) = 0;
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
    }
    void add(int tp, const data&amp;amp; d)
    {
        node&amp;amp; n = nodes[tp];
        n.d = n.d + d;
    }
    void rotate(int s)
    {
        int f1 = fa(s), f2 = fa(f1);
        int d1 = rch(s), d2 = rch(f1);
        ch(f2, d2) = s; fa(s) = f2;
        fa(ch(s, d1 ^ 1)) = f1; ch(f1, d1) = ch(s, d1 ^ 1);
        fa(f1) = s; ch(s, d1 ^ 1) = f1;
        update(f1); update(s);
    }
    void splay(int tp, int goal = 0)
    {
        for (int f; (f = fa(tp)) != goal; rotate(tp))
            if (fa(f) != goal) rotate(rch(tp) == rch(f) ? f : tp);
        if (!goal) root = tp;
    }
    int find_m(int tp, int r)
    {
        int p = tp;
        while (ch(p, r)) p = ch(p, r);
        if (p != tp) splay(p, tp);
        return p;
    }
    int merge(int tl, int tr)
    {
        if (!tl) { fa(tr) = 0; return tr; }
        if (!tr) { fa(tl) = 0; return tl; }
        int p = find_m(tl, 1);
        ch(p, 1) = tr; fa(tr) = p;
        return tl;
    }
    void insert(int k, const data&amp;amp; d)
    {
        int tp = new_node();
        splay(kth(root, k + 1)); splay(kth(root, k), root);
        int c = ch(root, 0);
        nodes[c].ch[1] = tp;
        nodes[tp].fa = c;
        nodes[tp].d = d;
        update(c); update(root);
    }
    void remove(int&amp;amp; tp)
    {
        fa(tp) = 0;
        if (recyc == 0) recyc = tp;
        else recyc = merge(recyc, tp);
        tp = 0;
    }
    int kth(int tp, int k)
    {
        if (tp == 0) return tp;
        node&amp;amp; n = nodes[tp];
        //pushdown(tp);
        int sz = nodes[n.ch[0]].sz + 1;
        if (sz &amp;gt; k) return kth(n.ch[0], k);
        if (sz &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz);
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        nodes.reserve((size = max(size, 15)) + 1);
        nodes.push_back(node(0));
        nodes.push_back(node()); nodes.push_back(node());
        nodes[1].ch[0] = 2; nodes[1].sz = 2; nodes[2].fa = 1;
        root = 1; // be the bound
        recyc = 0; reserve_size = size + 1;
    }
    T get(int id) { return nodes[id].d; }
    int size() { return nodes[root].sz - 2; }
    int kth(int k) { int id = kth(root, k + 1); splay(id); return id; }
    void erase(int l, int r)
    {
        splay(kth(root, r + 2)); splay(kth(root, l), root);
        remove(ch(ch(root, 0), 1));
        update(ch(root, 0)); update(root);
    }
    void range_add(int l, int r, data v)
    {
        splay(kth(root, r + 2)); splay(kth(root, l), root);
        add(ch(ch(root, 0), 1), v);
        update(ch(root, 0)); update(root);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上已经直接写好了区间删除，对于区间反转等操作，可以模仿线段树加懒惰标记即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Treap与SBT</title>
      <link>/post/20191211-treap-sbt/</link>
      <pubDate>Wed, 11 Dec 2019 13:10:00 +0800</pubDate>
      <guid>/post/20191211-treap-sbt/</guid>
      <description>&lt;p&gt;这里之所以把这两个放在一起讲，是因为它们实在是相似度很高（至少在竞赛领域），都需要求kth和指定元素的rank（Treap的话可有可无，但通常会需要）。不过如果你没有写过树，强烈建议你自己通过理解来写一遍。&lt;/p&gt;

&lt;h2 id=&#34;bst&#34;&gt;BST&lt;/h2&gt;

&lt;p&gt;首先，Treap和SBT都属于BST的一种，BST就是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&#34; target=&#34;_blank&#34;&gt;二叉搜索树&lt;/a&gt;，它满足的特点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;二叉树&lt;/li&gt;
&lt;li&gt;没有两个节点的值相等&lt;/li&gt;
&lt;li&gt;任意子树的根节点的值都比左子树所有节点的值要大&lt;/li&gt;
&lt;li&gt;任意子树的根节点的值都比右子树所有节点的值要小&lt;/li&gt;
&lt;li&gt;任意子树均为二叉搜索树&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果我们实在需要支持多个相同值放在树里面，那么有两种情况，如果那些相同值是确实完全没有区别（例如int），那么只需要在每个节点多加一个字段记录这个值出现的次数就可以了，但如果这些值只有偏序关系，可能不是严格相等，存在其它非比较字段，那么我们就再在每个节点增加一个next域做成一个链表即可。&lt;/p&gt;

&lt;p&gt;基本操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;插入(insert)：对比子树的根节点的值r与插入的值v，如果v与r相等，根节点重复数量+1，如果v小于r，插入到左子树，v大于r则插入到右子树&lt;/li&gt;
&lt;li&gt;查找(find)：和插入相似，值相等时返回其id&lt;/li&gt;
&lt;li&gt;删除(erase)：先查找，找到的时候，再查找它的后继（右子树的最小），用后继元素替换后再删除原后继&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;支持简单重复元素的bst模板&#34;&gt;支持简单重复元素的BST模板&lt;/h2&gt;

&lt;p&gt;这个模板还添加了size域，用于求第k小元素和元素排名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct bst
{
    struct data
    {
        int v;
        data(int _v = 0) :v(_v) {}
        bool operator==(const data&amp;amp; d) const
        {
            return v == d.v;
        }
        bool operator&amp;lt;(const data&amp;amp; d) const
        {
            return v &amp;lt; d.v;
        }
    };
    struct node
    {
        int ch[2], sz, dup;
        data d;
        node(int z = 1) :sz(z), dup(z) { ch[0] = ch[1] = 0; }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    int insert(int&amp;amp; tp, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        ++n.sz;
        if (d == n.d)
        {
            ++n.dup;
            return tp;
        }
        int r = d &amp;lt; n.d;
        int&amp;amp; s = n.ch[r ^ 1];
        int ret = insert(s, d);
        return ret;
    }
    int find(int tp, const data&amp;amp; d) // return id
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d) return tp;
        return find(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d);
    }
    int erasefind(int&amp;amp; tp, const data&amp;amp; d) // return deleted
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d)
        {
            --nodes[tp].sz;
            if (--nodes[tp].dup &amp;lt;= 0) remove(tp);
            return 1;
        }
        if (erasefind(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d))
        {
            --nodes[tp].sz;
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int nxt = nodes[tp].ch[1];
            while (nodes[nxt].ch[0])
                nxt = nodes[nxt].ch[0];
            int dup = nodes[nxt].dup;
            nodes[tp].d = nodes[nxt].d;
            nodes[tp].dup = nodes[nxt].dup;
            recycle.push_back(nxt);
            int* tmp = &amp;amp;nodes[tp].ch[1];
            while (nodes[*tmp].ch[0])
            {
                nodes[*tmp].sz -= dup;
                tmp = &amp;amp;nodes[*tmp].ch[0];
            }
            *tmp = nodes[*tmp].ch[1];
        }
    }
    int kth(int tp, int k) // return id
    {
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + n.dup &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - n.dup);
    }
    int rank(int tp, const data&amp;amp; d, int dup)
    {
        if (tp == 0) return 1;
        node&amp;amp; n = nodes[tp];
        if (d == n.d) return nodes[n.ch[0]].sz + 1 + dup * n.dup;
        else if (d &amp;lt; n.d) return rank(n.ch[0], d, dup);
        return rank(n.ch[1], d, dup) + nodes[n.ch[0]].sz + n.dup;
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    int get(int id) { return nodes[id].d.v; }
    int size() { return nodes[root].sz; }
    int insert(data v) { reserve(); return insert(root, v); }
    int erase(data v) { return erasefind(root, v); }
    int find(data v) { return find(root, v); } // return id
    int kth(int k) { return kth(root, k); } // return id
    // upperbound when upper = 1
    int rank(data v, int upper = 0) { return rank(root, v, upper); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一些说明&#34;&gt;一些说明&lt;/h3&gt;

&lt;p&gt;子节点用的节段是ch数组(child的缩写)，不使用left和right的原因是为了节省代码，例如在insert函数里，通过计算&lt;code&gt;d &amp;lt; n.d&lt;/code&gt;的值是0或1决定下一步是递归调用左还是右子节点的时候，就不需要分别针对left和right写代码，后面的find和erase同理。&lt;/p&gt;

&lt;p&gt;rank函数在upper为0的时候，找到的是相同元素里面最小的排名，如果v不存在树里面，那么就是v假如要插入到树里的排名。upper为1的时候，找到的是大于v的最小的元素的排名，即v的后继。&lt;/p&gt;

&lt;p&gt;kth函数的参数如果非法，会导致无限循环，如果你想避免那么你可以在函数里添加检查，例如加一句&lt;code&gt;if (tp == 0) return 0;&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;优化bst&#34;&gt;优化BST&lt;/h2&gt;

&lt;p&gt;单纯的BST最大的问题是，它最坏的情况是可能成为一条链表，例如你按从小到大插入到树里面的时候，缺乏让它缩减树高的机制，所以接下来要讲两个非常重要的操作，就是树的旋转&lt;/p&gt;

&lt;p&gt;图A&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
4--&amp;gt;2
2--&amp;gt;1
2--&amp;gt;3
4--&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图B&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
2--&amp;gt;4
4--&amp;gt;3
2--&amp;gt;1
4--&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两图，从A到B叫做zig，把左儿子旋转到root的位置，也叫右旋，B到A叫做zag，把右儿子旋转到root的位置，也叫左旋，旋转代码也很简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void rotate(int&amp;amp; tp, int r)
{
    node&amp;amp; n = nodes[tp];
    int s = n.ch[r];
    n.ch[r] = nodes[s].ch[r ^ 1];
    nodes[s].ch[r ^ 1] = tp;
    tp = s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上参数r如果是0，就是zig，r是1就是zag。有了旋转操作，我们就可以开始看自平衡树了。&lt;/p&gt;

&lt;h2 id=&#34;treap&#34;&gt;Treap&lt;/h2&gt;

&lt;p&gt;Treap其实炒鸡简单，在BST的基础上多一个随机数生成的字段，这个字段用于决定树要怎么旋转。这个字段就是个优先级，父节点的优先级不大于两个子节点的优先级，这其实就是heap，所以，Treap就是树堆（Tree-heap）。维护Treap，我们只需要在insert的时候，检查是不是满足heap，如果不满足就旋转，相对BST只加了非常少的代码，也就加了rotate函数，rnd函数（直接用rand也行），insert加了维护，以及旋转时需要的update函数维护size字段，也就是说Treap是最经济实惠的平衡树。&lt;/p&gt;

&lt;p&gt;操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更新(update): 累加左右子树的size&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除(erase): 找到要删除的元素后，对比两子树的根的优先级，把较的小旋转到原来要删除的元素的位置，使要删除的元素的深度+1，直到删除的元素没有两个子树为止&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct treap
{
struct data
{
    int v;
    data(int _v = 0) :v(_v) {}
    bool operator==(const data&amp;amp; d) const
    {
        return v == d.v;
    }
    bool operator&amp;lt;(const data&amp;amp; d) const
    {
        return v &amp;lt; d.v;
    }
};
struct node
{
    int ch[2], sz, dup;
    unsigned k;
    data d;
    node(int z = 1) :sz(z), dup(z), k(rnd()) { ch[0] = ch[1] = 0; }
    static unsigned rnd()
    {
        static unsigned r = 0x123;
        r = r * 69069 + 1;
        return r;
    }
};
vector&amp;lt;node&amp;gt; nodes;
vector&amp;lt;int&amp;gt; recycle;
int root;
int reserve_size;
void reserve()
{
    if (size() &amp;gt;= reserve_size)
        nodes.reserve((reserve_size *= 2) + 1);
}
int new_node()
{
    int id = (int)nodes.size();
    if (!recycle.empty())
    {
        id = recycle.back();
        recycle.pop_back();
        nodes[id] = node();
    }
    else nodes.push_back(node());
    return id;
}
void update(int tp)
{
    node&amp;amp; n = nodes[tp];
    n.sz = n.dup + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
}
int insert(int&amp;amp; tp, const data&amp;amp; d)
{
    if (tp == 0)
    {
        tp = new_node();
        nodes[tp].d = d;
        return tp;
    }
    node&amp;amp; n = nodes[tp];
    ++n.sz;
    if (d == n.d)
    {
        ++n.dup;
        return tp;
    }
    int r = d &amp;lt; n.d;
    int&amp;amp; s = n.ch[r ^ 1];
    int ret = insert(s, d);
    if (nodes[s].k &amp;lt; n.k) rotate(tp, r ^ 1), update(tp);
    return ret;
}
void rotate(int&amp;amp; tp, int r)
{
    node&amp;amp; n = nodes[tp];
    int s = n.ch[r];
    n.ch[r] = nodes[s].ch[r ^ 1];
    nodes[s].ch[r ^ 1] = tp;
    update(tp);
    tp = s;
}
int find(int tp, const data&amp;amp; d) // return id
{
    if (tp == 0) return 0;
    if (d == nodes[tp].d) return tp;
    return find(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d);
}
int erasefind(int&amp;amp; tp, const data&amp;amp; d) // return deleted
{
    if (tp == 0) return 0;
    if (d == nodes[tp].d)
    {
        --nodes[tp].sz;
        if (--nodes[tp].dup &amp;lt;= 0) remove(tp);
        return 1;
    }
    if (erasefind(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d))
    {
        --nodes[tp].sz;
        return 1;
    }
    return 0;
}
void remove(int&amp;amp; tp)
{
    if (tp == 0) return;
    if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
    {
        recycle.push_back(tp);
        tp = nodes[tp].ch[!nodes[tp].ch[0]];
    }
    else
    {
        int r = nodes[nodes[tp].ch[0]].k &amp;lt; nodes[nodes[tp].ch[1]].k;
        rotate(tp, r ^ 1);
        remove(nodes[tp].ch[r]);
        update(tp);
    }
}
int kth(int tp, int k) // return id
{
    node&amp;amp; n = nodes[tp];
    int sz = nodes[n.ch[0]].sz;
    if (sz &amp;gt;= k) return kth(n.ch[0], k);
    if (sz + n.dup &amp;gt;= k) return tp;
    return kth(n.ch[1], k - sz - n.dup);
}
int rank(int tp, const data&amp;amp; d, int dup)
{
    if (tp == 0) return 1;
    node&amp;amp; n = nodes[tp];
    if (d == n.d) return nodes[n.ch[0]].sz + 1 + dup * n.dup;
    else if (d &amp;lt; n.d) return rank(n.ch[0], d, dup);
    return rank(n.ch[1], d, dup) + nodes[n.ch[0]].sz + n.dup;
}
// interface
void init(int size)
{
    nodes.clear();
    recycle.clear();
    nodes.reserve(size + 1);
    nodes.push_back(node(0));
    root = 0; reserve_size = size;
}
int get(int id) { return nodes[id].d.v; }
int size() { return nodes[root].sz; }
int insert(data v) { reserve(); return insert(root, v); }
int erase(data v) { return erasefind(root, v); }
int find(data v) { return find(root, v); } // return id
int kth(int k) { return kth(root, k); } // return id
// upperbound when upper = 1
int rank(data v, int upper = 0) { return rank(root, v, upper); }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sbt&#34;&gt;SBT&lt;/h2&gt;

&lt;p&gt;这个名字和BST特别像，但它全名是&lt;code&gt;Size Balanced Tree&lt;/code&gt;，作者是&lt;a href=&#34;https://www.zhihu.com/question/30541674&#34; target=&#34;_blank&#34;&gt;CQF&lt;/a&gt;，它通过size字段来进行树平衡。它的关键操作叫做&lt;code&gt;maintain&lt;/code&gt;，这个操作的平摊复杂度是 $O(1)$ ，这货具体解释可以看CQF的论文，SBT的时间常数比Treap更小一些，内存也更小，不过代码也稍长一些（就是因为&lt;code&gt;maintain&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct sbt
{
    struct data
    {
        int v;
        data(int _v = 0) :v(_v) {}
        bool operator==(const data&amp;amp; d) const
        {
            return v == d.v;
        }
        bool operator&amp;lt;(const data&amp;amp; d) const
        {
            return v &amp;lt; d.v;
        }
    };
    struct node
    {
        int ch[2], sz, dup;
        data d;
        node(int z = 1) :sz(z), dup(z) { ch[0] = ch[1] = 0; }
    };
    vector&amp;lt;node&amp;gt; nodes;
    vector&amp;lt;int&amp;gt; recycle;
    int root;
    int reserve_size;
    void reserve()
    {
        if (size() &amp;gt;= reserve_size)
            nodes.reserve((reserve_size *= 2) + 1);
    }
    int new_node()
    {
        int id = (int)nodes.size();
        if (!recycle.empty())
        {
            id = recycle.back();
            recycle.pop_back();
            nodes[id] = node();
        }
        else nodes.push_back(node());
        return id;
    }
    void update(int tp)
    {
        node&amp;amp; n = nodes[tp];
        n.sz = n.dup + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;
    }
    int insert(int&amp;amp; tp, const data&amp;amp; d)
    {
        if (tp == 0)
        {
            tp = new_node();
            nodes[tp].d = d;
            return tp;
        }
        node&amp;amp; n = nodes[tp];
        ++n.sz;
        if (d == n.d)
        {
            ++n.dup;
            return tp;
        }
        int r = d &amp;lt; n.d;
        int&amp;amp; s = n.ch[r ^ 1];
        int ret = insert(s, d);
        maintain(tp, r ^ 1);
        return ret;
    }
    void rotate(int&amp;amp; tp, int r)
    {
        node&amp;amp; n = nodes[tp];
        int s = n.ch[r];
        n.ch[r] = nodes[s].ch[r ^ 1];
        nodes[s].ch[r ^ 1] = tp;
        update(tp); update(s);
        tp = s;
    }
    void maintain(int&amp;amp; tp, int s)
    {
        if (tp == 0) return;
        if (nodes[nodes[nodes[tp].ch[s]].ch[s]].sz &amp;gt; nodes[nodes[tp].ch[s ^ 1]].sz)
            rotate(tp, s);
        else if (nodes[nodes[nodes[tp].ch[s]].ch[s ^ 1]].sz &amp;gt; nodes[nodes[tp].ch[s ^ 1]].sz)
        {
            rotate(nodes[tp].ch[s], s ^ 1);
            rotate(tp, s);
        }
        else return;

        maintain(nodes[tp].ch[s], s);
        maintain(nodes[tp].ch[s ^ 1], s ^ 1);
        maintain(tp, s);
        maintain(tp, s ^ 1);
    }

    int find(int tp, const data&amp;amp; d) // return id
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d) return tp;
        return find(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d);
    }
    int erasefind(int&amp;amp; tp, const data&amp;amp; d) // return deleted
    {
        if (tp == 0) return 0;
        if (d == nodes[tp].d)
        {
            --nodes[tp].sz;
            if (--nodes[tp].dup &amp;lt;= 0) remove(tp);
            return 1;
        }
        if (erasefind(nodes[tp].ch[(d &amp;lt; nodes[tp].d) ^ 1], d))
        {
            --nodes[tp].sz;
            return 1;
        }
        return 0;
    }
    void remove(int&amp;amp; tp)
    {
        if (tp == 0) return;
        if (!nodes[tp].ch[0] || !nodes[tp].ch[1])
        {
            recycle.push_back(tp);
            tp = nodes[tp].ch[!nodes[tp].ch[0]];
        }
        else
        {
            int r = nodes[nodes[tp].ch[0]].sz &amp;gt;= nodes[nodes[tp].ch[1]].sz;
            rotate(tp, r ^ 1);
            remove(nodes[tp].ch[r]);
            update(tp);
        }
    }
    int kth(int tp, int k) // return id
    {
        node&amp;amp; n = nodes[tp];
        int sz = nodes[n.ch[0]].sz;
        if (sz &amp;gt;= k) return kth(n.ch[0], k);
        if (sz + n.dup &amp;gt;= k) return tp;
        return kth(n.ch[1], k - sz - n.dup);
    }
    int rank(int tp, const data&amp;amp; d, int dup)
    {
        if (tp == 0) return 1;
        node&amp;amp; n = nodes[tp];
        if (d == n.d) return nodes[n.ch[0]].sz + 1 + dup * n.dup;
        else if (d &amp;lt; n.d) return rank(n.ch[0], d, dup);
        return rank(n.ch[1], d, dup) + nodes[n.ch[0]].sz + n.dup;
    }
    // interface
    void init(int size)
    {
        nodes.clear();
        recycle.clear();
        nodes.reserve(size + 1);
        nodes.push_back(node(0));
        root = 0; reserve_size = size;
    }
    int get(int id) { return nodes[id].d.v; }
    int size() { return nodes[root].sz; }
    int insert(data v) { reserve(); return insert(root, v); }
    int erase(data v) { return erasefind(root, v); }
    int find(data v) { return find(root, v); } // return id
    int kth(int k) { return kth(root, k); } // return id
    // upperbound when upper = 1
    int rank(data v, int upper = 0) { return rank(root, v, upper); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;温馨提示&#34;&gt;温馨提示&lt;/h2&gt;

&lt;p&gt;别看代码长，如果你还没自己实现过，硬着头皮写一次，你就懂了，核心其实只有那么点。以上没有实现插入相等元素后用链表串起来，实在有需要时自己加一下就好了。又或者，如果你不需要处理相同元素，那么代码也有不少的简化，特别是删除元素的地方。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线段树</title>
      <link>/post/20191208-segtree/</link>
      <pubDate>Sun, 08 Dec 2019 18:26:00 +0800</pubDate>
      <guid>/post/20191208-segtree/</guid>
      <description>&lt;p&gt;很多人在初始接触线段树的时候，一看到别人写一大堆代码就直接弃坑了，其实不要被它的外表所欺骗，线段树其实是相当好写的树结构了，而且理解起来其实很简单。要学会这个，你不能光会抄模板就会区间修改和求个区间和，因为实际应用经常会使用它的变形，还是在于理解&lt;del&gt;（理解后背板）&lt;/del&gt;。&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;p&gt;首先，回想一下heap的结构，它使用一个数组，同时使用下标本身来表达父子关系，这样的方式能节省大量指针所需要的内存空间，以下也使用这种表示方法来表示一棵线段树，也就是说，这里介绍的，属于&lt;strong&gt;狭义线段树&lt;/strong&gt;。假设我们的数据是以下这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;构建线段树后结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16--&amp;gt;1,4:8
1,8:16--&amp;gt;5,8:8
1,4:8--&amp;gt;1,2:1
1,4:8--&amp;gt;3,4:7
1,2:1--&amp;gt;1,1:1
1,2:1--&amp;gt;2,2:0
3,4:7--&amp;gt;3,3:5
3,4:7--&amp;gt;4,4:2
5,8:8--&amp;gt;5,6:7
5,8:8--&amp;gt;7,8:1
5,6:7--&amp;gt;5,5:3
5,6:7--&amp;gt;6,6:4
7,8:1--&amp;gt;7,7:0
7,8:1--&amp;gt;8,8:1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冒号前面的两个数表示一条线段，冒号后表示的是数据，这个数据表示的是这个区间的和。如此一来，我们查询一个区间的和，可以很快地计算出来，例如求&lt;code&gt;[1,6]&lt;/code&gt;的和，那么需要拆分为&lt;code&gt;[1,4]&lt;/code&gt;与&lt;code&gt;[5,6]&lt;/code&gt;的和，分别是8和7，所以结果是&lt;code&gt;8+7=15&lt;/code&gt;，原理就是这样而已。&lt;/p&gt;

&lt;h2 id=&#34;单点数据更新&#34;&gt;单点数据更新&lt;/h2&gt;

&lt;p&gt;单点更新时，可以参考树状数组，先更新子节点，然后向上找父节点更新即可，也可以递归实现，这不在本节讨论范围。不过如果你确实只需要单点修改，那么可以考虑ZKW线段树，ZKW线段树是先更新子节点，然后向上找父节点更新，由于少了很多递归，常数比递归的线段树要小。后文提供一个简易的模板作为参考。&lt;/p&gt;

&lt;h2 id=&#34;区间数据更新&#34;&gt;区间数据更新&lt;/h2&gt;

&lt;p&gt;例如，我们希望对区间&lt;code&gt;[3,5]&lt;/code&gt;上的数都加上2，这时候需要引入懒惰标记，其实就是把操作记录在父节点上，有必要时再向下传递。像刚才的例子，都加上懒惰标记后&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16,0--&amp;gt;1,4:8,0
1,8:16,0--&amp;gt;5,8:8,0
1,4:8,0--&amp;gt;1,2:1,0
1,4:8,0--&amp;gt;3,4:7,0
1,2:1,0--&amp;gt;1,1:1,0
1,2:1,0--&amp;gt;2,2:0,0
3,4:7,0--&amp;gt;3,3:5,0
3,4:7,0--&amp;gt;4,4:2,0
5,8:8,0--&amp;gt;5,6:7,0
5,8:8,0--&amp;gt;7,8:1,0
5,6:7,0--&amp;gt;5,5:3,0
5,6:7,0--&amp;gt;6,6:4,0
7,8:1,0--&amp;gt;7,7:0,0
7,8:1,0--&amp;gt;8,8:1,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后对区间&lt;code&gt;[3,5]&lt;/code&gt;上的数都加上2，那么把这个区间拆分为&lt;code&gt;[3,4]&lt;/code&gt;和&lt;code&gt;[5,5]&lt;/code&gt;，更新标记&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16,0--&amp;gt;1,4:8,0
1,8:16,0--&amp;gt;5,8:8,0
1,4:8,0--&amp;gt;1,2:1,0
1,4:8,0--&amp;gt;3,4:11,2
1,2:1,0--&amp;gt;1,1:1,0
1,2:1,0--&amp;gt;2,2:0,0
3,4:11,2--&amp;gt;3,3:5,0
3,4:11,2--&amp;gt;4,4:2,0
5,8:8,0--&amp;gt;5,6:7,0
5,8:8,0--&amp;gt;7,8:1,0
5,6:7,0--&amp;gt;5,5:5,2
5,6:7,0--&amp;gt;6,6:4,0
7,8:1,0--&amp;gt;7,7:0,0
7,8:1,0--&amp;gt;8,8:1,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，&lt;code&gt;[3,3]&lt;/code&gt;和&lt;code&gt;[4,4]&lt;/code&gt;都没有更新，更新在&lt;code&gt;[3,4]&lt;/code&gt;上了，那么接下来需要查询&lt;code&gt;[3,3]&lt;/code&gt;的话，就把标记向下传递一层，变成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
1,8:16,0--&amp;gt;1,4:8,0
1,8:16,0--&amp;gt;5,8:8,0
1,4:8,0--&amp;gt;1,2:1,0
1,4:8,0--&amp;gt;3,4:11,0
1,2:1,0--&amp;gt;1,1:1,0
1,2:1,0--&amp;gt;2,2:0,0
3,4:11,0--&amp;gt;3,3:7,2
3,4:11,0--&amp;gt;4,4:4,2
5,8:8,0--&amp;gt;5,6:7,0
5,8:8,0--&amp;gt;7,8:1,0
5,6:7,0--&amp;gt;5,5:5,2
5,6:7,0--&amp;gt;6,6:4,0
7,8:1,0--&amp;gt;7,7:0,0
7,8:1,0--&amp;gt;8,8:1,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，再获取区间&lt;code&gt;[3,3]&lt;/code&gt;的结果7，就是所需要的答案&lt;/p&gt;

&lt;h2 id=&#34;基础模板&#34;&gt;基础模板&lt;/h2&gt;

&lt;p&gt;以下基础模板只支持区间求和，以及区间整体加上一个数的操作，和&lt;a href=&#34;/post/20191111-fenwicktree/&#34;&gt;树状数组&lt;/a&gt;后面提供的模板实现了相同的功能&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree_add
{
    struct node
    {
        int sum;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d; // 仿heap的形式保存线段树
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    // 当前tp节点对应的线段区间为[tl,tr]，更新区间是[l,r]
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl + 1) * v;
            d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 更新左右儿子
        if (l &amp;lt;= tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid + 1, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    int get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 统计左右儿子
        int sum = 0;
        if (l &amp;lt;= tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid + 1, tr, rson(tp));
        return sum;
    }
    void init(int size) // 可操作下标范围为0~size-1，如需要从1开始那么要+1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz; // 扩展为满二叉树
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r, v, 0, sz - 1, 0);
    }
    int get_sum(int l, int r)
    {
        return get_sum(l, r, 0, sz - 1, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法，调用init初始化范围（注意下标从0到size-1，下标要从1开始的话要size+1，否则如果size正好是2的k次方时操作下标为size时会出问题），然后通过&lt;code&gt;update_add&lt;/code&gt;和&lt;code&gt;get_sum&lt;/code&gt;更新数据即可。&lt;/p&gt;

&lt;p&gt;另外一点，这个模板实现没有使用左闭右开区间来写，如果改用左闭右开区间，并添加build实现，则得到如下实现（代码有少许简化且更对称更好读）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree_add
{
    struct node
    {
        int sum;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl) * v;
            d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 更新左右儿子
        if (l &amp;lt; tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    int get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        // 统计左右儿子
        int sum = 0;
        if (l &amp;lt; tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid, tr, rson(tp));
        return sum;
    }
    void build(int a[], int alen, int tl, int tr, int tp)
    {
        if (tl + 1 == tr)
        {
            if (tl &amp;lt; alen)
                d[tp].sum = a[tl];
            else
                d[tp].sum = 0;
            return;
        }
        int tmid = (tl + tr) / 2;
        build(a, alen, tl, tmid, lson(tp));
        build(a, alen, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
        d[tp].lz_add = 0;
    }
    void build(int a[], int alen)
    {
        build(a, alen, 0, sz, 0);
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r + 1, v, 0, sz, 0);
    }
    int get_sum(int l, int r)
    {
        return get_sum(l, r + 1, 0, sz, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;进阶模板&#34;&gt;进阶模板&lt;/h2&gt;

&lt;p&gt;如果你需要支持区间整体加上某个数，同时支持区间整体设置为指定数，那么就需要多重懒惰标记，模板可以改写如下（闭区间实现）&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree
{
    static const int lz_mark = 0x80000000;
    struct node
    {
        int sum;
        int lz_set;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl + 1) * v;
            if (d[tp].lz_set != lz_mark) d[tp].lz_set += v;
            else d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid + 1, tr, d[tp].lz_set, tmid + 1, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt;= tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid + 1, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    void update_set(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum = (tr - tl + 1) * v; //区间和
            d[tp].lz_set = v;
            d[tp].lz_add = 0;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid + 1, tr, d[tp].lz_set, tmid + 1, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt;= tmid) update_set(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_set(l, r, v, tmid + 1, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    int get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid + 1, tr, d[tp].lz_set, tmid + 1, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid + 1, tr, d[tp].lz_add, tmid + 1, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        int sum = 0;
        if (l &amp;lt;= tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid + 1, tr, rson(tp));
        return sum;
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r, v, 0, sz - 1, 0);
    }
    void update_set(int l, int r, int v)
    {
        update_set(l, r, v, 0, sz - 1, 0);
    }
    int get_sum(int l, int r)
    {
        return get_sum(l, r, 0, sz - 1, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;左闭右开区间实现（接口为闭区间）&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree
{
    static const int lz_mark = 0x80000000;
    struct node
    {
        int sum;
        int lz_set;
        int lz_add;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    void update_add(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum += (tr - tl) * v;
            if (d[tp].lz_set != lz_mark) d[tp].lz_set += v;
            else d[tp].lz_add = v;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid, tr, d[tp].lz_set, tmid, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt; tmid) update_add(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_add(l, r, v, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    void update_set(int l, int r, int v, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            d[tp].sum = (tr - tl) * v; //区间和
            d[tp].lz_set = v;
            d[tp].lz_add = 0;
            return;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid, tr, d[tp].lz_set, tmid, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        if (l &amp;lt; tmid) update_set(l, r, v, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) update_set(l, r, v, tmid, tr, rson(tp));
        d[tp].sum = d[lson(tp)].sum + d[rson(tp)].sum;
    }
    ll get_sum(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].sum;
        }
        int tmid = (tl + tr) / 2;
        // 下发lazy标志一层
        if (d[tp].lz_set != lz_mark)
        {
            update_set(tl, tmid, d[tp].lz_set, tl, tmid, lson(tp));
            update_set(tmid, tr, d[tp].lz_set, tmid, tr, rson(tp));
            d[tp].lz_set = lz_mark;
        }
        else if (d[tp].lz_add != 0)
        {
            update_add(tl, tmid, d[tp].lz_add, tl, tmid, lson(tp));
            update_add(tmid, tr, d[tp].lz_add, tmid, tr, rson(tp));
            d[tp].lz_add = 0;
        }
        int sum = 0;
        if (l &amp;lt; tmid) sum += get_sum(l, r, tl, tmid, lson(tp));
        if (r &amp;gt; tmid) sum += get_sum(l, r, tmid, tr, rson(tp));
        return sum;
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int l, int r, int v)
    {
        update_add(l, r + 1, v, 0, sz, 0);
    }
    void update_set(int l, int r, int v)
    {
        update_set(l, r + 1, v, 0, sz, 0);
    }
    ll get_sum(int l, int r)
    {
        return get_sum(l, r + 1, 0, sz, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;简易区间最值模板（就是简易得只有查询，如果要支持更新就自己加上）&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;
  &lt;h4&gt; 点击展开 &lt;/h4&gt;
&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct seg_tree
{
    struct node
    {
        int max;
        int min;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    inline int lson(int tp) { return tp * 2 + 1; }
    inline int rson(int tp) { return tp * 2 + 2; }
    int get_max(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].max;
        }
        int tmid = (tl + tr) / 2;
        int ret = INT_MIN;
        if (l &amp;lt; tmid) ret = max(ret, get_max(l, r, tl, tmid, lson(tp)));
        if (r &amp;gt; tmid) ret = max(ret, get_max(l, r, tmid, tr, rson(tp)));
        return ret;
    }
    int get_min(int l, int r, int tl, int tr, int tp)
    {
        if (l &amp;lt;= tl &amp;amp;&amp;amp; tr &amp;lt;= r)
        {
            return d[tp].min;
        }
        int tmid = (tl + tr) / 2;
        int ret = INT_MAX;
        if (l &amp;lt; tmid) ret = min(ret, get_min(l, r, tl, tmid, lson(tp)));
        if (r &amp;gt; tmid) ret = min(ret, get_min(l, r, tmid, tr, rson(tp)));
        return ret;
    }
    void build(int a[], int alen, int tl, int tr, int tp)
    {
        if (tl + 1 == tr)
        {
            if (tl &amp;lt; alen)
            {
                d[tp].max = a[tl];
                d[tp].min = a[tl];
            }
            else
            {
                d[tp].max = 0;
                d[tp].min = 0;
            }
            return;
        }
        int tmid = (tl + tr) / 2;
        build(a, alen, tl, tmid, lson(tp));
        build(a, alen, tmid, tr, rson(tp));
        d[tp].max = max(d[lson(tp)].max, d[rson(tp)].max);
        d[tp].min = min(d[lson(tp)].min, d[rson(tp)].min);
    }
    void build(int a[], int alen)
    {
        build(a, alen, 0, sz, 0);
    }
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    int get_min(int l, int r)
    {
        return get_min(l, r + 1, 0, sz, 0);
    }
    int get_max(int l, int r)
    {
        return get_max(l, r + 1, 0, sz, 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h2 id=&#34;zkw线段树模板&#34;&gt;ZKW线段树模板&lt;/h2&gt;

&lt;p&gt;这是单点修改求区间和的模板，求区间最值稍微改改就好了，如果需要区间修改，那么可以模仿树状数组的办法做差分，或做永久化标记，适应性比递归实现的线段树差一些，优点是常数小，以下实现比前面的大约快30%左右，代码更简单，就不额外解释了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct zkwseg_tree
{
    struct node
    {
        int sum;
    };
    int sz;
    vector&amp;lt;node&amp;gt; d;
    void init(int size) // 可操作下标范围为0~size-1
    {
        sz = size;
        while (sz &amp;amp; (sz - 1)) sz += sz&amp;amp;-sz;
        d.resize(sz * 2);
    }
    void update_add(int p, int v)
    {
        int i = sz + p;
        while (i)
        {
            d[i].sum += v;
            i &amp;gt;&amp;gt;= 1;
        }
    }
    int get_sum(int l, int r)
    {
        int sum = 0;
        l += sz;
        r += sz + 1;
        for (; l &amp;lt; r; l&amp;gt;&amp;gt;=1, r&amp;gt;&amp;gt;=1)
        {
            if (l &amp;amp; 1)
            {
                sum += d[l++].sum;
            }
            if (r &amp;amp; 1)
            {
                sum += d[--r].sum;
            }
        }
        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其它说明&#34;&gt;其它说明&lt;/h2&gt;

&lt;p&gt;以上模板为了解释简单，有的实现只有&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;get_sum&lt;/code&gt;操作，并没有&lt;code&gt;build&lt;/code&gt;的部分，只使用&lt;code&gt;update&lt;/code&gt;即可完成build的操作，时间复杂度也是一样的。除了维护区间和，也可以维护区间最大最小值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>后缀数组</title>
      <link>/post/20191113-suffixarray/</link>
      <pubDate>Wed, 13 Nov 2019 18:26:00 +0800</pubDate>
      <guid>/post/20191113-suffixarray/</guid>
      <description>&lt;p&gt;后缀数组其实概念很好理解，就是给出一个字符串，长度是n，对它所有的n个后缀编号从1到n进行排序，排序后，最小的那个后缀的编号假设是m1，那么&lt;code&gt;sa[1] = m1&lt;/code&gt;，类似地，第二小的是m2的话，&lt;code&gt;sa[2] = m2&lt;/code&gt;，sa这个数组就是我们所需要的后缀数组。根据这个，我们可以直接用sort算出sa，以下为最简单的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_simple
{
    vector&amp;lt;int&amp;gt; sa;
    int s_size;
    const char* p_s;
    int size() const
    {
        return s_size;
    }
    static bool cmp(const char* x, const char* y)
    {
        return strcmp(x, y) &amp;lt; 0;
    }
    void init(char * str)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;

        sa.resize(n + 1);
        vector&amp;lt; const char* &amp;gt; rp;
        rp.resize(n + 1);

        for (int i = 1; i &amp;lt;= n; ++i)
        {
            rp[i] = p_s + i;
        }
        sort(rp.begin() + 1, rp.end(), cmp);
        for (int i = 1; i &amp;lt;= n; ++i)
        {
            sa[i] = rp[i] - p_s;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现的时间复杂度 $O(n^2logn)$&lt;/p&gt;

&lt;p&gt;要注意的一点是下标从1开始。有了这个，可以做点什么呢？例如给你一个串p，求出p在主串s中出现了多少次。那么在有了sa的情况下，因为sa是有序的，问题就变成了二分搜索，分别用&lt;code&gt;lower_bound&lt;/code&gt;和&lt;code&gt;upper_bound&lt;/code&gt;通过sa搜索p，两个相减便得出现次数。&lt;/p&gt;

&lt;h2 id=&#34;rank-数组&#34;&gt;rank 数组&lt;/h2&gt;

&lt;p&gt;光有sa其实还不够用，我们还需要rank数组，&lt;code&gt;rank[m]&lt;/code&gt;的值是p的话，那么表示字符串中编号m的后缀，它的排名是p，即与sa数组是互逆，所以我们可以得到 &lt;code&gt;sa[rank[i]] == rank[sa[i]] == i&lt;/code&gt; ，也就是说通过rank，可以快速判断某两个后缀的大小关系。&lt;/p&gt;

&lt;h2 id=&#34;height-数组&#34;&gt;height 数组&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;height[i]&lt;/code&gt;的值表示的是，&lt;code&gt;sa[i-1]&lt;/code&gt;与&lt;code&gt;sa[i]&lt;/code&gt;这两个后缀的相同前缀长度，特别地，&lt;code&gt;height[1] == 0&lt;/code&gt;，求解height需要用到rank数组和sa数组，以及如下引理&lt;/p&gt;

&lt;p&gt;$$height[rank[i]]\ge height[rank[i-1]]-1$$&lt;/p&gt;

&lt;p&gt;通过以上引理直接暴力实现即可，复杂度 $O(n)$ ，这里不做证明。&lt;/p&gt;

&lt;p&gt;三个数组的完整实现如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_simple
{
    vector&amp;lt;int&amp;gt; sa, rk, ht;
protected:
    int s_size;
    const char* p_s;
public:
    int size() const
    {
        return s_size;
    }

    static bool cmp(const char* x, const char* y)
    {
        return strcmp(x, y) &amp;lt; 0;
    }

    void init(char * str, bool h = true)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;

        sa.resize(n + 1);
        rk.resize(n + 1);
        vector&amp;lt;const char*&amp;gt; rp;
        rp.resize(n + 1);

        for (int i = 1; i &amp;lt;= n; ++i)
        {
            rp[i] = p_s + i;
        }
        sort(rp.begin() + 1, rp.end(), cmp);
        for (int i = 1; i &amp;lt;= n; ++i)
        {
            sa[i] = rp[i] - p_s;
            rk[sa[i]] = i;
        }
        if (h) create_height();
    }
    void create_height()
    {
        ht.resize(s_size + 1);
        for (int i = 1, k = 0; i &amp;lt;= s_size; ++i)
        {
            if (k) --k;
            while (p_s[i + k] == p_s[sa[rk[i] - 1] + k])
                ++k;
            ht[rk[i]] = k;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;应用1-可重叠最长重复子串&#34;&gt;应用1 可重叠最长重复子串&lt;/h2&gt;

&lt;p&gt;这个题目在本博客讲&lt;a href=&#34;/post/20191028-kmp/&#34;&gt;kmp&lt;/a&gt;部分已经有介绍，例如&lt;code&gt;eabcaefabcabc&lt;/code&gt;，最长重复子串是&lt;code&gt;abca&lt;/code&gt;，长度是4，这里介绍用后缀数组的解法。其实所谓的最长重复子串，就是找到两个后缀，让它们的公共前缀最长，那这就简单了，我们只要在height数组里找最大值就可以了，查找时间 $O(n)$ 。&lt;/p&gt;

&lt;h2 id=&#34;应用2-不同子串的个数&#34;&gt;应用2 不同子串的个数&lt;/h2&gt;

&lt;p&gt;来看这道题 &lt;a href=&#34;https://vjudge.net/problem/SPOJ-DISUBSTR&#34; target=&#34;_blank&#34;&gt;SPOJ-DISUBSTR&lt;/a&gt; ，说的是统计一个字符串里有多少不同的子串。&lt;/p&gt;

&lt;p&gt;这里我们就需要用到height数组，由于它表示的正是和前一个后缀的相同前缀长度，那么我们对任意的后缀&lt;code&gt;sa[i]&lt;/code&gt;，取这个后缀的长度，即&lt;code&gt;len(s)-sa[i]&lt;/code&gt;，减去&lt;code&gt;height[i]&lt;/code&gt;再加上1，即表示&lt;code&gt;sa[i]&lt;/code&gt;这个后缀有多少个前缀与&lt;code&gt;sa[i-1]&lt;/code&gt;不相同，所以我们累加即可。核心代码也就这么几行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sum_h = 0;
for (int i = 1; i &amp;lt;= sa.size(); ++i)
{
    sum_h += sa.size() - sa.sa[i] - sa.ht[i] + 1;
}
printf(&amp;quot;%d\n&amp;quot;, sum_h);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许有人会发现问题了，这个题直接用hash实现，才 $O(n^2)$ 的复杂度，这个后缀数组的实现，光是生成就 $O(n^2logn)$ ，不是还更慢吗？单看时间复杂度的确是这样，但事实上后缀数组可以0ms通过，hash实现约400ms左右。&lt;/p&gt;

&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;

&lt;p&gt;直接排序的后缀数组确实过于暴力了，虽然不少题目已经足够AC，但我们还有更好的，这里简要介绍倍增法。假设对字符串&amp;rdquo;ababaabb&amp;rdquo;求后缀数组，那么先对每一个字符做排序，计算出它们的rank，注意相同串的rank结果要相同，结果在下表的&amp;rdquo;排序1&amp;rdquo;，然后我们对每个&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;i+1&lt;/code&gt;在&amp;rdquo;排序1&amp;rdquo;上的rank组合起来，这个组合的key再做排序，如下表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;组合1&lt;/td&gt;
&lt;td&gt;1 2&lt;/td&gt;
&lt;td&gt;2 1&lt;/td&gt;
&lt;td&gt;1 2&lt;/td&gt;
&lt;td&gt;2 1&lt;/td&gt;
&lt;td&gt;1 1&lt;/td&gt;
&lt;td&gt;1 2&lt;/td&gt;
&lt;td&gt;2 2&lt;/td&gt;
&lt;td&gt;2 0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事实上这样得到了所有后缀中，前缀长度为2的排名，接下来，我们步长翻倍，对每个&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;i+2&lt;/code&gt;在&amp;rdquo;排序2&amp;rdquo;上的rank组合起来再排序&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;排序2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;组合2&lt;/td&gt;
&lt;td&gt;2 2&lt;/td&gt;
&lt;td&gt;4 4&lt;/td&gt;
&lt;td&gt;2 1&lt;/td&gt;
&lt;td&gt;4 2&lt;/td&gt;
&lt;td&gt;1 5&lt;/td&gt;
&lt;td&gt;2 3&lt;/td&gt;
&lt;td&gt;5 0&lt;/td&gt;
&lt;td&gt;3 0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事实上这样得到了所有后缀中，前缀长度为4的排名，接下来，我们步长翻倍，对每个&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;i+4&lt;/code&gt;在&amp;rdquo;排序3&amp;rdquo;上的rank组合起来再排序&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;下标&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;排序3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;组合3&lt;/td&gt;
&lt;td&gt;3 1&lt;/td&gt;
&lt;td&gt;7 4&lt;/td&gt;
&lt;td&gt;2 8&lt;/td&gt;
&lt;td&gt;6 5&lt;/td&gt;
&lt;td&gt;1 0&lt;/td&gt;
&lt;td&gt;4 0&lt;/td&gt;
&lt;td&gt;8 0&lt;/td&gt;
&lt;td&gt;5 0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;排序4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;至此，再下一轮的步长是8，已经大于等于字符串长度的时候，rank数组便计算完成了。以下是使用此思路的实现代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_2_sort
{
    vector&amp;lt;int&amp;gt; sa, ht;
    int *rk;
protected:
    vector&amp;lt;int&amp;gt; rk1, rk2;
    int s_size;
    int *p_rk, *o_rk;
    const char* p_s;

    struct SA_2_sort_cmp
    {
        int *rk, w;
        SA_2_sort_cmp(int *_rk, int _w) :rk(_rk), w(_w) {}
        bool operator()(int x, int y) const
        {
            return rk[x] == rk[y] ? rk[x + w] &amp;lt; rk[y + w] : rk[x] &amp;lt; rk[y];
        }
    };
public:
    bool cmp(int x, int y, int w)
    {
        return o_rk[x] == o_rk[y] &amp;amp;&amp;amp; o_rk[x + w] == o_rk[y + w];
    }
    int size() const
    {
        return s_size;
    }
    void init(char * str, bool h = true)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;
        sa.resize(n + 1);
        rk1.clear(); rk1.resize(n * 2 + 2);
        rk2.clear(); rk2.resize(n * 2 + 2);
        p_rk = &amp;amp;*rk1.begin();
        o_rk = &amp;amp;*rk2.begin();

        for (int i = 1; i &amp;lt;= n; ++i) p_rk[i] = p_s[i];

        for (int w = 1, i, p; w &amp;lt; n; w &amp;lt;&amp;lt;= 1)
        {
            // init sa
            for (int i = 1; i &amp;lt;= n; ++i) sa[i] = i;

            sort(sa.begin() + 1, sa.end(), SA_2_sort_cmp(p_rk, w));

            // write new rank
            for (std::swap(p_rk, o_rk), p = 0, i = 1; i &amp;lt;= n; ++i)
                p_rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        }
        rk = p_rk;
        if (n == 1) sa[1] = rk[1] = 1;
        if (h) create_height();
    }
    void create_height()
    {
        int n = s_size;
        ht.resize(n + 1);
        for (int i = 1, k = 0; i &amp;lt;= n; ++i)
        {
            if (k) --k;
            while (p_s[i + k] == p_s[sa[p_rk[i] - 1] + k])
                ++k;
            ht[p_rk[i]] = k;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上实现的时间复杂度是 $O(nlog^2n)$ ，如果你想要更快，那就用 $O(n)$ 的计数排序吧，便可把整体时间复杂度下降到 $O(nlogn)$&lt;/p&gt;

&lt;h2 id=&#34;再优化&#34;&gt;再优化&lt;/h2&gt;

&lt;p&gt;绝大多数情况下，使用以上方法 $O(nlogn)$ 复杂度已经够用了，但如果你是一个更有追求的人，可以继续学习 $O(n)$ 复杂度建立后缀数组的办法，名字叫做&lt;code&gt;SA-IS&lt;/code&gt;和&lt;code&gt;DC3&lt;/code&gt;，你可以通过搜索以上两个名字得到更具体的介绍，本文就只介绍到这里。&lt;/p&gt;

&lt;h2 id=&#34;o-nlogn-模板&#34;&gt;$O(nlogn)$ 模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct SA_2
{
    vector&amp;lt;int&amp;gt; sa, ht;
    int *rk;
protected:
    vector&amp;lt;int&amp;gt; rk1, rk2;
    int s_size;
    int *p_rk, *o_rk;
    const char* p_s;
public:
    bool cmp(int x, int y, int w)
    {
        return o_rk[x] == o_rk[y] &amp;amp;&amp;amp; o_rk[x + w] == o_rk[y + w];
    }
    int size() const
    {
        return s_size;
    }
    void init(char * str, bool h = true)
    {
        int n = strlen(str);
        s_size = n;
        p_s = str - 1;
        int cnt_size = max(256, n) + 1;
        vector&amp;lt;int&amp;gt; vid, vpx, vcnt;
        sa.resize(n + 1);
        rk1.clear(); rk1.resize(n * 2 + 2);
        rk2.clear(); rk2.resize(n * 2 + 2);
        vid.resize(n + 1); vpx.resize(n + 1);
        vcnt.resize(cnt_size);
        int* id = &amp;amp;*vid.begin();
        int* px = &amp;amp;*vpx.begin();
        int* cnt = &amp;amp;*vcnt.begin();
        p_rk = &amp;amp;*rk1.begin();
        o_rk = &amp;amp;*rk2.begin();

        int m = 128, p = 0;
        for (int i = 1; i &amp;lt;= n; ++i) ++cnt[p_rk[i] = p_s[i]];
        for (int i = 1; i &amp;lt;= m; ++i) cnt[i] += cnt[i - 1];
        for (int i = n; i &amp;gt;= 1; --i) sa[cnt[p_rk[i]]--] = i;

        for (int w = 1, i; w &amp;lt; n; w &amp;lt;&amp;lt;= 1, m = p)
        {
            // init id
            for (p = 0, i = n; i &amp;gt; n - w; --i)
                id[++p] = i;
            for (int i = 1; i &amp;lt;= n; ++i)
                if (sa[i] &amp;gt; w) id[++p] = sa[i] - w;

            sort(cnt, id, px, n, m);

            // write new rank
            for (std::swap(p_rk, o_rk), p = 0, i = 1; i &amp;lt;= n; ++i)
                p_rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        }
        rk = p_rk;
        if (n == 1) sa[1] = rk[1] = 1;
        if (h) create_height();
    }
    void sort(int* cnt, int* id, int* px, int n, int m)
    {
        memset(cnt, 0, sizeof(int) * (m + 1));
        for (int i = 1; i &amp;lt;= n; ++i)
            ++cnt[px[i] = p_rk[id[i]]];
        for (int i = 1; i &amp;lt;= m; ++i)
            cnt[i] += cnt[i - 1];
        for (int i = n; i &amp;gt;= 1; --i)
            sa[cnt[px[i]]--] = id[i];
    }
    void create_height()
    {
        int n = s_size;
        ht.resize(n + 1);
        for (int i = 1, k = 0; i &amp;lt;= n; ++i)
        {
            if (k) --k;
            while (p_s[i + k] == p_s[sa[p_rk[i] - 1] + k])
                ++k;
            ht[p_rk[i]] = k;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>树状数组</title>
      <link>/post/20191111-fenwicktree/</link>
      <pubDate>Mon, 11 Nov 2019 13:32:00 +0800</pubDate>
      <guid>/post/20191111-fenwicktree/</guid>
      <description>&lt;p&gt;树状数组，是一个用于在近似 $O(logn)$ 时间内动态修改以及查询前缀和的数据结构，以下我们先来看以下树关系表格&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里表达的是，16的子节点有8, 12, 14, 15&lt;/p&gt;

&lt;p&gt;8的子节点有4, 6, 7&lt;/p&gt;

&lt;p&gt;12的子节点有10, 11，即夹在12与它的同级节点8之间&lt;/p&gt;

&lt;p&gt;我们把数值与它的二进制一起形象化画出下图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
2,0010--&amp;gt;1,0001
4,0100--&amp;gt;3,0011
4,0100--&amp;gt;2,0010
6,0110--&amp;gt;5,0101
8,1000--&amp;gt;7,0111
8,1000--&amp;gt;6,0110
8,1000--&amp;gt;4,0100
10,1010--&amp;gt;9,1001
12,1100--&amp;gt;11,1011
12,1100--&amp;gt;10,1010
14,1110--&amp;gt;13,1101
16,10000--&amp;gt;8,1000
16,10000--&amp;gt;12,1100
16,10000--&amp;gt;14,1110
16,10000--&amp;gt;15,1111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样构造的原理是运用到一个二进制运算技巧，假设一个节点x，那么它的父节点就是&lt;code&gt;x + (x &amp;amp; -x)&lt;/code&gt;，其中，&lt;code&gt;x &amp;amp; -x&lt;/code&gt;是去掉右起第一个1的左边的1，例如x如果是6，二进制是110，只保留最右边的1结果就是10了，所以6的父节点就是&lt;code&gt;6+2=8&lt;/code&gt;，更多的可以参考这篇&lt;a href=&#34;/post/20191012-binary-skill/&#34;&gt;二进制技巧&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;前缀和&#34;&gt;前缀和&lt;/h2&gt;

&lt;p&gt;给一个数组a，如果我们需要计算前n个元素的和 $\sum_{i=1}^n{a[i]}$ ，直接累加是很慢的，这里我们用树状数组，我们规定，每个节点保存的值，是它和它的子节点的和，我们用数组 &lt;code&gt;9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1&lt;/code&gt; 画个表格，注意数组下标从1开始。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;66&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那有了这个表，我们要是求出前4个数的和，直接看第4列是30，答案就出来了，因为它上面的数就是它和它所有子结点的和。但如果是别的数呢，例如要求前7个数的和，就不能光看第7列了，需要把第4列、第6列和第7列的3个数相加，即&lt;code&gt;30+9+3=42&lt;/code&gt;就是前7个数的和。注意到这三列其实就是三个同级节点，而且我们通过7这个数本身可以轻松计算前两列的数，计算的方法是&lt;code&gt;x - (x &amp;amp; -x)&lt;/code&gt;，把&lt;code&gt;x=7&lt;/code&gt;代入，得到6，再把6代入，得到4，再把4代入，得到0，0就结束了，而在这个迭代的过程里，就知道我们应该把4,6,7三列的数相加。&lt;/p&gt;

&lt;p&gt;再换一个数，例如11呢，把&lt;code&gt;x=11&lt;/code&gt;代入，得到10，再把10代入，得到8，再把8代入，得到0，所以我们应该把8,10,11三列的数加起来，即&lt;code&gt;44+1+6=51&lt;/code&gt;就是前11个数的和。&lt;/p&gt;

&lt;p&gt;把以上过程写成函数，就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sum(int fwtree[], int x)
{
    int r = 0;
    while (x &amp;gt; 0)
    {
        r += fwtree[x];
        x -= x&amp;amp;-x;
    }
    return r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，这段代码的时间复杂度近似是 $O(logx)$&lt;/p&gt;

&lt;h2 id=&#34;动态维护&#34;&gt;动态维护&lt;/h2&gt;

&lt;p&gt;还是前面的数组 &lt;code&gt;9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1&lt;/code&gt; ，现在假如已经计算好了树状数组，但我们需要对第6个元素，让它减少6，怎么操作呢，其实很简单，根据定义，在子节点修改的时候，让它的所有父节点都做相同的修改，那么6的父节点分别有8,16，所以我们对第6,8,16列都一起减少6，得到以下新表格&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;16&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;-2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这样就维护完成了，所以咱们的实现代码也非常的简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void add(int fwtree[], int treesize, int x, int add)
{
    while (x &amp;lt;= treesize)
    {
        fwtree[x] += add;
        x += x&amp;amp;-x;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;区间和&#34;&gt;区间和&lt;/h2&gt;

&lt;p&gt;我们之所以需要前缀和，就是为了能快速求区间和。例如我们需要求出数组第i个到第j个元素的和，那么我们用&lt;code&gt;sum(x)&lt;/code&gt;表示前x个元素的和，那么可以转化为求&lt;code&gt;sum(j) - sum(i-1)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;区间操作-单点查询&#34;&gt;区间操作+单点查询&lt;/h2&gt;

&lt;p&gt;因为树状数组的修改是单点修改，即每次只能修改一个数，那么现在我们提出一个新问题，如果我们需要多次做区间操作（整个区间的数同时加上y），然后查询数组里面指定第k个元素是什么，例如这个题&lt;a href=&#34;https://loj.ac/problem/131&#34; target=&#34;_blank&#34;&gt;loj131&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于树状数组不能快速做区间操作，我们用到另一个技巧叫做差分法，我们对数组 &lt;code&gt;9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1&lt;/code&gt;求相邻元素的差，得到新的数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样做了后，如果我们要求出原来第k个元素，那么就是求前k个元素之和，所以如果第i个元素加上a，那么相当于i后面所有元素都加上a。&lt;/p&gt;

&lt;p&gt;所以，这时候的区间操作，就会变成单点操作，例如我们要对区间&lt;code&gt;[i,j]&lt;/code&gt;所有的元素加上a，那么在差分了以后，其实就是对第i个元素加上a，再对第j+1个元素减去a。&lt;/p&gt;

&lt;h2 id=&#34;区间操作-区间和&#34;&gt;区间操作+区间和&lt;/h2&gt;

&lt;p&gt;如果我们既要做区间操作，同时还要求区间和怎么办，为了支持区间操作，我们仍然先做差分，然后接下来就是让人头痛的数学推导，假设数组a是原数组，b是a的差分数组，由前缀和的定义，我们求前n个元素的和，即&lt;/p&gt;

&lt;p&gt;$$ \sum_{i=1}^{n} a_i $$&lt;/p&gt;

&lt;p&gt;展开为b数组表达&lt;/p&gt;

&lt;p&gt;$$ = \sum_{i=1}^n{} \sum_{j=1}^i b_j $$&lt;/p&gt;

&lt;p&gt;展开，合并同类项&lt;/p&gt;

&lt;p&gt;$$ = \sum_{i=1}^n b_i\times(n-i+1) $$&lt;/p&gt;

&lt;p&gt;$$ = (n+1)\times\sum_{i=1}^n b_i - \sum_{i=1}^n b_i\times i $$&lt;/p&gt;

&lt;p&gt;那么，我们再定义一个c数组，满足&lt;code&gt;c[i] == b[i] * i&lt;/code&gt;，然后我们再分别对b和c维护一个树状数组，定义&lt;code&gt;sum(b,x)&lt;/code&gt;表示数组b前x个元素的和，&lt;code&gt;sum(c,x)&lt;/code&gt;表示数组c前x个元素的和，那么我们便可以通过计算&lt;code&gt;(x + 1) * sum(b, x) - sum(c, x)&lt;/code&gt;求出数组a的前缀和。&lt;/p&gt;

&lt;p&gt;习题：&lt;a href=&#34;https://loj.ac/problem/132&#34; target=&#34;_blank&#34;&gt;loj132&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;拓展&#34;&gt;拓展&lt;/h2&gt;

&lt;p&gt;树状数组还有一些别的技巧，一是 $O(n)$ 建立，通过已知数组a在 $O(n)$ 时间生成对应的树状数组（直接add来操作是nlogn），这个在这里不做介绍。&lt;/p&gt;

&lt;p&gt;还有权值树状数组求第k小元素。所谓权值树状数组，就是用&lt;code&gt;a[i] = v&lt;/code&gt;来表示数值i重复出现了v次，所以v是非负数，那么这个数组的前缀和就是递增的，即存在二分。然后对数组a维护的树状数组直接二分的话是 $O(lognlogn)$ ，但我们可以运用树状数组的特性优化到 $O(logn)$ ，以下是实现代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int kth(int fwtree[], int size, int k)
{
    int cnt = 0, ret = 0;
    for (int i = (int)(log(size + 0.1) / log(2)); ~i; --i)
    {
        ret += 1 &amp;lt;&amp;lt; i;
        if (ret &amp;gt;= size || cnt + fwtree[ret] &amp;gt;= k)
            ret -= 1 &amp;lt;&amp;lt; i;
        else
            cnt += fwtree[ret];
    }
    return ret + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;权值树状数组还有一个应用，就是用来求&lt;strong&gt;逆序数&lt;/strong&gt;，先对原数组排序求出每个元素的rank，转化为长度n，元素为1~n的一个排列，之后使用权值树状数组，就可以轻松求出在&lt;code&gt;a[1]&lt;/code&gt;到&lt;code&gt;a[i-1]&lt;/code&gt;有多少个元素比&lt;code&gt;a[i]&lt;/code&gt;要大，计算&lt;code&gt;sum(n) - sum(a[i])&lt;/code&gt;便知，把结果累加就是逆序数。&lt;/p&gt;

&lt;h2 id=&#34;模板&#34;&gt;模板&lt;/h2&gt;

&lt;p&gt;区间修改+区间求和模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;vector&amp;gt;
typedef long long ll;


struct fwtree_range
{
    std::vector&amp;lt;int&amp;gt; ta;
    std::vector&amp;lt;ll&amp;gt; tb;
    int sz;
    void init(int size)
    {
        ta.clear(); ta.resize(size + 1);
        tb.clear(); tb.resize(size + 1);
        sz = size;
    }
    void add(int x, int a)
    {
        ll v = a * (ll)x;
        for (; x &amp;lt;= sz; x += x&amp;amp;-x)
        {
            ta[x] += a;
            tb[x] += v;
        }
    }
    template &amp;lt;class T&amp;gt;
    ll sum_t(T&amp;amp; t, int x)
    {
        ll r = 0;
        for (; x &amp;gt; 0; x -= x&amp;amp;-x)
            r += t[x];
        return r;
    }
    ll sum(int x)
    {
        return (x + 1) * sum_t(ta, x) - sum_t(tb, x);
    }
    void range_add(int l, int r, int a)
    {
        add(l, a);
        add(r + 1, -a);
    }
    ll range_sum(int l, int r)
    {
        return sum(r) - sum(l - 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法，调用&lt;code&gt;init&lt;/code&gt;初始化大小后，使用&lt;code&gt;range_add&lt;/code&gt;及&lt;code&gt;range_sum&lt;/code&gt;做区间修改及区间和查询就行了，当然它也支持单点修改和单点查询，你令区间&lt;code&gt;l == r&lt;/code&gt;就行了。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
