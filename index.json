[{"authors":["admin"],"categories":null,"content":"一个喜欢折腾和研究算法的大学生\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"一个喜欢折腾和研究算法的大学生","tags":null,"title":"抱抱熊","type":"authors"},{"authors":null,"categories":["算法"],"content":"本篇针对两种最基本的排序（冒泡、选择）来讲优化思路。越是简单的东西反而可能存在你越想不到的优化点。但是在开始之前，先给不了解的人讲一个设计原则的问题，我们在设计排序接口的时候，最为常见的有\nvoid sort(type arr[], int len)\n也许你也见过\nvoid sort(iter beg, iter end)\n这时候问题就来了，很多人会错误地把end认为是最后一个元素，其实不然，这两接口可以相互转换，例如我们可以写 sort(arr, arr + len) ，这样写很自然对不对，但如果你认为end是最后一个元素，那你就不得不改成 sort(arr, arr + len - 1) 。事实上，这类的接口我们需要一个统一的原则，就是左闭右开区间原则，即beg就是首个元素，而end是最后一个元素+1，即end是作为结束标志，不应该把end算在范围内。接下来下面所有的接口写法，都是以\nvoid sort(iter beg, iter end)\n这种方式写的，至于这样写有什么好处，接下来我们就看示例。\n选择排序 基本实现 我们先来看选择排序，因为它编写简单，而且最不容易出错，我们来看以下两种不同的接口写法，我们定义要排序的数据类型名字是sort_element_t，定义交换函数\nvoid sort_element_swap(sort_element_t *x, sort_element_t *y) { sort_element_t t = *x; *x = *y; *y = t; }  具体实现\nvoid select_sort(sort_element_t arr[], size_t len) //方式1 { for (size_t i = 0; i \u0026lt; len; ++i) { size_t head = i; for (size_t j = i + 1; j \u0026lt; len; ++j) { if (arr[j] \u0026lt; arr[head]) head = j; } sort_element_swap(arr + i, arr + head); } } void select_sort(sort_element_t * beg, sort_element_t * end) //方式2 { for (; beg \u0026lt; end; ++beg) { sort_element_t* head = beg; for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; *head) head = i; } sort_element_swap(beg, head); } }  就这么一眼看过去，看起来还真差不多，这样，我们再细分一下，选择排序的中间那步，其实就是找一个最小的元素，我们单独提取成一个独立函数再来看看\n//方式1 size_t find_min(sort_element_t arr[], size_t beg, size_t len) { size_t head = beg; for (size_t j = beg + 1; j \u0026lt; len; ++j) { if (arr[j] \u0026lt; arr[head]) head = j; } return head; } void select_sort(sort_element_t arr[], size_t len) { for (size_t i = 0; i \u0026lt; len; ++i) { sort_element_swap(arr + i, arr + find_min(arr, i, len)); } }  //方式2 sort_element_t* find_min(sort_element_t * beg, sort_element_t * end) { sort_element_t* head = beg; for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; *head) head = i; } return head; } void select_sort(sort_element_t * beg, sort_element_t * end) { for (; beg \u0026lt; end; ++beg) { sort_element_swap(beg, find_min(beg, end)); } }  仔细观察一下，是不是第二种写法函数参数统一，而且参数数量少，而且也少了很多不必要的加法运算（像方法一需要写arr + i这类）。如果你说方法一的find_min参数也可以只写两个，写成find_min(sort_element_t arr[], size_t len)，那么你在调用的地方将不得不写成find_min(arr + i, len - i)，这种又加又减在遇到更复杂的情况的时候，更容易把你弄晕出Bug。总之结论是最好把参数写成两个指针（或两个迭代器）的形式，不建议使用数组加长度的形式，STL的接口也全使用迭代器的形式。\n对于这个排序要注意的一点是，有人会写成类似下面的形式：\nvoid select_sort(sort_element_t arr[], size_t len) { for (size_t j = 0; j \u0026lt; len; ++j) { for (size_t i = j + 1; i \u0026lt; len; ++i) { if (arr[j] \u0026gt; arr[i]) { sort_element_t t = arr[j]; arr[j] = arr[i]; arr[i] = t; } } } }  以上这种叫做劣化版的选择排序，在大多数的情况下会比前一个方法慢，极端条件下甚至会慢1倍甚至更多\n那说完劣化再讲优化，选择排序的时间复杂度是O(n^2)，而且运行时间与原来的排列完全无关。以上的选择排序总是选择小的，那大小一起选呢？能不能起到优化的作用？如果你单纯的多写一个find_max变成双向选择来做，在VS2005下是没有优化效果的，我测试过了。那应该怎么样呢？确实还是双向选择，不过具体实现稍有点不同。\n优化1，双向选择 这里的实现是一个函数里同时把最大最小一起找，这样减少了一次遍历的过程，时间能减半之余，还有一个非常有用的优化，就是当你发现最大值等于最小值的时候能提前跳出\nsort_element_t* find_min_max( sort_element_t * beg, sort_element_t * end, sort_element_t** head_max) { sort_element_t* head = beg; *head_max = beg; for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; *head) head = i; else if (**head_max \u0026lt; *i) *head_max = i; } return head; } void double_select_sort(sort_element_t * beg, sort_element_t * end) { while (end - beg \u0026gt; 1) { sort_element_t * head_max, * head = find_min_max(beg, end, \u0026amp;head_max); if (head_max != head) { if (head_max == beg) head_max = head; sort_element_swap(beg++, head); sort_element_swap(--end, head_max); } else { break; } } }  与选择排序的运行时间比较如下，排序45000个int，编译环境是VS2015，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时\n   int 1 2 3 4 5 6 7 8 9 10 Avg     select2 0 1114 834 1113 1124 1124 1119 1124 1124 1141 981   select 2213 2238 2227 2229 2256 2242 2238 2241 2245 2260 2238    合理运用双向，效果也往往不错，但是千万要注意，环境不同会导致测试结果不相同，例如你换到mingw上使用-O3编译那么将会是select比select2快，所以上面数据只供参考，具体结果请自己做测试。\n优化2，数据结构 选择排序的优化主要是在find_min上面，find_min的时间复杂度是O(n)，那如果我们通过一些数据结构的组织，例如二叉堆，那么找最大或最小值时间将变成O(1)，而维护这个数据结构的代价是O(logn)的话，总体时间复杂度将变为O(nlogn)，这比起选择排序的O(n^2)就是一个巨大的变化，具体内容在之后的 堆排序 篇具体讲解。\n冒泡排序 基本实现 冒泡排序是我们课本必然介绍的一个排序，相对于选择排序，这种在编写的时候更容易出现逻辑错误，我们先来看典型的实现（双迭代器实现）\nvoid bubble_sort(sort_element_t * beg, sort_element_t * end) { for (; beg \u0026lt; end; --end) { for (sort_element_t * i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-1]) sort_element_swap(i - 1, i); } } }  冒泡排序这种写法，铁定的O(n^2)时间没跑，不过好在冒泡排序的优化方法也不少。\n优化1，提前跳出 void bubble_sort(sort_element_t * beg, sort_element_t * end) { for (; beg \u0026lt; end; --end) { int sorted = 1; for (sort_element_t * i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (sorted) break; } }  通过sorted变量记录某一轮是不是存在交换，如果没有交换则表明数据已经是有序的，可以提前退出循环。有这个优化对于已经有序的数据，冒泡排序将运行得特别快，即最优情况时间复杂度只有O(n)\n优化2，鸡尾酒排序 前面的冒泡写法是单向冒泡，把最大值向最右边移，这回我们做成双向，一边把最大值右移，一边把最小值左移，不过这种方法有另一个命名，叫做鸡尾酒排序\nvoid cocktail_sort(sort_element_t * beg, sort_element_t * end) { while (beg \u0026lt; end) { int sorted = 1; for (sort_element_t * i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (sorted) break; --end; sorted = 1; for (sort_element_t * i = end - 1; i \u0026gt; beg; --i) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (sorted) break; ++beg; } }  那改成双向就真的有提升了吗？我们看实测，排序45000个int，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时\n   int 1 2 3 4 5 6 7 8 9 10 Avg     cocktail 0 0 1313 1502 1614 1674 671 1 2 836 761   bubble 0 0 1245 2286 2329 2332 871 1 4 1459 1052    其中第4组是乱序无重复数值的数据，最有代表性的一列。从中可以看到，cocktail比起bubble能节省30%的时间\n让我们再脑洞大开，除了可以双向，还有一种对CPU执行有利的优化方式\n优化3，奇偶排序 这种排序的排序方式见下表，假设有8个数，奇数轮比较(1,2), (3,4), (5,6), (7,8)，偶数轮比较(2,3), (4,5), (6,7)，如此循环，直到没有交换为止\n   轮次 1 2 3 4 5 6 7 8     0 8 7 6 5 4 3 2 1   1 7 8 5 6 3 4 1 2   2 7 5 8 3 6 1 4 2   3 5 7 3 8 1 6 2 4   4 5 3 7 1 8 2 6 4    具体实现代码如下\nvoid odd_even_sort(sort_element_t * beg, sort_element_t * end) { int sorted = 0, last_sorted = 0; while (sorted == 0) { last_sorted = sorted; sorted = 1; for (sort_element_t * i = beg + 1; i \u0026lt; end; i += 2) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (last_sorted \u0026amp;\u0026amp; sorted) break; last_sorted = sorted; sorted = 1; for (sort_element_t * i = beg + 2; i \u0026lt; end; i += 2) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (last_sorted \u0026amp;\u0026amp; sorted) break; } }  让我们再脑洞大开，除了比较方向，好像我们有一个条件没有考虑上，就是冒泡排序总是相邻元素的比较，那么如果不相邻地比较呢？\n优化4，梳排序 通过一开始设置较大的步长，让元素能较快移动，然后逐步减少步长，直到1变成普通的冒泡排序为止。这个方法的优点，就是快，相对前面的方法来说飞快\nvoid comb_sort(sort_element_t * beg, sort_element_t * end) { const double shrink_factor = 0.8; ptrdiff_t gap = end - beg; int swapped = 0; while (gap \u0026gt; 1 || swapped) { if (gap \u0026gt; 1) { gap = (ptrdiff_t)(gap * shrink_factor); if (gap == 10 || gap == 9) { gap = 11; } } swapped = 0; for (sort_element_t * i = beg + gap; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-gap]) { sort_element_swap(i, i - gap); swapped = 1; } } } }  完整测试 在完整测试里你会发现一些和你想象中完全不一样的情况，可不要以为你的“优化”一定就是优化\nVS2005下的运行时间比较（按Avg平均值排序）    int 1 2 3 4 5 6 7 8 9 10 Avg     combsort 0 0 1 3 3 1 1 0 1 2 1   odd_even 0 0 574 1315 1315 1222 557 0 3 878 586   cocktail 0 0 1313 1502 1614 1674 671 1 2 836 761   select2 0 1114 834 1113 1124 1124 1119 1124 1124 1141 981   bubble 0 0 1245 2286 2329 2332 871 1 4 1459 1052   select 2213 2238 2227 2229 2256 2242 2238 2241 2245 2260 2238    如果你只测试随机数据，那么排序应该是\ncombsort \u0026lt;\u0026lt; select2 \u0026lt; odd_even \u0026lt; cocktail \u0026lt; select \u0026lt; bubble\n在mingw64(gcc8)下使用-O3编译（最大优化）的运行时间比较    int 1 2 3 4 5 6 7 8 9 10 Avg     combsort 0 1 1 2 3 2 2 1 2 3 1   select 497 497 434 501 501 500 501 503 500 502 493   odd_even 0 0 564 1311 1264 1217 562 0 2 882 580   cocktail 0 0 1242 1515 1610 1677 669 0 3 837 755   select2 1 1114 837 1114 1114 1112 1114 1113 1112 1114 974   bubble 0 0 1247 2312 2332 2338 951 0 3 1455 1063    你可以发现，找最小值过程在mingw64下被特别照顾了一下，结果它比其它的明显要快，你可以从中得知，如果你想在mingw下写出运行得快的双向选择排序，如果你的想法是再写一个find_max函数，那对不起，这样是没有优化效果的。但这不是全部，还有让你更大跌眼镜的情况。\n在mingw64(gcc8)下使用-O1编译（基本优化）的运行时间比较    int 1 2 3 4 5 6 7 8 9 10 Avg     combsort 0 0 0 3 3 1 1 0 2 2 1   select2 0 263 375 256 260 258 255 254 531 255 270   odd_even 0 0 597 1287 1256 1204 1368 1 3 780 649   cocktail 0 0 1244 1504 1594 1656 1081 1 3 815 789   bubble 0 0 1241 2091 2117 2115 685 0 3 1247 949   select 2233 2233 2232 2231 2232 2224 2229 2229 2225 2232 2230    现在双向选择不但最快，而且还比-O3下的快得多。老实说，会造成这种奇怪的结果，-O1比-O3还快的原因还真不要问我，找开发gcc/mingw的开发者。\n最后还是忠告一句，千万不要在一个编译器某个编译参数上看到有优化效果，就以为是事实，优化的坑远比你想象的要来得深，并不是你以为优化了它就一定变快了，编译器和编译参数以及运行环境才是你的老大。\n","date":1570511736,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570511736,"objectID":"d460bcc6e133fb754a6ffc672bf1f9c5","permalink":"/post/20191008-sorting-1/","publishdate":"2019-10-08T13:15:36+08:00","relpermalink":"/post/20191008-sorting-1/","section":"post","summary":"本篇针对两种最基本的排序（冒泡、选择）来讲优化思路。越是简单的东西反而可能存在你越想不到的优化点。但是在开始之前，先给不了解的人讲一个设计原则的问题，我们在设计排序接口的时候，最为常见的有\nvoid sort(type arr[], int len)\n也许你也见过\nvoid sort(iter beg, iter end)\n这时候问题就来了，很多人会错误地把end认为是最后一个元素，其实不然，这两接口可以相互转换，例如我们可以写 sort(arr, arr + len) ，这样写很自然对不对，但如果你认为end是最后一个元素，那你就不得不改成 sort(arr, arr + len - 1) 。事实上，这类的接口我们需要一个统一的原则，就是左闭右开区间原则，即beg就是首个元素，而end是最后一个元素+1，即end是作为结束标志，不应该把end算在范围内。接下来下面所有的接口写法，都是以\nvoid sort(iter beg, iter end)\n这种方式写的，至于这样写有什么好处，接下来我们就看示例。\n","tags":["algorithm","sorting","bubblesort","selectionsort","c","c++"],"title":"选择和冒泡排序优化思路","type":"post"},{"authors":null,"categories":["算法"],"content":"我们现在使用的排序，很大比例在使用quick sort，因为它是平均速度最快的排序，但与此同时它可能也是坑最深的排序，现在我们就来讨论讨论它，因为内容较多，我计划写多篇，本篇是第一篇。\n快排的思路 我们先来介绍一下快排的思路。快排的思路其实很简单，在数组中选一个元素，我们就称呼这个元素为pivot，通过与这个元素的比较，把数组划分成不比pivot大的在一边，不比pivot小的在另一边，于是就分成了两个更小的数据，对它们分别再排序就行了。但是，这个描述特别的含糊，首先是怎么选中间元素，这里面有很多不同的做法。然后就是划分了，这个划分方法非常的多，水也特别深，这里主要介绍最为常见的划分方法。\n划分结果分类 首先，就是划分的结果，划分的结果有什么好讲的呢？其实算法的描述只说了划分成不比pivot大的在一边，不比pivot小的在另一边，并没有说等于的数怎么办。事实上，关键就在等于的数怎么处理，你既可以划在其中一边，也可以两边都有，也可以划成3分，中间那块就是等于pivot的，左边是小于等于，右边是大于等于，三种划分结果都是可以的。但是，不能容许的一种情况是划分后只有一块，例如你选的pivot正好是最小的数，于是划分后，整个数组就一块，全是大于等于pivot的，这样很可能导致无限递归，这次划分也白干了。\n所以很多人单凭算法思路来实现的时候，往往陷入栈溢出异常，其实就是划分结果上出了问题，并没有保证每次划分后，至少划分成两块。\n划分手段分类 划分手段的典型方法至少有5种，本篇介绍其中的4种\n1. Lomuto partition scheme 首先我们来看以下代码：\nsort_element_t * partition( sort_element_t * beg, sort_element_t * end) { sort_element_t pivot = *beg; sort_element_t * p = beg; for (sort_element_t * i = beg + 1; i \u0026lt; end; i++) { if (*i \u0026lt; pivot) { sort_element_swap(++p, i); } } sort_element_swap(p, beg); return p; } void quick_sort_recursive( sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { sort_element_t * p = partition(beg, end); quick_sort_recursive(beg, p); quick_sort_recursive(p + 1, end); } }  这种划分方法wiki上有描述，叫做 Lomuto partition scheme 它的思路挺好理解，首先p就是划分边界，一开始p = left，遍历数组，发现比pivot小的，就交换到p的位置，并且p++，那么p左边的就全是比p要小的。而在最后面，把pivot交换到p的位置，所以这个方法期望把数组划分成三块，小于pivot的，等于pivot的，大于等于pivot的，而且能保证至少划分出两块（中间那块等于pivot的一定存在，不过只有一个元素）。这个方法的优点是可以通过简单的修改就变成3路划分（小于、等于、大于三块），缺点是它这种划分方法速度最慢，交换次数较多。\n2. 不知名字的方法 这种方法来源不明，如果你知道请告诉我，在我看来有点像 Hoare partition scheme 的变种，来看代码\nsort_element_t* partition( sort_element_t * first, sort_element_t * last) { sort_element_t pivot = *first; while (first \u0026lt; last) { while (first \u0026lt; last \u0026amp;\u0026amp; pivot \u0026lt; *last) last--; *first = *last; while (first \u0026lt; last \u0026amp;\u0026amp; pivot \u0026gt;= *first) first++; *last = *first; } *first = pivot; return first; } void quick_sort_recursive( sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { sort_element_t* p = partition(beg, end - 1); quick_sort_recursive(beg, p); quick_sort_recursive(p + 1, end); } }  这个方法通过在右边寻找应该放在左边的元素，与pivot交换，然后在左边寻找应该放在右边的元素，再次与pivot交换，这样pivot通过多数交换换到划分位置上。不过上面代码做了一个简单优化，通过赋值而不是直接交换以减少赋值的次数，这种方法在网上非常常见。\n3. Hoare partition scheme 后来有个叫做 C.A.R. Hoare 的人发明了这种划分方法，见代码\nsort_element_t* partition( sort_element_t * first, sort_element_t * last) { sort_element_t * begin = first; sort_element_t pivot = *first; while (first \u0026lt; last) { while (first \u0026lt; last \u0026amp;\u0026amp; *last \u0026gt;= pivot) --last; while (first \u0026lt; last \u0026amp;\u0026amp; pivot \u0026gt;= *first) ++first; if (first \u0026lt; last) sort_element_swap(first, last); } sort_element_swap(first, begin); return first; } void quick_sort_recursive( sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { sort_element_t* p = partition(beg, end - 1); quick_sort_recursive(beg, p); quick_sort_recursive(p + 1, end); } }  注意的是，这个写法和 wiki 上的略有差别。这个方法与前一个的不同点是，通过在左边寻找应该放在右边的元素，而在右边寻找应该放在左边的元素，然后交换。这个方法是以上三种里面速度最快的，但与此同时是坑最多的。例如，原描述是左边找小于，右边找大于的交换，而上面代码的实现是左边找小于等于，右边找大于等于；原描述是先找左边再找右边，上面实现是先找右边再找左边。也就是说，取不取等于号有4种组合，再乘以先左或先右两种，共8种组合，这8种有一些要求pivot取最左边，有一些要求pivot取最右边，有些左右都行，有些pivot任意位置都行。所以当你写这种划分方法的时候，看起来没什么区别的代码，偏偏出现栈溢出各种问题，其实就隐藏在这些细节上。如果你想练习调试的本领，就把这8种组合的划分全写出来，你肯定收获不少。至于哪种组合最佳，我不知道，但我知道最差的组合，就是两边都取等于号的那两种。\n这个写法还有一个四路划分的变种，即先划分成以下这样\n  =   =   划分好后再把两端的相等元素交换到中间得到\n   =    这里不具体展开，有兴趣可以自行实现\n4. VS partition scheme 之所以这么叫是因为我目前只看到在Visual Studio系列STL的std::sort是这么写的，这个写成代码有点长，但思路和上面说的四路划分有点类似，这里简单讲讲它的思路。首先pivot选择在中间，形成这样的状态\n   ? = ?    找到等于的元素就交换到等于那块的旁边扩大它就行了，核心思想就这样，还有很多其它的细节，这里不展开。这种方法网上几乎没有人这么写，因为写起来确实挺麻烦的。\n总结 本篇先介绍到这里，大家写快排练习建议使用 Hoare partition scheme ，如果你觉得你的能力更好，那你可以写 VS partition scheme 自己琢磨一下细节问题，相信你是能写出来的。那么下一篇会介绍优化的部分。\n","date":1570429102,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570429102,"objectID":"e4a727e5a6348a68314ff2501d974f7a","permalink":"/post/20191007-qsort-talk-1/","publishdate":"2019-10-07T14:18:22+08:00","relpermalink":"/post/20191007-qsort-talk-1/","section":"post","summary":"我们现在使用的排序，很大比例在使用quick sort，因为它是平均速度最快的排序，但与此同时它可能也是坑最深的排序，现在我们就来讨论讨论它，因为内容较多，我计划写多篇，本篇是第一篇。\n快排的思路 我们先来介绍一下快排的思路。快排的思路其实很简单，在数组中选一个元素，我们就称呼这个元素为pivot，通过与这个元素的比较，把数组划分成不比pivot大的在一边，不比pivot小的在另一边，于是就分成了两个更小的数据，对它们分别再排序就行了。但是，这个描述特别的含糊，首先是怎么选中间元素，这里面有很多不同的做法。然后就是划分了，这个划分方法非常的多，水也特别深，这里主要介绍最为常见的划分方法。\n","tags":["algorithm","sorting","quicksort","c","c++","partition"],"title":"Quick sort(快速排序)杂谈 1","type":"post"},{"authors":null,"categories":["杂谈"],"content":"这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。\n一开始我使用std::random_shuffle打乱数组并用std::sort排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是std::sort对这种方式打乱的数据排序有点问题导致变慢。\n后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，std::sort的时间是完全正常的，非得std::random_shuffle才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向std::random_shuffle，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是arr[i] = i，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在cppreference下源代码长下面这样：\ntemplate\u0026lt; class RandomIt \u0026gt; void random_shuffle( RandomIt first, RandomIt last ) { typename std::iterator_traits\u0026lt;RandomIt\u0026gt;::difference_type i, n; n = last - first; for (i = n-1; i \u0026gt; 0; --i) { using std::swap; swap(first[i], first[std::rand() % (i+1)]); } }  这个代码我看着就不对，这个是生成不了我的执行结果的，于是又找到了下面这个：\ntemplate \u0026lt;class RandomAccessIterator\u0026gt; inline void random_shuffle(RandomAccessIterator first, RandomAccessIterator last) { __random_shuffle(first, last, distance_type(first)); } template \u0026lt;class RandomAccessIterator, class RandomNumberGenerator\u0026gt; void random_shuffle(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator\u0026amp; rand) { if (first == last) return; for (RandomAccessIterator i = first + 1; i != last; ++i) iter_swap(i, first + rand((i - first) + 1)); } template \u0026lt;class RandomAccessIterator, class Distance\u0026gt; void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last, Distance*) { if (first == last) return; for (RandomAccessIterator i = first + 1; i != last; ++i) #ifdef __STL_NO_DRAND48 iter_swap(i, first + Distance(rand() % ((i - first) + 1))); #else iter_swap(i, first + Distance(lrand48() % ((i - first) + 1))); #endif }  看了这个代码，我瞬间明白这到底是怎么回事了，你能从中发现些什么吗？\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n我发现的是，前面的代码用的是rand，而之前我发现的，是数组里前32768个数都特别大，我的直觉是这个rand函数最大值就是32767从而导致以上问题，结果一查，还真的只有mingw的rand函数的最大值这么小，也就是说如果你希望代码跨平台，使用std::random_shuffle要慎重，当然最好是减少依赖。\n","date":1570338248,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570338248,"objectID":"17aa6d9424945fe4bb7e23edb81727e0","permalink":"/post/20191006-mingw-bug/","publishdate":"2019-10-06T13:04:08+08:00","relpermalink":"/post/20191006-mingw-bug/","section":"post","summary":"这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。\n一开始我使用std::random_shuffle打乱数组并用std::sort排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是std::sort对这种方式打乱的数据排序有点问题导致变慢。\n后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，std::sort的时间是完全正常的，非得std::random_shuffle才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向std::random_shuffle，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是arr[i] = i，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在cppreference下源代码长下面这样：\n","tags":["stl","c++","mingw","random_shuffle"],"title":"Mingw 的 Bug","type":"post"},{"authors":null,"categories":["杂谈"],"content":"第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把\\n自动换成\\r\\n从而导致主题应用失败，服了。\n另一个坑就是hugo的表格，你不能像以下这么写\na|b|c -|-|- 1|2|3  这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样\na | b | c ---|---|--- 1 | 2 | 3  显示结果就是这样\n   a b c     1 2 3    区别是什么呢？在表格的第二行是---|---|---，这一行是用来描述对齐方式的，不过hugo的引擎要求每列至少3个字符，所以刚好3个字符时只能是\n--- :-- --: :-:  中四选一，任何一个只剩下两个字符就不算是表格。\n本博客计划是发布我的研究成果，当然主要是算法方面，而且主要是网上不会轻易搜索到的东西。\n更多的东西可以关注我的 Github 账号。\n #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int g_eof; int get_lv(char c) { return !(c == '+' || c == '-'); } double get_val(double v[], char op) { if (op == '+') return v[0] + v[1]; if (op == '-') return v[0] - v[1]; if (op == '*') return v[0] * v[1]; if (op == '/') return v[0] / v[1]; return v[0]; } double calc(char* op, int level, double val, char o, int i) { char c[2] = { o }; double v[2] = { val }; if ((g_eof = scanf(\u0026quot;%lf\u0026quot;, \u0026amp;v[i])) != EOF) scanf(\u0026quot;%c\u0026quot;, \u0026amp;c[i]); if (c[i] == '(') { v[i] = calc(\u0026amp;c[i], 0, 0, 0, 0); scanf(\u0026quot;%c\u0026quot;, \u0026amp;c[i]); } if (i \u0026gt; 0) { if (!(c[i] == '\\n' || c[i] == ')' || get_lv(c[0]) \u0026gt;= get_lv(c[1]))) v[i] = calc(\u0026amp;c[1], get_lv(c[1]), v[1], c[1], get_lv(c[1]) \u0026gt; 0); v[0] = get_val(v, c[0]); c[0] = c[1]; } if (c[0] == '\\n' || c[0] == ')' || get_lv(c[0]) \u0026lt; level) { *op = c[0]; return v[0]; } return calc(op, level, v[0], c[0], 1); } int main(void) { char op; while (g_eof != EOF) printf(\u0026quot;= %.15g\\n\u0026quot;, calc(\u0026amp;op, 0, 0, '\\n', 0)); return 0; } ","date":1570288330,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570288330,"objectID":"458f89e40dd9bc6cb64d4e2c297e6a93","permalink":"/post/20191005-first-post/","publishdate":"2019-10-05T23:12:10+08:00","relpermalink":"/post/20191005-first-post/","section":"post","summary":"第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把\\n自动换成\\r\\n从而导致主题应用失败，服了。\n另一个坑就是hugo的表格，你不能像以下这么写\na|b|c -|-|- 1|2|3  这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样\n","tags":["algorithm","hugo","table"],"title":"博客第一文，附hugo表格的坑","type":"post"}]