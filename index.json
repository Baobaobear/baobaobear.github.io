[{"authors":["admin"],"categories":null,"content":"一个喜欢折腾和研究算法的大学生\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"一个喜欢折腾和研究算法的大学生","tags":null,"title":"抱抱熊","type":"authors"},{"authors":null,"categories":["笔记"],"content":"二进制的技巧特别多，这里就做一份cheat sheet，希望能帮助到大家。不过过于简单的就不列举了\n单行表达式    作用 表达式     把右边连续的1变成0 n \u0026amp; ( n + 1 )   把右边第一个1变成0 n \u0026amp; ( n - 1 )   把右起第一个0变成1 n | ( n + 1 )   把右起连续的0变成1 n | ( n - 1 )   取右边连续的1 n ^ ( n + 1 )   去掉右起第一个1的左边 n \u0026amp; -n 或 n \u0026amp; ( n ^ ( n - 1 ) )   高低位交换，前x位 ( n \u0026lt;\u0026lt; x ) | ( x \u0026gt;\u0026gt; ( 32 - x ) )   有符号整数计算绝对值 ( n ^ (n \u0026gt;\u0026gt; 31) ) - (n \u0026gt;\u0026gt; 31)    多行的技巧 1. 两数交换不使用第三个变量 void swap(int* a, int* b) { *a ^= *b; *b ^= *a; *a ^= *b; }  2. 奇偶校验码 int check_bit(int n) { n ^= n \u0026gt;\u0026gt; 1; n ^= n \u0026gt;\u0026gt; 2; n ^= n \u0026gt;\u0026gt; 4; n ^= n \u0026gt;\u0026gt; 8; n ^= n \u0026gt;\u0026gt; 16; return n \u0026amp; 1; }  3. 计算二进制中的1的个数 uint32_t method_1_uint32_count1(uint32_t n) { n = (n \u0026amp; 0x55555555) + ((n \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); n = (n \u0026amp; 0x33333333) + ((n \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); n = (n \u0026amp; 0x0f0f0f0f) + ((n \u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); n = (n \u0026amp; 0x00ff00ff) + ((n \u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); n = (n \u0026amp; 0x0000ffff) + ((n \u0026gt;\u0026gt; 16) \u0026amp; 0x0000ffff); return n; } uint32_t method_2_uint32_count1(uint32_t n) { n = n - ((n \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); n = (n \u0026amp; 0x33333333) + ((n \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); n = (n + (n \u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; n = n + (n \u0026gt;\u0026gt; 8); n = n + (n \u0026gt;\u0026gt; 16); return n \u0026amp; 0x3f; }  4. 计算下一组合 前提：我们使用一个整数的二进制位来代表对应集合上的元素有没有选中，从而来表达一个组合。当我们要遍历所有组合的时候，就可以用这个办法了\nint next_combination(int k) { int b = k \u0026amp; -k, t = (k + b); return (((t ^ k) \u0026gt;\u0026gt; 2) / b) | t; }  5. n皇后问题位运算实现 uint64_t queen(uint32_t row, uint32_t lb, uint32_t rb) { if (row == 0) return 1; uint64_t sum = 0; for (uint32_t r = row; r; r \u0026amp;= r - 1) { uint32_t p = r ^ (r \u0026amp; (r - 1)); if ((p \u0026amp; lb) == 0 \u0026amp;\u0026amp; (p \u0026amp; rb) == 0) sum += queen(row ^ p, (lb | p) \u0026lt;\u0026lt; 1, (rb | p) \u0026gt;\u0026gt; 1); } return sum; } uint64_t nqueen(int n) // 返回值为棋盘大小n时解的个数 { return queen(((uint32_t)1 \u0026lt;\u0026lt; n) - 1, 0, 0); }  6. 古老的快速平方根倒数 求 1/sqrt(n)，这段代码出自Quake-III Arena (雷神之锤3)源代码 /game/code/q_math.c，针对 IEEE 754 标准的单精度浮点格式\nfloat Q_rsqrt( float number ) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = * ( long * ) \u0026amp;y; // evil floating point bit level hacking i = 0x5f3759df - ( i \u0026gt;\u0026gt; 1 ); // what the fuck? y = * ( float * ) \u0026amp;i; y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration // y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed #ifndef Q3_VM #ifdef __linux__ assert( !isnan(y) ); // bk010122 - FPE? #endif #endif return y; }  注：使用常数 0x5f375a86 可以使得结果误差更小，详见维基百科\n7. 绘画Sierpinski三角 #include \u0026lt;stdio.h\u0026gt; int main(void) { const int n = (1 \u0026lt;\u0026lt; 5); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt;= i; ++j) putchar( ( i \u0026amp; j ) == j ? '#' : ' '); printf(\u0026quot;\\n\u0026quot;); } return 0; }  输出结果\n# ## # # #### # # ## ## # # # # ######## # # ## ## # # # # #### #### # # # # ## ## ## ## # # # # # # # # ################ # # ## ## # # # # #### #### # # # # ## ## ## ## # # # # # # # # ######## ######## # # # # ## ## ## ## # # # # # # # # #### #### #### #### # # # # # # # # ## ## ## ## ## ## ## ## # # # # # # # # # # # # # # # # ################################ ","date":1570864680,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570864680,"objectID":"d7f604b5e2a0d4ff98302e3384050d66","permalink":"/post/20191012-binary-skill/","publishdate":"2019-10-12T15:18:00+08:00","relpermalink":"/post/20191012-binary-skill/","section":"post","summary":"二进制的技巧特别多，这里就做一份cheat sheet，希望能帮助到大家。不过过于简单的就不列举了\n单行表达式    作用 表达式     把右边连续的1变成0 n \u0026amp; ( n + 1 )   把右边第一个1变成0 n \u0026amp; ( n - 1 )   把右起第一个0变成1 n | ( n + 1 )   把右起连续的0变成1 n | ( n - 1 )   取右边连续的1 n ^ ( n + 1 )   去掉右起第一个1的左边 n \u0026amp; -n 或 n \u0026amp; ( n ^ ( n - 1 ) )   高低位交换，前x位 ( n \u0026lt;\u0026lt; x ) | ( x \u0026gt;\u0026gt; ( 32 - x ) )   有符号整数计算绝对值 ( n ^ (n \u0026gt;\u0026gt; 31) ) - (n \u0026gt;\u0026gt; 31)   ","tags":["算法","二进制","c","c++","cheat sheet"],"title":"二进制技巧","type":"post"},{"authors":null,"categories":null,"content":" 废江\u0026rsquo;s博客 备战acm小菜鸟的个人日常 burningdzb的博客 白月光__编程小萌新  ","date":1570809600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570809600,"objectID":"76742f83502b2cf566f8baa2d043b7db","permalink":"/blogroll/","publishdate":"2019-10-12T00:00:00+08:00","relpermalink":"/blogroll/","section":"","summary":" 废江\u0026rsquo;s博客 备战acm小菜鸟的个人日常 burningdzb的博客 白月光__编程小萌新  ","tags":null,"title":"Blogroll","type":"page"},{"authors":null,"categories":["研究"],"content":"本篇针对插入排序和希尔排序来讲优化思路，有部分内容因为前一篇文章已经有交代，这里不重复，如果你还没有看，请先看前一篇。\n插入排序基本实现 我们先来看插入排序的基本实现\nvoid insert_sort(sort_element_t * beg, sort_element_t * end) { for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { sort_element_t val = *i; sort_element_t* j = i; for (; j \u0026gt; beg \u0026amp;\u0026amp; val \u0026lt; j[-1]; --j) { *j = j[-1]; } *j = val; } }  插入排序即使不做任何优化，效率也明显高于上篇所说的冒泡排序和选择排序。那么按照惯例，先上双向看看效果\n插入排序优化，双向插入 不过双向版本的插入排序可能并不是你想象中那么好写，甚至于有点不太好懂\n   点击展开  \nvoid double_insert_sort(sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { for (sort_element_t* i = beg + 1, *j = end - 1; ; ) { sort_element_t val = *i; sort_element_t* t = i; for (; t \u0026gt; beg \u0026amp;\u0026amp; val \u0026lt; t[-1]; --t) { *t = t[-1]; } *t = val; if (++i \u0026gt; j) { if (*i \u0026lt; *j) ++j; else break; } val = j[-1]; t = j; for (; t \u0026lt; end \u0026amp;\u0026amp; *t \u0026lt; val; ++t) { t[-1] = *t; } t[-1] = val; if (i \u0026gt; --j) { if (*j \u0026lt; j[-1]) --i; else break; } } } }  \n我们来看看测试结果，在 VS2015 下对 45000 个int排序\n   int 1 2 3 4 5 6 7 8 9 10 Avg     insert2 0 0 376 165 174 176 177 0 0 80 114   insert 0 0 359 165 174 177 192 0 0 86 115   odd_even 0 0 575 1259 1242 1224 532 0 2 855 568   cocktail 0 0 1252 1474 1537 1611 642 1 2 813 733   select2 0 1068 809 1076 1082 1073 1072 1074 1073 1065 939   bubble 0 0 1192 2190 2220 2193 832 1 4 1376 1000   select 2159 2174 2157 2137 2166 2160 2155 2149 2146 2138 2154    这个优化效果非常不明显，有种吃力不讨好的感觉。那么，我们换个方法，来试试加大步长吧，这个变动让算法有了另一个名字\n希尔排序 希尔排序的坑特别深，你需要有心理准备。希尔排序和梳排序类似，都是通过使用较大的步长让元素更快速地到达正确位置附近，不过在步长的选择上，希尔排序与梳排序差别巨大。首先梳排序的步长选择较为简单，每次乘以0.8即可，这个数字就不要管怎么来的了，我也不知道。梳排序的研究资料较少，但希尔排序则不一样，步长选择的研究非常多，也就是说光是步长的选择就是一门学问，这就是一个大坑，而且这个步长选择对性能的影响十分明显。我们先来看最早的希尔排序版本，最早的版本使用步长每次乘以0.5。\nvoid shell_sort_0_5(sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { size_t incre = (size_t)(end - beg) / 2; for (; incre \u0026gt;= 1; incre /= 2) { sort_element_t * bound = beg + incre; for (sort_element_t * i = bound; i \u0026lt; end; ++i) { sort_element_t * p = i; sort_element_t val = *i; for (; p \u0026gt;= bound \u0026amp;\u0026amp; val \u0026lt; *(p - incre); p -= incre) *p = *(p - incre); *p = val; } } } }  后来，Pratt 与 Knuth 改进了新的步长序列\n1, 4, 13, 40, 121, ...\n得到以下代码\nvoid shell_sort(sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { size_t incre = 1; while (incre \u0026lt; (size_t)(end - beg - 1) / 3) incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973 for (; incre \u0026gt;= 1; incre /= 3) { sort_element_t * bound = beg + incre; for (sort_element_t * i = bound; i \u0026lt; end; ++i) { sort_element_t * p = i; sort_element_t val = *i; for (; p \u0026gt;= bound \u0026amp;\u0026amp; val \u0026lt; *(p - incre); p -= incre) *p = *(p - incre); *p = val; } } } }  更多关于步长的研究可以参考维基百科，本篇不对步长做讲解。后文的优化将使用这个版本的代码\n希尔排序优化，运用带哨兵的插入排序 带哨兵的插入排序是什么东西？其实就是指以下这样的插入排序\nvoid unguarded_insert_sort(sort_element_t * beg, sort_element_t * end) { for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { sort_element_t val = *i; sort_element_t* j = i; for (; val \u0026lt; j[-1]; --j) { *j = j[-1]; } *j = val; } }  和前面的插入排序的区别在哪？就是少了j \u0026gt; beg \u0026amp;\u0026amp;，不做边界判断。不做边界判断确实能运行得更快，但不会越界吗？我们来考虑以下这种情况\nint arr[8] = {-1, 8, 9, 4, 5, 6, 1, 6};\n然后我们排序的时候写unguarded_insert_sort(arr + 1, arr + 8);它就能正确排序而且不会发生越界，因为最前面存在比需要排序的元素都要小的数，而那个数就是哨兵，它充当着让内循环退出的作用，也就是说，在调用这个函数的时候，只要保证beg的左边存在比右边都要小的元素就行了。\n有了这个能怎么优化呢？我们把步长1的部分单独拆出来，写成下面这样\nvoid shell_sort_o1(sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { size_t incre = 1; while (incre \u0026lt; (size_t)(end - beg - 1) / 3) incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973 for (; incre \u0026gt; 1; incre /= 3) { sort_element_t * bound = beg + incre; for (sort_element_t * i = bound; i \u0026lt; end; ++i) { sort_element_t * p = i; sort_element_t val = *i; for (; p \u0026gt;= bound \u0026amp;\u0026amp; val \u0026lt; *(p - incre); p -= incre) *p = *(p - incre); *p = val; } } insert_sort(beg, end); } }  这个能理解吧，步长1的时候完全就是插入排序，但真正厉害的在下面这步，要注意到这种写法在变为步长1之前，它的步长是4，我们可以证明整个数组的最小值一定在前4个数中，即前一个步长的范围内。这里不给出具体证明，有兴趣你可以自己试试证明。有了这个结论，前4个元素用插入排序排好了后，后面的就可以使用unguarded_insert_sort了\nvoid shell_sort_o2(sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 10) { size_t incre = 1; while (incre \u0026lt; (size_t)(end - beg - 1) / 3) incre = incre * 3 + 1; // A003462, Pratt, 1971, Knuth, 1973 for (; incre \u0026gt; 1; incre /= 3) { sort_element_t * bound = beg + incre; for (sort_element_t * i = bound; i \u0026lt; end; ++i) { sort_element_t * p = i; sort_element_t val = *i; for (; p \u0026gt;= bound \u0026amp;\u0026amp; val \u0026lt; *(p - incre); p -= incre) *p = *(p - incre); *p = val; } } insert_sort(beg, beg + 4); unguarded_insert_sort(beg + 4, end); } else { insert_sort(beg, end); } }  这个哨兵技巧在其它的排序里面甚至别的问题里同样也会存在。除了这个还有没有别的优化空间呢？例如，shellsort的最优情况下的时间复杂度还是O(nlogn)，那有没有办法使得最优情况时间复杂度下降到O(n)呢？确实有办法，如果在某一轮发现没有数进行交换，那么就立即转成带次数限制的插入排序进行尝试，具体请参阅我的sort项目。\n测试结果 以下是在 VS2015 上对 4,500,000 个int排序的测试\n   int 1 2 3 4 5 6 7 8 9 10 Avg     bao_shell 5 6 57 373 368 148 52 35 77 350 147   shell_o2 47 49 68 553 540 187 59 53 106 500 216   shell_sort 47 54 77 563 547 190 67 59 111 509 222   shell_0_5 80 89 114 606 601 236 82 89 143 572 261   comb_sort 166 161 180 492 477 214 171 169 223 478 273    其中bao_shell是我在sort项目中写的希尔排序，使用了更优的步长序列，里面包含更多的优化技巧，本篇就不一一介绍了。\n","date":1570711972,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570711972,"objectID":"ca48df74bf8be0f26c54d2e6620948f6","permalink":"/post/20191009-sorting-2/","publishdate":"2019-10-10T20:52:52+08:00","relpermalink":"/post/20191009-sorting-2/","section":"post","summary":"本篇针对插入排序和希尔排序来讲优化思路，有部分内容因为前一篇文章已经有交代，这里不重复，如果你还没有看，请先看前一篇。\n插入排序基本实现 我们先来看插入排序的基本实现\nvoid insert_sort(sort_element_t * beg, sort_element_t * end) { for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { sort_element_t val = *i; sort_element_t* j = i; for (; j \u0026gt; beg \u0026amp;\u0026amp; val \u0026lt; j[-1]; --j) { *j = j[-1]; } *j = val; } }  插入排序即使不做任何优化，效率也明显高于上篇所说的冒泡排序和选择排序。那么按照惯例，先上双向看看效果\n","tags":["算法","排序","插入排序","希尔排序","c","c++"],"title":"插入排序与希尔排序优化思路","type":"post"},{"authors":null,"categories":["研究"],"content":"本篇针对两种最基本的排序（冒泡、选择）来讲优化思路。越是简单的东西反而可能存在你越想不到的优化点。但是在开始之前，先给不了解的人讲一个设计原则的问题，我们在设计排序接口的时候，最为常见的有\nvoid sort(type arr[], int len)\n也许你也见过\nvoid sort(iter beg, iter end)\n这时候问题就来了，很多人会错误地把end认为是最后一个元素，其实不然，这两接口可以相互转换，例如我们可以写 sort(arr, arr + len) ，这样写很自然对不对，但如果你认为end是最后一个元素，那你就不得不改成 sort(arr, arr + len - 1) 。事实上，这类的接口我们需要一个统一的原则，就是左闭右开区间原则，即beg就是首个元素，而end是最后一个元素+1，即end是作为结束标志，不应该把end算在范围内。接下来下面所有的接口写法，都是以\nvoid sort(iter beg, iter end)\n这种方式写的，至于这样写有什么好处，接下来我们就看示例。\n选择排序 基本实现 我们先来看选择排序，因为它编写简单，而且最不容易出错，我们来看以下两种不同的接口写法，我们定义要排序的数据类型名字是sort_element_t，定义交换函数\nvoid sort_element_swap(sort_element_t *x, sort_element_t *y) { sort_element_t t = *x; *x = *y; *y = t; }  具体实现\nvoid select_sort(sort_element_t arr[], size_t len) //方式1 { for (size_t i = 0; i \u0026lt; len; ++i) { size_t head = i; for (size_t j = i + 1; j \u0026lt; len; ++j) { if (arr[j] \u0026lt; arr[head]) head = j; } sort_element_swap(arr + i, arr + head); } } void select_sort(sort_element_t * beg, sort_element_t * end) //方式2 { for (; beg \u0026lt; end; ++beg) { sort_element_t* head = beg; for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; *head) head = i; } sort_element_swap(beg, head); } }  就这么一眼看过去，看起来还真差不多，这样，我们再细分一下，选择排序的中间那步，其实就是找一个最小的元素，我们单独提取成一个独立函数再来看看\n//方式1 size_t find_min(sort_element_t arr[], size_t beg, size_t len) { size_t head = beg; for (size_t j = beg + 1; j \u0026lt; len; ++j) { if (arr[j] \u0026lt; arr[head]) head = j; } return head; } void select_sort(sort_element_t arr[], size_t len) { for (size_t i = 0; i \u0026lt; len; ++i) { sort_element_swap(arr + i, arr + find_min(arr, i, len)); } }  //方式2 sort_element_t* find_min(sort_element_t * beg, sort_element_t * end) { sort_element_t* head = beg; for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; *head) head = i; } return head; } void select_sort(sort_element_t * beg, sort_element_t * end) { for (; beg \u0026lt; end; ++beg) { sort_element_swap(beg, find_min(beg, end)); } }  仔细观察一下，是不是第二种写法函数参数统一，而且参数数量少，而且也少了很多不必要的加法运算（像方法一需要写arr + i这类）。如果你说方法一的find_min参数也可以只写两个，写成find_min(sort_element_t arr[], size_t len)，那么你在调用的地方将不得不写成find_min(arr + i, len - i)，这种又加又减在遇到更复杂的情况的时候，更容易把你弄晕出Bug。总之结论是最好把参数写成两个指针（或两个迭代器）的形式，不建议使用数组加长度的形式，STL的接口也全使用迭代器的形式。\n对于这个排序要注意的一点是，有人会写成类似下面的形式：\nvoid select_sort(sort_element_t arr[], size_t len) { for (size_t j = 0; j \u0026lt; len; ++j) { for (size_t i = j + 1; i \u0026lt; len; ++i) { if (arr[j] \u0026gt; arr[i]) { sort_element_t t = arr[j]; arr[j] = arr[i]; arr[i] = t; } } } }  以上这种叫做劣化版的选择排序，在大多数的情况下会比前一个方法慢，极端条件下甚至会慢1倍甚至更多\n那说完劣化再讲优化，选择排序的时间复杂度是O(n^2)，而且运行时间与原来的排列完全无关。以上的选择排序总是选择小的，那大小一起选呢？能不能起到优化的作用？如果你单纯的多写一个find_max变成双向选择来做，在VS2005下是没有优化效果的，我测试过了。那应该怎么样呢？确实还是双向选择，不过具体实现稍有点不同。\n优化1，双向选择 这里的实现是一个函数里同时把最大最小一起找，这样减少了一次遍历的过程，时间能减半之余，还有一个非常有用的优化，就是当你发现最大值等于最小值的时候能提前跳出\nsort_element_t* find_min_max( sort_element_t * beg, sort_element_t * end, sort_element_t** head_max) { sort_element_t* head = beg; *head_max = beg; for (sort_element_t* i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; *head) head = i; else if (**head_max \u0026lt; *i) *head_max = i; } return head; } void double_select_sort(sort_element_t * beg, sort_element_t * end) { while (end - beg \u0026gt; 1) { sort_element_t * head_max, * head = find_min_max(beg, end, \u0026amp;head_max); if (head_max != head) { if (head_max == beg) head_max = head; sort_element_swap(beg++, head); sort_element_swap(--end, head_max); } else { break; } } }  与选择排序的运行时间比较如下，排序45000个int，编译环境是VS2015，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时\n   int 1 2 3 4 5 6 7 8 9 10 Avg     select2 0 1114 834 1113 1124 1124 1119 1124 1124 1141 981   select 2213 2238 2227 2229 2256 2242 2238 2241 2245 2260 2238    合理运用双向，效果也往往不错，但是千万要注意，环境不同会导致测试结果不相同，例如你换到mingw上使用-O3编译那么将会是select比select2快，所以上面数据只供参考，具体结果请自己做测试。\n优化2，数据结构 选择排序的优化主要是在find_min上面，find_min的时间复杂度是O(n)，那如果我们通过一些数据结构的组织，例如二叉堆，那么找最大或最小值时间将变成O(1)，而维护这个数据结构的代价是O(logn)的话，总体时间复杂度将变为O(nlogn)，这比起选择排序的O(n^2)就是一个巨大的变化，具体内容在之后的 堆排序 篇具体讲解。\n冒泡排序 基本实现 冒泡排序是我们课本必然介绍的一个排序，相对于选择排序，这种在编写的时候更容易出现逻辑错误，我们先来看典型的实现（双迭代器实现）\nvoid bubble_sort(sort_element_t * beg, sort_element_t * end) { for (; beg \u0026lt; end; --end) { for (sort_element_t * i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-1]) sort_element_swap(i - 1, i); } } }  冒泡排序这种写法，铁定的O(n^2)时间没跑，不过好在冒泡排序的优化方法也不少。\n优化1，提前跳出 void bubble_sort(sort_element_t * beg, sort_element_t * end) { for (; beg \u0026lt; end; --end) { int sorted = 1; for (sort_element_t * i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (sorted) break; } }  通过sorted变量记录某一轮是不是存在交换，如果没有交换则表明数据已经是有序的，可以提前退出循环。有这个优化对于已经有序的数据，冒泡排序将运行得特别快，即最优情况时间复杂度只有O(n)\n优化2，鸡尾酒排序 前面的冒泡写法是单向冒泡，把最大值向最右边移，这回我们做成双向，一边把最大值右移，一边把最小值左移，不过这种方法有另一个命名，叫做鸡尾酒排序\nvoid cocktail_sort(sort_element_t * beg, sort_element_t * end) { while (beg \u0026lt; end) { int sorted = 1; for (sort_element_t * i = beg + 1; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (sorted) break; --end; sorted = 1; for (sort_element_t * i = end - 1; i \u0026gt; beg; --i) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (sorted) break; ++beg; } }  那改成双向就真的有提升了吗？我们看实测，排序45000个int，用10组不同分布的数据，表格中的数字单位是毫秒，即排序用时\n   int 1 2 3 4 5 6 7 8 9 10 Avg     cocktail 0 0 1313 1502 1614 1674 671 1 2 836 761   bubble 0 0 1245 2286 2329 2332 871 1 4 1459 1052    其中第4组是乱序无重复数值的数据，最有代表性的一列。从中可以看到，cocktail比起bubble能节省30%的时间\n让我们再脑洞大开，除了可以双向，还有一种对CPU执行有利的优化方式\n优化3，奇偶排序 这种排序的排序方式见下表，假设有8个数，奇数轮比较(1,2), (3,4), (5,6), (7,8)，偶数轮比较(2,3), (4,5), (6,7)，如此循环，直到没有交换为止\n   轮次 1 2 3 4 5 6 7 8     0 8 7 6 5 4 3 2 1   1 7 8 5 6 3 4 1 2   2 7 5 8 3 6 1 4 2   3 5 7 3 8 1 6 2 4   4 5 3 7 1 8 2 6 4    具体实现代码如下\nvoid odd_even_sort(sort_element_t * beg, sort_element_t * end) { int sorted = 0, last_sorted = 0; while (sorted == 0) { last_sorted = sorted; sorted = 1; for (sort_element_t * i = beg + 1; i \u0026lt; end; i += 2) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (last_sorted \u0026amp;\u0026amp; sorted) break; last_sorted = sorted; sorted = 1; for (sort_element_t * i = beg + 2; i \u0026lt; end; i += 2) { if (*i \u0026lt; i[-1]) { sort_element_swap(i - 1, i); sorted = 0; } } if (last_sorted \u0026amp;\u0026amp; sorted) break; } }  让我们再脑洞大开，除了比较方向，好像我们有一个条件没有考虑上，就是冒泡排序总是相邻元素的比较，那么如果不相邻地比较呢？\n优化4，梳排序 通过一开始设置较大的步长，让元素能较快移动，然后逐步减少步长，直到1变成普通的冒泡排序为止。这个方法的优点，就是快，相对前面的方法来说飞快。当然，最后一步你也可以选择不调用冒泡排序，而改调用cocktail_sort或odd_even_sort都可以，差别不明显。\nvoid comb_sort(sort_element_t * beg, sort_element_t * end) { const double shrink_factor = 0.8; ptrdiff_t gap = end - beg; while (gap \u0026gt; 1) { if (gap \u0026gt; 1) { gap = (ptrdiff_t)(gap * shrink_factor); if (gap == 10 || gap == 9) gap = 11; } for (sort_element_t * i = beg + gap; i \u0026lt; end; ++i) { if (*i \u0026lt; i[-gap]) sort_element_swap(i, i - gap); } } bubble_sort(beg, end); }  完整测试 在完整测试里你会发现一些和你想象中完全不一样的情况，可不要以为你的“优化”一定就是优化\nVS2005下的运行时间比较（按Avg平均值排序）    int 1 2 3 4 5 6 7 8 9 10 Avg     combsort 0 0 1 3 3 1 1 0 1 2 1   odd_even 0 0 574 1315 1315 1222 557 0 3 878 586   cocktail 0 0 1313 1502 1614 1674 671 1 2 836 761   select2 0 1114 834 1113 1124 1124 1119 1124 1124 1141 981   bubble 0 0 1245 2286 2329 2332 871 1 4 1459 1052   select 2213 2238 2227 2229 2256 2242 2238 2241 2245 2260 2238    如果你只测试随机数据，那么排序应该是\ncombsort \u0026lt;\u0026lt; select2 \u0026lt; odd_even \u0026lt; cocktail \u0026lt; select \u0026lt; bubble\n在mingw64(gcc8)下使用-O3编译（最大优化）的运行时间比较    int 1 2 3 4 5 6 7 8 9 10 Avg     combsort 0 1 1 2 3 2 2 1 2 3 1   select 497 497 434 501 501 500 501 503 500 502 493   odd_even 0 0 564 1311 1264 1217 562 0 2 882 580   cocktail 0 0 1242 1515 1610 1677 669 0 3 837 755   select2 1 1114 837 1114 1114 1112 1114 1113 1112 1114 974   bubble 0 0 1247 2312 2332 2338 951 0 3 1455 1063    你可以发现，找最小值过程在mingw64下被特别照顾了一下，结果它比其它的明显要快，你可以从中得知，如果你想在mingw下写出运行得快的双向选择排序，如果你的想法是再写一个find_max函数，那对不起，这样是没有优化效果的。但这不是全部，还有让你更大跌眼镜的情况。\n在mingw64(gcc8)下使用-O1编译（基本优化）的运行时间比较    int 1 2 3 4 5 6 7 8 9 10 Avg     combsort 0 0 0 3 3 1 1 0 2 2 1   select2 0 263 375 256 260 258 255 254 531 255 270   odd_even 0 0 597 1287 1256 1204 1368 1 3 780 649   cocktail 0 0 1244 1504 1594 1656 1081 1 3 815 789   bubble 0 0 1241 2091 2117 2115 685 0 3 1247 949   select 2233 2233 2232 2231 2232 2224 2229 2229 2225 2232 2230    现在双向选择不但最快，而且还比-O3下的快得多。老实说，会造成这种奇怪的结果，-O1比-O3还快的原因还真不要问我，找开发gcc/mingw的开发者。\n最后还是忠告一句，千万不要在一个编译器某个编译参数上看到有优化效果，就以为是事实，优化的坑远比你想象的要来得深，并不是你以为优化了它就一定变快了，编译器和编译参数以及运行环境才是你的老大。\n","date":1570511736,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570511736,"objectID":"d460bcc6e133fb754a6ffc672bf1f9c5","permalink":"/post/20191008-sorting-1/","publishdate":"2019-10-08T13:15:36+08:00","relpermalink":"/post/20191008-sorting-1/","section":"post","summary":"本篇针对两种最基本的排序（冒泡、选择）来讲优化思路。越是简单的东西反而可能存在你越想不到的优化点。但是在开始之前，先给不了解的人讲一个设计原则的问题，我们在设计排序接口的时候，最为常见的有\nvoid sort(type arr[], int len)\n也许你也见过\nvoid sort(iter beg, iter end)\n这时候问题就来了，很多人会错误地把end认为是最后一个元素，其实不然，这两接口可以相互转换，例如我们可以写 sort(arr, arr + len) ，这样写很自然对不对，但如果你认为end是最后一个元素，那你就不得不改成 sort(arr, arr + len - 1) 。事实上，这类的接口我们需要一个统一的原则，就是左闭右开区间原则，即beg就是首个元素，而end是最后一个元素+1，即end是作为结束标志，不应该把end算在范围内。接下来下面所有的接口写法，都是以\nvoid sort(iter beg, iter end)\n这种方式写的，至于这样写有什么好处，接下来我们就看示例。\n","tags":["算法","排序","冒泡排序","选择排序","鸡尾酒排序","奇偶排序","梳排序","c","c++"],"title":"选择和冒泡排序优化思路","type":"post"},{"authors":null,"categories":["研究"],"content":"我们现在使用的排序，很大比例在使用quick sort，因为它是平均速度最快的排序，但与此同时它可能也是坑最深的排序，现在我们就来讨论讨论它，因为内容较多，我计划写多篇，本篇是第一篇。\n快排的思路 我们先来介绍一下快排的思路。快排的思路其实很简单，在数组中选一个元素，我们就称呼这个元素为pivot，通过与这个元素的比较，把数组划分成不比pivot大的在一边，不比pivot小的在另一边，于是就分成了两个更小的数据，对它们分别再排序就行了。但是，这个描述特别的含糊，首先是怎么选中间元素，这里面有很多不同的做法。然后就是划分了，这个划分方法非常的多，水也特别深，这里主要介绍最为常见的划分方法。\n划分结果分类 首先，就是划分的结果，划分的结果有什么好讲的呢？其实算法的描述只说了划分成不比pivot大的在一边，不比pivot小的在另一边，并没有说等于的数怎么办。事实上，关键就在等于的数怎么处理，你既可以划在其中一边，也可以两边都有，也可以划成3分，中间那块就是等于pivot的，左边是小于等于，右边是大于等于，三种划分结果都是可以的。但是，不能容许的一种情况是划分后只有一块，例如你选的pivot正好是最小的数，于是划分后，整个数组就一块，全是大于等于pivot的，这样很可能导致无限递归，这次划分也白干了。\n所以很多人单凭算法思路来实现的时候，往往陷入栈溢出异常，其实就是划分结果上出了问题，并没有保证每次划分后，至少划分成两块。\n划分手段分类 划分手段的典型方法至少有5种，本篇介绍其中的4种\n1. Lomuto partition scheme 首先我们来看以下代码：\nsort_element_t * partition( sort_element_t * beg, sort_element_t * end) { sort_element_t pivot = *beg; sort_element_t * p = beg; for (sort_element_t * i = beg + 1; i \u0026lt; end; i++) { if (*i \u0026lt; pivot) { sort_element_swap(++p, i); } } sort_element_swap(p, beg); return p; } void quick_sort_recursive( sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { sort_element_t * p = partition(beg, end); quick_sort_recursive(beg, p); quick_sort_recursive(p + 1, end); } }  这种划分方法wiki上有描述，叫做 Lomuto partition scheme 它的思路挺好理解，首先p就是划分边界，一开始p = left，遍历数组，发现比pivot小的，就交换到p的位置，并且p++，那么p左边的就全是比p要小的。而在最后面，把pivot交换到p的位置，所以这个方法期望把数组划分成三块，小于pivot的，等于pivot的，大于等于pivot的，而且能保证至少划分出两块（中间那块等于pivot的一定存在，不过只有一个元素）。这个方法的优点是可以通过简单的修改就变成3路划分（小于、等于、大于三块），缺点是它这种划分方法速度最慢，交换次数较多。\n2. 不知名字的方法 这种方法来源不明，如果你知道请告诉我，在我看来有点像 Hoare partition scheme 的变种，来看代码\nsort_element_t* partition( sort_element_t * first, sort_element_t * last) { sort_element_t pivot = *first; while (first \u0026lt; last) { while (first \u0026lt; last \u0026amp;\u0026amp; pivot \u0026lt; *last) last--; *first = *last; while (first \u0026lt; last \u0026amp;\u0026amp; pivot \u0026gt;= *first) first++; *last = *first; } *first = pivot; return first; } void quick_sort_recursive( sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { sort_element_t* p = partition(beg, end - 1); quick_sort_recursive(beg, p); quick_sort_recursive(p + 1, end); } }  这个方法通过在右边寻找应该放在左边的元素，与pivot交换，然后在左边寻找应该放在右边的元素，再次与pivot交换，这样pivot通过多数交换换到划分位置上。不过上面代码做了一个简单优化，通过赋值而不是直接交换以减少赋值的次数，这种方法在网上非常常见。\n3. Hoare partition scheme 后来有个叫做 C.A.R. Hoare 的人发明了这种划分方法，见代码\nsort_element_t* partition( sort_element_t * first, sort_element_t * last) { sort_element_t * begin = first; sort_element_t pivot = *first; while (first \u0026lt; last) { while (first \u0026lt; last \u0026amp;\u0026amp; *last \u0026gt;= pivot) --last; while (first \u0026lt; last \u0026amp;\u0026amp; pivot \u0026gt;= *first) ++first; if (first \u0026lt; last) sort_element_swap(first, last); } sort_element_swap(first, begin); return first; } void quick_sort_recursive( sort_element_t * beg, sort_element_t * end) { if (end - beg \u0026gt; 1) { sort_element_t* p = partition(beg, end - 1); quick_sort_recursive(beg, p); quick_sort_recursive(p + 1, end); } }  注意的是，这个写法和 wiki 上的略有差别。这个方法与前一个的不同点是，通过在左边寻找应该放在右边的元素，而在右边寻找应该放在左边的元素，然后交换。这个方法是以上三种里面速度最快的，但与此同时是坑最多的。例如，原描述是左边找小于，右边找大于的交换，而上面代码的实现是左边找小于等于，右边找大于等于；原描述是先找左边再找右边，上面实现是先找右边再找左边。也就是说，取不取等于号有4种组合，再乘以先左或先右两种，共8种组合，这8种有一些要求pivot取最左边，有一些要求pivot取最右边，有些左右都行，有些pivot任意位置都行。所以当你写这种划分方法的时候，看起来没什么区别的代码，偏偏出现栈溢出各种问题，其实就隐藏在这些细节上。如果你想练习调试的本领，就把这8种组合的划分全写出来，你肯定收获不少。至于哪种组合最佳，我不知道，但我知道最差的组合，就是两边都取等于号的那两种。\n这个写法还有一个四路划分的变种，即先划分成以下这样\n  =   =   划分好后再把两端的相等元素交换到中间得到\n   =    这里不具体展开，有兴趣可以自行实现\n4. VS partition scheme 之所以这么叫是因为我目前只看到在Visual Studio系列STL的std::sort是这么写的，这个写成代码有点长，但思路和上面说的四路划分有点类似，这里简单讲讲它的思路。首先pivot选择在中间，形成这样的状态\n   ? = ?    找到等于的元素就交换到等于那块的旁边扩大它就行了，核心思想就这样，还有很多其它的细节，这里不展开。这种方法网上几乎没有人这么写，因为写起来确实挺麻烦的。\n总结 本篇先介绍到这里，大家写快排练习建议使用 Hoare partition scheme ，如果你觉得你的能力更好，那你可以写 VS partition scheme 自己琢磨一下细节问题，相信你是能写出来的。那么下一篇会介绍优化的部分。\n","date":1570429102,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570429102,"objectID":"e4a727e5a6348a68314ff2501d974f7a","permalink":"/post/20191007-qsort-talk-1/","publishdate":"2019-10-07T14:18:22+08:00","relpermalink":"/post/20191007-qsort-talk-1/","section":"post","summary":"我们现在使用的排序，很大比例在使用quick sort，因为它是平均速度最快的排序，但与此同时它可能也是坑最深的排序，现在我们就来讨论讨论它，因为内容较多，我计划写多篇，本篇是第一篇。\n快排的思路 我们先来介绍一下快排的思路。快排的思路其实很简单，在数组中选一个元素，我们就称呼这个元素为pivot，通过与这个元素的比较，把数组划分成不比pivot大的在一边，不比pivot小的在另一边，于是就分成了两个更小的数据，对它们分别再排序就行了。但是，这个描述特别的含糊，首先是怎么选中间元素，这里面有很多不同的做法。然后就是划分了，这个划分方法非常的多，水也特别深，这里主要介绍最为常见的划分方法。\n","tags":["算法","排序","快速排序","c","c++","partition"],"title":"Quick sort(快速排序)杂谈 1","type":"post"},{"authors":null,"categories":["杂谈"],"content":"这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。\n一开始我使用std::random_shuffle打乱数组并用std::sort排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是std::sort对这种方式打乱的数据排序有点问题导致变慢。\n后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，std::sort的时间是完全正常的，非得std::random_shuffle才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向std::random_shuffle，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是arr[i] = i，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在cppreference下源代码长下面这样：\ntemplate\u0026lt; class RandomIt \u0026gt; void random_shuffle( RandomIt first, RandomIt last ) { typename std::iterator_traits\u0026lt;RandomIt\u0026gt;::difference_type i, n; n = last - first; for (i = n-1; i \u0026gt; 0; --i) { using std::swap; swap(first[i], first[std::rand() % (i+1)]); } }  这个代码我看着就不对，这个是生成不了我的执行结果的，于是又找到了下面这个：\ntemplate \u0026lt;class RandomAccessIterator\u0026gt; inline void random_shuffle(RandomAccessIterator first, RandomAccessIterator last) { __random_shuffle(first, last, distance_type(first)); } template \u0026lt;class RandomAccessIterator, class RandomNumberGenerator\u0026gt; void random_shuffle(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator\u0026amp; rand) { if (first == last) return; for (RandomAccessIterator i = first + 1; i != last; ++i) iter_swap(i, first + rand((i - first) + 1)); } template \u0026lt;class RandomAccessIterator, class Distance\u0026gt; void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last, Distance*) { if (first == last) return; for (RandomAccessIterator i = first + 1; i != last; ++i) #ifdef __STL_NO_DRAND48 iter_swap(i, first + Distance(rand() % ((i - first) + 1))); #else iter_swap(i, first + Distance(lrand48() % ((i - first) + 1))); #endif }  看了这个代码，我瞬间明白这到底是怎么回事了，你能从中发现些什么吗？\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n我发现的是，前面的代码用的是rand，而之前我发现的，是数组里前32768个数都特别大，我的直觉是这个rand函数最大值就是32767从而导致以上问题，结果一查，还真的只有mingw的rand函数的最大值这么小，也就是说如果你希望代码跨平台，使用std::random_shuffle要慎重，当然最好是减少依赖。\n","date":1570338248,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570338248,"objectID":"17aa6d9424945fe4bb7e23edb81727e0","permalink":"/post/20191006-mingw-bug/","publishdate":"2019-10-06T13:04:08+08:00","relpermalink":"/post/20191006-mingw-bug/","section":"post","summary":"这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。\n一开始我使用std::random_shuffle打乱数组并用std::sort排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是std::sort对这种方式打乱的数据排序有点问题导致变慢。\n后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，std::sort的时间是完全正常的，非得std::random_shuffle才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向std::random_shuffle，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是arr[i] = i，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在cppreference下源代码长下面这样：\n","tags":["stl","c++","mingw","random_shuffle"],"title":"Mingw 的 Bug","type":"post"},{"authors":null,"categories":["杂谈"],"content":"第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把\\n自动换成\\r\\n从而导致主题应用失败，服了。\n另一个坑就是hugo的表格，你不能像以下这么写\na|b|c -|-|- 1|2|3  这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样\na | b | c ---|---|--- 1 | 2 | 3  显示结果就是这样\n   a b c     1 2 3    区别是什么呢？在表格的第二行是---|---|---，这一行是用来描述对齐方式的，不过hugo的引擎要求每列至少3个字符，所以刚好3个字符时只能是\n--- :-- --: :-:  中四选一，任何一个只剩下两个字符就不算是表格。\n本博客计划是发布我的研究成果，当然主要是算法方面，而且主要是网上不会轻易搜索到的东西。\n更多的东西可以关注我的 Github 账号。\n #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int g_eof; int get_lv(char c) { return !(c == '+' || c == '-'); } double get_val(double v[], char op) { if (op == '+') return v[0] + v[1]; if (op == '-') return v[0] - v[1]; if (op == '*') return v[0] * v[1]; if (op == '/') return v[0] / v[1]; return v[0]; } double calc(char* op, int level, double val, char o, int i) { char c[2] = { o }; double v[2] = { val }; if ((g_eof = scanf(\u0026quot;%lf\u0026quot;, \u0026amp;v[i])) != EOF) scanf(\u0026quot;%c\u0026quot;, \u0026amp;c[i]); if (c[i] == '(') { v[i] = calc(\u0026amp;c[i], 0, 0, 0, 0); scanf(\u0026quot;%c\u0026quot;, \u0026amp;c[i]); } if (i \u0026gt; 0) { if (!(c[i] == '\\n' || c[i] == ')' || get_lv(c[0]) \u0026gt;= get_lv(c[1]))) v[i] = calc(\u0026amp;c[1], get_lv(c[1]), v[1], c[1], get_lv(c[1]) \u0026gt; 0); v[0] = get_val(v, c[0]); c[0] = c[1]; } if (c[0] == '\\n' || c[0] == ')' || get_lv(c[0]) \u0026lt; level) { *op = c[0]; return v[0]; } return calc(op, level, v[0], c[0], 1); } int main(void) { char op; while (g_eof != EOF) printf(\u0026quot;= %.15g\\n\u0026quot;, calc(\u0026amp;op, 0, 0, '\\n', 0)); return 0; } ","date":1570288330,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570288330,"objectID":"458f89e40dd9bc6cb64d4e2c297e6a93","permalink":"/post/20191005-first-post/","publishdate":"2019-10-05T23:12:10+08:00","relpermalink":"/post/20191005-first-post/","section":"post","summary":"第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把\\n自动换成\\r\\n从而导致主题应用失败，服了。\n另一个坑就是hugo的表格，你不能像以下这么写\na|b|c -|-|- 1|2|3  这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样\n","tags":["算法","hugo","表格"],"title":"博客第一文，附hugo表格的坑","type":"post"}]