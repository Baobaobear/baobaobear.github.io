<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.5.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="抱抱熊">

  
  
  
    
  
  <meta name="description" content="最近在编写大整数库的过程中，踩到不少的坑，于是把一些有用的细节准备写成文章做整理。如果你只是想直接查找并使用一个大整数库，那直接上GMP即可，如果你是想学习个中细节，那你可以坐下来细品。

所谓大整数，又叫高精度运算，就是运算对象是上千位甚至到百万位，总之远远超过内置数据类型的表示范围，这类数字都叫大整数。而C/C&#43;&#43;的标准库里目前并没有大整数库，于是这个轮子被反复制造了无数个，不过在github上比较有质量的轮子并没有很多。本文除了介绍基础实现，主要还是介绍优化方法。

大整数的表示

大整数的表示方法最常见的有4种：


直接使用string
使用定长数组(仅适用于竞赛)
使用链表
使用变长线性表例如vector


直接用string的方式适合初学者，输入输出直观，但缺点也非常明显，因为计算时需要在字符与数值之间来回转换，浪费太多不必要的时间，效率会非常差。不过如果你是初学者，先用string表示法来写未尝不是个好主意。但有个细节就是，如果想要效率高，最好把string前后倒置调整为低位在前再做运算，这样速度和实现难度都会低一些。

至于使用链表，好处是变长容易，变短也不难，但性能比用string的更差还更难写，这里就不谈了，以下介绍使用数组的表示法

为了在数组里表示一个大整数，如果我们采用10进制，表示123456789，那很简单，例如这样：

int a[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};


即a[0]表示个位，a[1]表示十位，如此类推。之所以这样做，是希望同一个位置的元素的含义是固定的，这样能简化后面的算法编写。

但是，对于计算机来说，这样表示实在是太浪费空间和时间，我们还可以这样：

int a[] = {6789, 2345, 1};


也就是说，采用10000进制，那么这个10000叫做基数或base。我们还可以视情况使用其它的基数，例如使用2^16或2^32等等。对于这种我们原始进制是b的情况，但通过更大的基数b^n来表示的方法，叫做压位高精度，n就是压的位数。压位高精度的运算效率远超非压位。">

  
  <link rel="alternate" hreflang="en-us" href="/post/20210228-bigint1/">

  


  
  
  
  <meta name="theme-color" content="#ff3860">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/atom-one-dark-reasonable.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/atom-one-dark-reasonable.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.css" integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ==" crossorigin="anonymous">
    

    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.3029a502a418216cce7fbc18a9c0af71.css">

  

  




  


  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/post/20210228-bigint1/">

  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Baobaobear">
  <meta property="og:url" content="/post/20210228-bigint1/">
  <meta property="og:title" content="大整数高精度计算1————基础算法 | Baobaobear">
  <meta property="og:description" content="最近在编写大整数库的过程中，踩到不少的坑，于是把一些有用的细节准备写成文章做整理。如果你只是想直接查找并使用一个大整数库，那直接上GMP即可，如果你是想学习个中细节，那你可以坐下来细品。

所谓大整数，又叫高精度运算，就是运算对象是上千位甚至到百万位，总之远远超过内置数据类型的表示范围，这类数字都叫大整数。而C/C&#43;&#43;的标准库里目前并没有大整数库，于是这个轮子被反复制造了无数个，不过在github上比较有质量的轮子并没有很多。本文除了介绍基础实现，主要还是介绍优化方法。

大整数的表示

大整数的表示方法最常见的有4种：


直接使用string
使用定长数组(仅适用于竞赛)
使用链表
使用变长线性表例如vector


直接用string的方式适合初学者，输入输出直观，但缺点也非常明显，因为计算时需要在字符与数值之间来回转换，浪费太多不必要的时间，效率会非常差。不过如果你是初学者，先用string表示法来写未尝不是个好主意。但有个细节就是，如果想要效率高，最好把string前后倒置调整为低位在前再做运算，这样速度和实现难度都会低一些。

至于使用链表，好处是变长容易，变短也不难，但性能比用string的更差还更难写，这里就不谈了，以下介绍使用数组的表示法

为了在数组里表示一个大整数，如果我们采用10进制，表示123456789，那很简单，例如这样：

int a[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};


即a[0]表示个位，a[1]表示十位，如此类推。之所以这样做，是希望同一个位置的元素的含义是固定的，这样能简化后面的算法编写。

但是，对于计算机来说，这样表示实在是太浪费空间和时间，我们还可以这样：

int a[] = {6789, 2345, 1};


也就是说，采用10000进制，那么这个10000叫做基数或base。我们还可以视情况使用其它的基数，例如使用2^16或2^32等等。对于这种我们原始进制是b的情况，但通过更大的基数b^n来表示的方法，叫做压位高精度，n就是压的位数。压位高精度的运算效率远超非压位。"><meta property="og:image" content="/img/icon-192.png">
  <meta property="twitter:image" content="/img/icon-192.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2021-02-28T00:00:00&#43;08:00">
    
    <meta property="article:modified_time" content="2021-02-28T00:00:00&#43;08:00">
  

  


    






  






<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/20210228-bigint1/"
  },
  "headline": "大整数高精度计算1————基础算法",
  
  "datePublished": "2021-02-28T00:00:00+08:00",
  "dateModified": "2021-02-28T00:00:00+08:00",
  
  "author": {
    "@type": "Person",
    "name": "抱抱熊"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "Baobaobear",
    "logo": {
      "@type": "ImageObject",
      "url": "/img/icon-512.png"
    }
  },
  "description": "\u003cp\u003e最近在编写大整数库的过程中，踩到不少的坑，于是把一些有用的细节准备写成文章做整理。如果你只是想直接查找并使用一个大整数库，那直接上GMP即可，如果你是想学习个中细节，那你可以坐下来细品。\u003c/p\u003e\n\n\u003cp\u003e所谓大整数，又叫高精度运算，就是运算对象是上千位甚至到百万位，总之远远超过内置数据类型的表示范围，这类数字都叫大整数。而C/C++的标准库里目前并没有大整数库，于是这个轮子被反复制造了无数个，不过在github上比较有质量的轮子并没有很多。本文除了介绍基础实现，主要还是介绍优化方法。\u003c/p\u003e\n\n\u003ch2 id=\"大整数的表示\"\u003e大整数的表示\u003c/h2\u003e\n\n\u003cp\u003e大整数的表示方法最常见的有4种：\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e直接使用string\u003c/li\u003e\n\u003cli\u003e使用定长数组(仅适用于竞赛)\u003c/li\u003e\n\u003cli\u003e使用链表\u003c/li\u003e\n\u003cli\u003e使用变长线性表例如vector\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e直接用string的方式适合初学者，输入输出直观，但缺点也非常明显，因为计算时需要在字符与数值之间来回转换，浪费太多不必要的时间，效率会非常差。不过如果你是初学者，先用string表示法来写未尝不是个好主意。但有个细节就是，如果想要效率高，最好把string前后倒置调整为低位在前再做运算，这样速度和实现难度都会低一些。\u003c/p\u003e\n\n\u003cp\u003e至于使用链表，好处是变长容易，变短也不难，但性能比用string的更差还更难写，这里就不谈了，以下介绍使用数组的表示法\u003c/p\u003e\n\n\u003cp\u003e为了在数组里表示一个大整数，如果我们采用10进制，表示\u003ccode\u003e123456789\u003c/code\u003e，那很简单，例如这样：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eint a[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e即\u003ccode\u003ea[0]\u003c/code\u003e表示个位，\u003ccode\u003ea[1]\u003c/code\u003e表示十位，如此类推。之所以这样做，是希望同一个位置的元素的含义是固定的，这样能简化后面的算法编写。\u003c/p\u003e\n\n\u003cp\u003e但是，对于计算机来说，这样表示实在是太浪费空间和时间，我们还可以这样：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003eint a[] = {6789, 2345, 1};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e也就是说，采用10000进制，那么这个10000叫做\u003ccode\u003e基数\u003c/code\u003e或\u003ccode\u003ebase\u003c/code\u003e。我们还可以视情况使用其它的基数，例如使用\u003ccode\u003e2^16\u003c/code\u003e或\u003ccode\u003e2^32\u003c/code\u003e等等。对于这种我们原始进制是b的情况，但通过更大的基数\u003ccode\u003eb^n\u003c/code\u003e来表示的方法，叫做\u003ccode\u003e压位高精度\u003c/code\u003e，n就是压的位数。压位高精度的运算效率远超非压位。\u003c/p\u003e"
}
</script>

  

  


  


  





  <title>大整数高精度计算1————基础算法 | Baobaobear</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Baobaobear</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/post/"><span>All Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Recent Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#tags"><span>Tags</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/blogroll/"><span>Blogroll</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>大整数高精度计算1————基础算法</h1>

  

  
    



<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Feb 28, 2021
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    10 min read
  </span>
  

  
  
  
  <span class="middot-divider"></span>
  <a href="/post/20210228-bigint1/#disqus_thread"></a>
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/categories/%e7%a0%94%e7%a9%b6">研究</a></span>
  

  
    
<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=/post/20210228-bigint1/&amp;text=%e5%a4%a7%e6%95%b4%e6%95%b0%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%971%e2%80%94%e2%80%94%e2%80%94%e2%80%94%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=/post/20210228-bigint1/&amp;t=%e5%a4%a7%e6%95%b4%e6%95%b0%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%971%e2%80%94%e2%80%94%e2%80%94%e2%80%94%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook-f"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=%e5%a4%a7%e6%95%b4%e6%95%b0%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%971%e2%80%94%e2%80%94%e2%80%94%e2%80%94%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95&amp;body=/post/20210228-bigint1/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=/post/20210228-bigint1/&amp;title=%e5%a4%a7%e6%95%b4%e6%95%b0%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%971%e2%80%94%e2%80%94%e2%80%94%e2%80%94%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=%e5%a4%a7%e6%95%b4%e6%95%b0%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%971%e2%80%94%e2%80%94%e2%80%94%e2%80%94%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95%20/post/20210228-bigint1/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=/post/20210228-bigint1/&amp;title=%e5%a4%a7%e6%95%b4%e6%95%b0%e9%ab%98%e7%b2%be%e5%ba%a6%e8%ae%a1%e7%ae%971%e2%80%94%e2%80%94%e2%80%94%e2%80%94%e5%9f%ba%e7%a1%80%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>


  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>最近在编写大整数库的过程中，踩到不少的坑，于是把一些有用的细节准备写成文章做整理。如果你只是想直接查找并使用一个大整数库，那直接上GMP即可，如果你是想学习个中细节，那你可以坐下来细品。</p>

<p>所谓大整数，又叫高精度运算，就是运算对象是上千位甚至到百万位，总之远远超过内置数据类型的表示范围，这类数字都叫大整数。而C/C++的标准库里目前并没有大整数库，于是这个轮子被反复制造了无数个，不过在github上比较有质量的轮子并没有很多。本文除了介绍基础实现，主要还是介绍优化方法。</p>

<h2 id="大整数的表示">大整数的表示</h2>

<p>大整数的表示方法最常见的有4种：</p>

<ol>
<li>直接使用string</li>
<li>使用定长数组(仅适用于竞赛)</li>
<li>使用链表</li>
<li>使用变长线性表例如vector</li>
</ol>

<p>直接用string的方式适合初学者，输入输出直观，但缺点也非常明显，因为计算时需要在字符与数值之间来回转换，浪费太多不必要的时间，效率会非常差。不过如果你是初学者，先用string表示法来写未尝不是个好主意。但有个细节就是，如果想要效率高，最好把string前后倒置调整为低位在前再做运算，这样速度和实现难度都会低一些。</p>

<p>至于使用链表，好处是变长容易，变短也不难，但性能比用string的更差还更难写，这里就不谈了，以下介绍使用数组的表示法</p>

<p>为了在数组里表示一个大整数，如果我们采用10进制，表示<code>123456789</code>，那很简单，例如这样：</p>

<pre><code class="language-cpp">int a[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
</code></pre>

<p>即<code>a[0]</code>表示个位，<code>a[1]</code>表示十位，如此类推。之所以这样做，是希望同一个位置的元素的含义是固定的，这样能简化后面的算法编写。</p>

<p>但是，对于计算机来说，这样表示实在是太浪费空间和时间，我们还可以这样：</p>

<pre><code class="language-cpp">int a[] = {6789, 2345, 1};
</code></pre>

<p>也就是说，采用10000进制，那么这个10000叫做<code>基数</code>或<code>base</code>。我们还可以视情况使用其它的基数，例如使用<code>2^16</code>或<code>2^32</code>等等。对于这种我们原始进制是b的情况，但通过更大的基数<code>b^n</code>来表示的方法，叫做<code>压位高精度</code>，n就是压的位数。压位高精度的运算效率远超非压位。</p>

<p>以下我们用万进制来做一步步的演示，首先定义出这个类，在这里我用vector来保存（没有必要采用定长数组，因为效率没啥区别，除非你的OJ就不给加<code>O2</code>优化例如某谷或参加某些信息竞赛）：</p>

<pre><code class="language-cpp">struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; //1表示正数，-1表示负数
    std::vector&lt;int&gt; v;
};
</code></pre>

<p>于是这里有一个问题，0怎么表示？在这里规定0的sign为1，且v的长度为1，这种约定可以在后期简化一些代码。当然你也可以规定v的长度为0，你怎么约定就怎么写代码即可。</p>

<h2 id="大整数的基本运算">大整数的基本运算</h2>

<p>实现一个功能还算得上完整的大整数，需要的基本运算有：</p>

<ol>
<li>比较运算</li>
<li>字符串输入</li>
<li>字符串输出</li>
<li>加法</li>
<li>减法</li>
<li>乘法</li>
<li>除法及求余</li>
</ol>

<h3 id="1-比较运算">1. 比较运算</h3>

<p>大整数的比较很简单，先判断符号，符号不同再看位数，位数不同再从最高位一位一位比就行。但是我们其实更需要一个按绝对值比较的函数（后面的运算会需要它），那么先写一个无视符号的比较版本，再在运算符重载处判断符号即可。</p>

<h3 id="2-字符串输入输出">2. 字符串输入输出</h3>

<p>对于输入输出的字符串进制与该大整数的基相同时，输入输出直接映射转换即可，对于不同进制的输入输出在后面再做介绍，以下是实现了输入输出及一些基础功能的版本</p>

<pre><code class="language-cpp">struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; //1表示正数，-1表示负数
    std::vector&lt;int&gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) {
        *this = n;
    }
    //判断是否为0
    bool iszero() const {
        return v.size() == 1 &amp;&amp; v.back() == 0;
    }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;&amp; v.size() &gt; 1)
            v.pop_back();
        if (iszero())
            sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &gt;= v.size())
            return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &lt; v.size(); --i)
                if (v[i] != b.v[i])
                    return v[i] &lt; b.v[i];
            return false;
        } else {
            return v.size() &lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == '-')
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - '0');
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //字符串输出
    std::string to_str() const {
        std::string s;
        for (size_t i = 0; i &lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + '0';
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &gt; 1 &amp;&amp; s.back() == '0')
            s.pop_back();
        //补符号
        if (sign &lt; 0)
            s += '-';
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }

    BigIntSimple &amp;operator=(int n) {
        v.clear();
        sign = n &gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty())
            v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;operator=(const std::string &amp;s) {
        set(s.c_str());
        return *this;
    }

};
</code></pre>

<p>下文的介绍为了不重复，就不带上以上的代码了</p>

<h3 id="3-加法和减法">3. 加法和减法</h3>

<p>加法和减法都挺简单，核心思想就是模拟手工竖式，手工怎么算它就怎么算。要注意的点就是符号的处理。</p>

<p>另外，还有一些小优化，加法进位的时候，这个if是可以简单省略掉的，用求模和除法运算即可。即当前位是<code>sum % base</code>，进位是<code>sum / base</code>。示例代码如下</p>

<pre><code class="language-cpp">        for (size_t i = 0; i &lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i];
            r.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
</code></pre>

<p>但除法就没这么简单了，这时候还可以利用位运算来区分正负，比如，我们用当前位是<code>sum - (sum &gt;&gt; 31) * base</code>，因为如果sum是负数，那么<code>sum &gt;&gt; 31</code>在sum是int时就等于-1，相当于<code>sum + base</code>；而如果sum是非负数，那么<code>sum &gt;&gt; 31</code>就是0，结果就相当于<code>sum</code>，这样就成功实现了<code>sum&lt;0 ? sum+base : sum</code>的逻辑。而这种方法同样可以用在加法上。</p>

<p>其它的细节在以下代码的注释中有标注</p>

<pre><code class="language-cpp">    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign)
            return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &lt; b.v.size())
            r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &gt;&gt; 31);
            carry = (carry &gt;&gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;&amp; i &lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &gt;&gt; 31);
            carry = (carry &gt;&gt; 31) + 1;
        }
        //处理升位进位
        if (carry)
            r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;subtract(const BigIntSimple &amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &gt;&gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &gt;&gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign)
            return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }
</code></pre>

<h3 id="4-乘法">4. 乘法</h3>

<p>本文不区分高精度乘以低精度，和高精度乘以高精度，下文的除法也一样，因为实在没有这个必要分开写，以下直接介绍的是高精度乘以高精度。</p>

<p>乘法可以看成在加法外面再套一层循环，内循环相比加法多了一个偏移和一个乘法。但是由于进位的值不会只是1，所以那个位运算方法在这里不能使用，只能用求模了。以下直接上代码</p>

<pre><code class="language-cpp">    BigIntSimple operator*(const BigIntSimple &amp;b) const {
        //r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &lt; v.size(); ++j) {
            int carry = 0, m = v[j]; //m用来缓存乘数
            //carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        r.sign = sign * b.sign;
        return r;
    }
</code></pre>

<h3 id="5-除法和求余">5. 除法和求余</h3>

<p>除法是高精度的基础算法里面变化最多的，也是基础算法里面最难的，网上也有很多不同的写法，顺带说一说一些误区，同时这里提供一个我自己的写法，不过此法有限制条件，但在限制条件内应该是模拟手工的方法里面速度较快的。</p>

<p>第一种就是暴力整体二分，然后做乘法验证（或者利用二进制一位一位来确定，但却不使用移位减法，而使用整体相乘），这时候，设是2n位除以n位，那么二分的次数就是n，然后一次乘法是n^2，所以整体复杂度是<code>O(n^3)</code>，这是一个非常糟糕的方法，虽然写起来似乎更简单，但时间上还不如直接模拟，千万不要做整体二分。类似地还有二分开方，也是<code>O(n^3)</code>。</p>

<p>在模拟手工除法时，最关键的就是试商的部分，试商方法有很多，最简单的方式是用减法，先判断余数是不是大于等于除数，如果是，就做一次减法。这个写法确实容易，但问题是效率低下，除非你用的基数特别小，比如不压位10进制，这样速度还能看，甚至乎你用的是<code>2^n</code>进制，直接每个位枚举。</p>

<p>那我们来个二分呢？如果在每一位上分别二分，那在基数较大的时候比做减法好一些，但还是不够好，我们还需要更快的方案，进一步减少试商次数。</p>

<p>假设被除数有4个位，是$a_4,a_3,a_2,a_1$，除数有3个位，是$b_3,b_2,b_1$，那么我们只要试一位的商（多个位就是一位的写法加个循环），假如我们用$\frac{a_4 base+a_3}{b_3}$来试商，结果一定大于等于实际的商，但同时这会有一个问题，就是假如b2等于<code>base-1</code>，那会导致试商与实际的商误差非常大，例如<code>9999,0000</code>除以<code>1,9999</code>，直接用高位除得到9999，但这远超过实际商了，修正商的代价也不小。于是，我们想到，在<code>base</code>不太大的情况下，我们可以通过增加位数来估商，这样误差就会小得多。比如说我们用$\frac{a_4 base^2 + a_3 base + a_2}{b_3 base + b_2}$来试商，精度确实会大为提高，而且商的误差最多只有1，但缺点是，$a_4 base^2$的结果超出int的范围了，不过我们还可以用double。注意到，上式中a2对结果并没有任何影响，所以可以变形为$\frac{a_4 base + a_3}{b_3 + b_2/base}$。另外，我不希望这个估商总比实际商大，我们希望是小于等于实际商，这样在试后一位的时候，这个结果能自然得到修正，就增加了试商的效率，于是可以把式子改为$\frac{a_4 base + a_3}{b_3 + (b_2+1)base^{-1}}$，但这个+1导致误差增大，与实际商的误差最大达到2，那解决方法很简单，我们再增加1位的精度，得到式子$\frac{a_4 base + a_3}{b_3 + b_2 base^{-1} + (b_1+1)base^{-2}}$，于是便得到接下来在代码中所使用的算法。由于误差不超过1，如果估小了，那在下一位的估商时候就会产生补回去的效果，于是不必重复试商。这个方法要求<code>base&lt;=32768</code>以避免各种溢出，在满足此条件下，因为每个位均只需要估一次，那么其时间常数与乘法相比，和减法与加法常数比是几乎相同的。</p>

<p>但是，有一个非常极端的情况，既然商最大误差是1，那么相当于余数的最大误差就等于除数，那如果除数特别大呢？举个例子，求<code>9999,9999,9999,9999/9999,9999,9999</code>，用上面的方法，高一位的试商结果是0，次一位的试商是9999（实际商是10000），相减得到余数<code>1,0000,0000,9998</code>，结果最高位并没有减到0，于是不能继续移位，需要在同一位再一次试商。但虽然在同一位试商两次，但后一位就不用做减法了，均滩还是n次。</p>

<p>算法有了，该处理细节了，除法需要一个减法函数，不过这个函数对借位的处理和之前的减法可不一样，因为可能一次借n个，那就产生了一个问题：对负数求模。负数求模的结果和正数很不一样，所以如果还是要避免if做判断处理，那就要再换个方法，我承认我很菜，花了很久时间才想到这个法子，实现如下</p>

<pre><code class="language-cpp">    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;sub_mul(const BigIntSimple &amp;b, int mul, int offset) {
        if (mul == 0)
            return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }
</code></pre>

<p>以上代码关键点就是这两行</p>

<pre><code class="language-cpp">borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
</code></pre>

<p>核心思想是通过减去base统一在负数段求模后，再加上base回来，这样也达到避免if，避免if的写法比带if的写法时间上可以节省一半，不清楚有没有性能更好的做法。以下为除法及求余的具体实现。</p>

<pre><code class="language-cpp">    BigIntSimple div_mod(const BigIntSimple &amp;b, BigIntSimple &amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&lt;=131072时可用（受double的精度限制）
        //能保证估计结果q'与实际结果q的关系满足q'&lt;=q&lt;=q'+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                    (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;b) const {
        BigIntSimple r;
        div_mod(b, r);
        return r;
        //return *this - *this / b * b;
    }
</code></pre>

<p>求余就不说了，有求商之后代码仅一行<code>return *this - *this / b * b</code>，而且这样写与C语言规则一致，模与被除数符号相同。当然以上代码实现的<code>div_mod</code>函数本身就把商和余数同时求出，就可以直接调用而少了乘法和减法。</p>

<p>但是，现在系统几乎都是64位的，于是在64位下我们就应该考虑更大的base，例如说使用亿进制，最大限度利用64位带来的性能提升。但是，如果我们使用大的base，那么考虑到double的精度，前面的试商法就失效了，甚至于连base的平方都超出double能精确表示的范围，那这时候应该怎么办呢？为了方便描述，这里我们假设用的是$2^{n}$进制，且n&gt;=18，而double的尾数是53位，于是$log_2base^3=3n=54&gt;53$，这就是令原问题失效的边界。但是，我们真的需要3n长度的尾数吗？确实并不需要，我们的base的精度是n位，只需要再增加k位，只要n+k到53还有一些距离就行，把这个数看成是浮点数，同样地，把被除数和除数都看成浮点数，那我们的除数如何进行+1操作呢？比如说除数表示为$b_3b_2b_1$，那我们让b_3右移n+k位加上去，不就相当于+1了。在实际操作中，我令k=n/2，这样操作起来更为文件，具体请参阅我的<a href="https://github.com/Baobaobear/MiniBigInteger" target="_blank">MiniBigInteger</a>项目。</p>

<h2 id="完整模板">完整模板</h2>

<p><details>
<summary>
  <h4> 点击展开 </h4>
</summary></p>

<pre><code class="language-cpp">struct BigIntSimple {
    static const int BIGINT_BASE = 10000;
    static const int BIGINT_DIGITS = 4;

    int sign; // 1表示正数，-1表示负数
    std::vector&lt;int&gt; v;

    //定义0也需要长度1
    BigIntSimple() {
        sign = 1;
        v.push_back(0);
    }
    BigIntSimple(int n) { *this = n; }
    //判断是否为0
    bool iszero() const { return v.size() == 1 &amp;&amp; v.back() == 0; }
    //消除前导0并修正符号
    void trim() {
        while (v.back() == 0 &amp;&amp; v.size() &gt; 1)
            v.pop_back();
        if (iszero()) sign = 1;
    }
    //获取pos位置上的数值，用于防越界，简化输入处理
    int get(unsigned pos) const {
        if (pos &gt;= v.size()) return 0;
        return v[pos];
    }
    //绝对值大小比较
    bool absless(const BigIntSimple &amp;b) const {
        if (v.size() == b.v.size()) {
            for (size_t i = v.size() - 1; i &lt; v.size(); --i)
                if (v[i] != b.v[i]) return v[i] &lt; b.v[i];
            return false;
        } else {
            return v.size() &lt; b.v.size();
        }
    }
    //字符串输入
    void set(const char *s) {
        v.clear();
        sign = 1;
        //处理负号
        while (*s == '-')
            sign = -sign, ++s;
        //先按数位直接存入数组里
        for (size_t i = 0; s[i]; ++i)
            v.push_back(s[i] - '0');
        std::reverse(v.begin(), v.end());
        //压位处理，e是压位后的长度
        size_t e = (v.size() + BIGINT_DIGITS - 1) / BIGINT_DIGITS;
        for (size_t i = 0, j = 0; i &lt; e; ++i, j += BIGINT_DIGITS) {
            v[i] = v[j]; //设置压位的最低位
            //高位的按每一位上的数值乘以m，m是该位的权值
            for (size_t k = 1, m = 10; k &lt; BIGINT_DIGITS; ++k, m *= 10)
                v[i] += get(j + k) * m;
        }
        //修正压位后的长度
        if (e) {
            v.resize(e);
            trim();
        } else {
            v.resize(1);
        }
    }
    //字符串输出
    std::string to_str() const {
        std::string s;
        for (size_t i = 0; i &lt; v.size(); ++i) {
            int d = v[i];
            //拆开压位
            for (size_t k = 0; k &lt; BIGINT_DIGITS; ++k) {
                s += d % 10 + '0';
                d /= 10;
            }
        }
        //去除前导0
        while (s.size() &gt; 1 &amp;&amp; s.back() == '0')
            s.pop_back();
        //补符号
        if (sign &lt; 0) s += '-';
        //不要忘记要逆序
        std::reverse(s.begin(), s.end());
        return s;
    }

    bool operator&lt;(const BigIntSimple &amp;b) const {
        if (sign == b.sign) {
            return sign &gt; 0 ? absless(b) : b.absless(*this);
        } else {
            return sign &lt; 0;
        }
    }

    BigIntSimple &amp;operator=(int n) {
        v.clear();
        sign = n &gt;= 0 ? 1 : -1;
        for (n = abs(n); n; n /= BIGINT_BASE)
            v.push_back(n % BIGINT_BASE);
        if (v.empty()) v.push_back(0);
        return *this;
    }

    BigIntSimple &amp;operator=(const std::string &amp;s) {
        set(s.c_str());
        return *this;
    }

    BigIntSimple operator-() const {
        BigIntSimple r = *this;
        r.sign = -r.sign;
        return r;
    }

    BigIntSimple operator+(const BigIntSimple &amp;b) const {
        //符号不同时转换为减法
        if (sign != b.sign) return *this - -b;
        BigIntSimple r = *this;
        //填充高位
        if (r.v.size() &lt; b.v.size()) r.v.resize(b.v.size());
        int carry = 0;
        //逐位相加
        for (size_t i = 0; i &lt; b.v.size(); ++i) {
            carry += r.v[i] + b.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &gt;&gt; 31);
            carry = (carry &gt;&gt; 31) + 1;
        }
        //处理进位，拆两个循环来写是避免做 i &lt; b.v.size() 的判断
        for (size_t i = b.v.size(); carry &amp;&amp; i &lt; r.v.size(); ++i) {
            carry += r.v[i] - BIGINT_BASE;
            r.v[i] = carry - BIGINT_BASE * (carry &gt;&gt; 31);
            carry = (carry &gt;&gt; 31) + 1;
        }
        //处理升位进位
        if (carry) r.v.push_back(carry);
        return r;
    }

    BigIntSimple &amp;subtract(const BigIntSimple &amp;b) {
        int borrow = 0;
        //先处理b的长度
        for (size_t i = 0; i &lt; b.v.size(); ++i) {
            borrow += v[i] - b.v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &gt;&gt;= 31);
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i];
            v[i] = borrow;
            v[i] -= BIGINT_BASE * (borrow &gt;&gt;= 31);
        }
        //减法可能会出现前导0需要消去
        trim();
        return *this;
    }

    BigIntSimple operator-(const BigIntSimple &amp;b) const {
        //符号不同时转换为加法
        if (sign != b.sign) return (*this) + -b;
        if (absless(b)) { //保证大数减小数
            BigIntSimple r = b;
            return -r.subtract(*this);
        } else {
            BigIntSimple r = *this;
            return r.subtract(b);
        }
    }

    BigIntSimple operator*(const BigIntSimple &amp;b) const {
        // r记录相加结果
        BigIntSimple r;
        r.v.resize(v.size() + b.v.size()); //初始化长度
        for (size_t j = 0; j &lt; v.size(); ++j) {
            int carry = 0, m = v[j]; // m用来缓存乘数
            // carry可能很大，只能使用求模的办法，此循环与加法部分几乎相同，就多乘了个m
            for (size_t i = 0; i &lt; b.v.size(); ++i) {
                carry += r.v[i + j] + b.v[i] * m;
                r.v[i + j] = carry % BIGINT_BASE;
                carry /= BIGINT_BASE;
            }
            r.v[j + b.v.size()] += carry;
        }
        r.trim();
        r.sign = sign * b.sign;
        return r;
    }

    //对b乘以mul再左移offset的结果相减，为除法服务
    BigIntSimple &amp;sub_mul(const BigIntSimple &amp;b, int mul, int offset) {
        if (mul == 0) return *this;
        int borrow = 0;
        //与减法不同的是，borrow可能很大，不能使用减法的写法
        for (size_t i = 0; i &lt; b.v.size(); ++i) {
            borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        //如果还有借位就继续处理
        for (size_t i = b.v.size(); borrow; ++i) {
            borrow += v[i + offset] - BIGINT_BASE + 1;
            v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;
            borrow /= BIGINT_BASE;
        }
        return *this;
    }

    BigIntSimple div_mod(const BigIntSimple &amp;b, BigIntSimple &amp;r) const {
        BigIntSimple d;
        r = *this;
        if (absless(b)) return d;
        d.v.resize(v.size() - b.v.size() + 1);
        //提前算好除数的最高三位+1的倒数，若最高三位是a3,a2,a1
        //那么db是a3+a2/base+(a1+1)/base^2的倒数，最后用乘法估商的每一位
        //此法在BIGINT_BASE&lt;=32768时可在int32范围内用
        //但即使使用int64，那么也只有BIGINT_BASE&lt;=131072时可用（受double的精度限制）
        //能保证估计结果q'与实际结果q的关系满足q'&lt;=q&lt;=q'+1
        //所以每一位的试商平均只需要一次，只要后面再统一处理进位即可
        //如果要使用更大的base，那么需要更换其它试商方案
        double t = (b.get((unsigned)b.v.size() - 2) +
                    (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);
        double db = 1.0 / (b.v.back() + t / BIGINT_BASE);
        for (size_t i = v.size() - 1, j = d.v.size() - 1; j &lt;= v.size();) {
            int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);
            int m = std::max((int)(db * rm), r.get(i + 1));
            r.sub_mul(b, m, j);
            d.v[j] += m;
            if (!r.get(i + 1)) //检查最高位是否已为0，避免极端情况
                --i, --j;
        }
        r.trim();
        //修正结果的个位
        int carry = 0;
        while (!r.absless(b)) {
            r.subtract(b);
            ++carry;
        }
        //修正每一位的进位
        for (size_t i = 0; i &lt; d.v.size(); ++i) {
            carry += d.v[i];
            d.v[i] = carry % BIGINT_BASE;
            carry /= BIGINT_BASE;
        }
        d.trim();
        d.sign = sign * b.sign;
        return d;
    }

    BigIntSimple operator/(const BigIntSimple &amp;b) const {
        BigIntSimple r;
        return div_mod(b, r);
    }

    BigIntSimple operator%(const BigIntSimple &amp;b) const {
        return *this - *this / b * b;
    }
};
</code></pre>

<p></details></p>

<p>经测试，这个实现在1秒内可以计算出30000阶乘，而计算10000阶乘不到0.1秒，附上求阶乘的实现如下：</p>

<pre><code class="language-cpp">BigIntSimple fac(int start, int n) {
    if (n &lt; 16) {
        BigIntSimple s = 1;
        for (int i = start; i &lt; start + n; ++i)
            s = BigIntSimple(i) * s;
        return s;
    }
    int m = (n + 1) / 2;
    return fac(start, m) * fac(start + m, n - m);
}

int main() {
    int n;
    while (cin &gt;&gt; n) {
        cout &lt;&lt; fac(1, n).to_str() &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>在hdu oj 1042上，<a href="https://vjudge.net/solution/29867142" target="_blank">以171ms通过</a>，在提交记录里面，超过了大部分其它提交。当然这还不是极限。</p>

<p>对于除法，2n/n所需要时间与n*n所需时间比大约是1.5（n是位数），不同编译器这个比值稍有不同。</p>

<p>本基础篇就介绍到这里，后文将介绍乘法和除法的优化。</p>
    </div>

    


    

<div class="article-tags">
  
  <a class="badge badge-light" href="">大整数</a>
  
  <a class="badge badge-light" href="">高精度</a>
  
  <a class="badge badge-light" href="">算法</a>
  
  <a class="badge badge-light" href="">模板</a>
  
</div>



    
      








  






  
  
  
    
  
  
  <div class="media author-card">
    
      
      <img class="portrait mr-3" src="/authors/admin/avatar_hu7aaa46bd12fd0c0b960b4100abd18eca_101820_250x250_fill_q90_lanczos_center.jpg" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title"><a href="/">抱抱熊</a></h5>
      
      <p class="card-text">一个喜欢折腾和研究算法的大学生</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/baobaobear" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>



      
      
      <div class="article-widget">
        <div class="hr-light"></div>
        <h3>Related</h3>
        <ul>
          
          <li><a href="/post/20200104-xoshiro/">伪随机数生成算法</a></li>
          
          <li><a href="/post/20191216-kmp-manacher/">扩展KMP与Manacher</a></li>
          
          <li><a href="/post/20191028-kmp/">KMP及扩展KMP</a></li>
          
          <li><a href="/post/20200416-pam/">回文树</a></li>
          
          <li><a href="/post/20200220-sam/">后缀自动机SAM</a></li>
          
        </ul>
      </div>
      
    

    

    
<section id="comments">
  
    
<div id="disqus_thread"></div>
<script>
  let disqus_config = function () {
    
    
    
  };
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
      return;
    }
    var d = document, s = d.createElement('script'); s.async = true;
    s.src = 'https://' + "baobaobear" + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  
</section>



  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js" integrity="sha256-0w92bcB21IY5+rGI84MGj52jNfHNbXVeQLrZ0CGdjNY=" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/cpp.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js" integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log==" crossorigin="anonymous"></script>
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    <script id="dsq-count-scr" src="https://baobaobear.disqus.com/count.js" async></script>
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.d6bd04fdad2ad213aa8111c5a3b72fc5.js"></script>

    






  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
