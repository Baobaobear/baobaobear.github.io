<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.5.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="抱抱熊">

  
  
  
    
  
  <meta name="description" content="这次主要介绍伪随机数生成算法，顺便介绍一个在2018-2019年的伪随机数研究成果，就是 xoshiro/xoroshiro 随机数生成算法。

历史

在较早的时候，甚至到现在，伪随机数的生成元老级别算法“线性同余伪随机数生成算法”可谓无处不在，像现在的C/C&#43;&#43;的rand函数就是使用线性同余实现的伪随机数生成。所谓的线性同余法，就是这个迭代方程 $S_n = (aS_{n-1} &#43; c)\mod m$，其中，$S_0$ 称为这个随机序列的种子，a,c,m是三个常数，不过这三个数不能随意选，m的大小决定随机数的周期，最大周期等于m，为了便于在计算机里实现，通常m选取$2^{32}$或$2^{64}$。在m已经确定为这两的时候，为了让周期尽可能大，常数a,c还至少要满足以下条件：


若 c 非 0，那么 c 与 m 互质；若 c 为 0，那么 a 与 m 互质
m 所有的素因子均能整除 a-1
若 m 是4的倍数，那么 a-1 也是 4 的倍数
a 和 c 都是正整数且小于 m


一些典型的常数取值可以参见wiki上的线性同余条目。

更高的需求

我们之所以使用线性同余，就是因为它实现简单，在对随机数质量要求较低的时候，例如用来作为treap的随机数，那么线性同余完全够用，但建议不要使用rand，因为在windows下不少编译器的最大值太小了，导致效果下降，自己写一个用参数a=69069,c=1,m=2^32比rand好，我在那篇关于treap的文章就是用了这组参数。线性同余法最大的缺陷是低位随机性特别差，如果使用类似next() % k的方式来获得区间在$[0,k-1]$的随机数，那么当线性同余迭代方程的m是2的幂且k也是2的幂的时候，灾难就发生了，特别地当k是2的时候，你将得到一个0101的循环序列。为了避免这种情况，通常会取线性同余结果的高位，而且低位去掉得越多，%2的周期就越长。例如结果是64位，取高32位作为最终结果，那么%2的周期就是 $2^{33}$ ，但这样会导致有效位减少，而且问题也没有根本地解决。另一种解决办法是选取一个素数作为m，例如2147483647正是一个素数，但如此一来，线性同余的计算速度就会慢不少，周期也没有前一个的长。两种基本实现如下：">

  
  <link rel="alternate" hreflang="en-us" href="/post/20200104-xoshiro/">

  


  
  
  
  <meta name="theme-color" content="#ff3860">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/atom-one-dark-reasonable.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/atom-one-dark-reasonable.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.css" integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ==" crossorigin="anonymous">
    

    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.3029a502a418216cce7fbc18a9c0af71.css">

  

  




  


  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/post/20200104-xoshiro/">

  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Baobaobear">
  <meta property="og:url" content="/post/20200104-xoshiro/">
  <meta property="og:title" content="伪随机数生成算法 | Baobaobear">
  <meta property="og:description" content="这次主要介绍伪随机数生成算法，顺便介绍一个在2018-2019年的伪随机数研究成果，就是 xoshiro/xoroshiro 随机数生成算法。

历史

在较早的时候，甚至到现在，伪随机数的生成元老级别算法“线性同余伪随机数生成算法”可谓无处不在，像现在的C/C&#43;&#43;的rand函数就是使用线性同余实现的伪随机数生成。所谓的线性同余法，就是这个迭代方程 $S_n = (aS_{n-1} &#43; c)\mod m$，其中，$S_0$ 称为这个随机序列的种子，a,c,m是三个常数，不过这三个数不能随意选，m的大小决定随机数的周期，最大周期等于m，为了便于在计算机里实现，通常m选取$2^{32}$或$2^{64}$。在m已经确定为这两的时候，为了让周期尽可能大，常数a,c还至少要满足以下条件：


若 c 非 0，那么 c 与 m 互质；若 c 为 0，那么 a 与 m 互质
m 所有的素因子均能整除 a-1
若 m 是4的倍数，那么 a-1 也是 4 的倍数
a 和 c 都是正整数且小于 m


一些典型的常数取值可以参见wiki上的线性同余条目。

更高的需求

我们之所以使用线性同余，就是因为它实现简单，在对随机数质量要求较低的时候，例如用来作为treap的随机数，那么线性同余完全够用，但建议不要使用rand，因为在windows下不少编译器的最大值太小了，导致效果下降，自己写一个用参数a=69069,c=1,m=2^32比rand好，我在那篇关于treap的文章就是用了这组参数。线性同余法最大的缺陷是低位随机性特别差，如果使用类似next() % k的方式来获得区间在$[0,k-1]$的随机数，那么当线性同余迭代方程的m是2的幂且k也是2的幂的时候，灾难就发生了，特别地当k是2的时候，你将得到一个0101的循环序列。为了避免这种情况，通常会取线性同余结果的高位，而且低位去掉得越多，%2的周期就越长。例如结果是64位，取高32位作为最终结果，那么%2的周期就是 $2^{33}$ ，但这样会导致有效位减少，而且问题也没有根本地解决。另一种解决办法是选取一个素数作为m，例如2147483647正是一个素数，但如此一来，线性同余的计算速度就会慢不少，周期也没有前一个的长。两种基本实现如下："><meta property="og:image" content="/img/icon-192.png">
  <meta property="twitter:image" content="/img/icon-192.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2020-01-04T08:26:00&#43;08:00">
    
    <meta property="article:modified_time" content="2020-01-04T08:26:00&#43;08:00">
  

  


    






  






<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/20200104-xoshiro/"
  },
  "headline": "伪随机数生成算法",
  
  "datePublished": "2020-01-04T08:26:00+08:00",
  "dateModified": "2020-01-04T08:26:00+08:00",
  
  "author": {
    "@type": "Person",
    "name": "抱抱熊"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "Baobaobear",
    "logo": {
      "@type": "ImageObject",
      "url": "/img/icon-512.png"
    }
  },
  "description": "\u003cp\u003e这次主要介绍伪随机数生成算法，顺便介绍一个在2018-2019年的伪随机数研究成果，就是 xoshiro/xoroshiro 随机数生成算法。\u003c/p\u003e\n\n\u003ch2 id=\"历史\"\u003e历史\u003c/h2\u003e\n\n\u003cp\u003e在较早的时候，甚至到现在，伪随机数的生成元老级别算法“线性同余伪随机数生成算法”可谓无处不在，像现在的C/C++的rand函数就是使用线性同余实现的伪随机数生成。所谓的线性同余法，就是这个迭代方程 $S_n = (aS_{n-1} + c)\\mod m$，其中，$S_0$ 称为这个随机序列的种子，a,c,m是三个常数，不过这三个数不能随意选，m的大小决定随机数的周期，最大周期等于m，为了便于在计算机里实现，通常m选取$2^{32}$或$2^{64}$。在m已经确定为这两的时候，为了让周期尽可能大，常数a,c还至少要满足以下条件：\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e若 c 非 0，那么 c 与 m 互质；若 c 为 0，那么 a 与 m 互质\u003c/li\u003e\n\u003cli\u003em 所有的素因子均能整除 a-1\u003c/li\u003e\n\u003cli\u003e若 m 是4的倍数，那么 a-1 也是 4 的倍数\u003c/li\u003e\n\u003cli\u003ea 和 c 都是正整数且小于 m\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e一些典型的常数取值可以参见wiki上的\u003ca href=\"https://en.wikipedia.org/wiki/Linear_congruential_generator\" target=\"_blank\"\u003e线性同余\u003c/a\u003e条目。\u003c/p\u003e\n\n\u003ch2 id=\"更高的需求\"\u003e更高的需求\u003c/h2\u003e\n\n\u003cp\u003e我们之所以使用线性同余，就是因为它实现简单，在对随机数质量要求较低的时候，例如用来作为treap的随机数，那么线性同余完全够用，但建议不要使用rand，因为在windows下不少编译器的最大值太小了，导致效果下降，自己写一个用参数\u003ccode\u003ea=69069,c=1,m=2^32\u003c/code\u003e比rand好，我在那篇关于treap的文章就是用了这组参数。线性同余法最大的缺陷是低位随机性特别差，如果使用类似\u003ccode\u003enext() % k\u003c/code\u003e的方式来获得区间在$[0,k-1]$的随机数，那么当线性同余迭代方程的m是2的幂且k也是2的幂的时候，灾难就发生了，特别地当k是2的时候，你将得到一个0101的循环序列。为了避免这种情况，通常会取线性同余结果的高位，而且低位去掉得越多，\u003ccode\u003e%2\u003c/code\u003e的周期就越长。例如结果是64位，取高32位作为最终结果，那么\u003ccode\u003e%2\u003c/code\u003e的周期就是 $2^{33}$ ，但这样会导致有效位减少，而且问题也没有根本地解决。另一种解决办法是选取一个素数作为m，例如2147483647正是一个素数，但如此一来，线性同余的计算速度就会慢不少，周期也没有前一个的长。两种基本实现如下：\u003c/p\u003e"
}
</script>

  

  


  


  





  <title>伪随机数生成算法 | Baobaobear</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Baobaobear</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/post/"><span>All Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Recent Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#tags"><span>Tags</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/blogroll/"><span>Blogroll</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>伪随机数生成算法</h1>

  

  
    



<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Jan 4, 2020
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    20 min read
  </span>
  

  
  
  
  <span class="middot-divider"></span>
  <a href="/post/20200104-xoshiro/#disqus_thread"></a>
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/categories/%e7%a0%94%e7%a9%b6">研究</a></span>
  

  
    
<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=/post/20200104-xoshiro/&amp;text=%e4%bc%aa%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=/post/20200104-xoshiro/&amp;t=%e4%bc%aa%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook-f"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=%e4%bc%aa%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95&amp;body=/post/20200104-xoshiro/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=/post/20200104-xoshiro/&amp;title=%e4%bc%aa%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=%e4%bc%aa%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95%20/post/20200104-xoshiro/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=/post/20200104-xoshiro/&amp;title=%e4%bc%aa%e9%9a%8f%e6%9c%ba%e6%95%b0%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>


  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>这次主要介绍伪随机数生成算法，顺便介绍一个在2018-2019年的伪随机数研究成果，就是 xoshiro/xoroshiro 随机数生成算法。</p>

<h2 id="历史">历史</h2>

<p>在较早的时候，甚至到现在，伪随机数的生成元老级别算法“线性同余伪随机数生成算法”可谓无处不在，像现在的C/C++的rand函数就是使用线性同余实现的伪随机数生成。所谓的线性同余法，就是这个迭代方程 $S_n = (aS_{n-1} + c)\mod m$，其中，$S_0$ 称为这个随机序列的种子，a,c,m是三个常数，不过这三个数不能随意选，m的大小决定随机数的周期，最大周期等于m，为了便于在计算机里实现，通常m选取$2^{32}$或$2^{64}$。在m已经确定为这两的时候，为了让周期尽可能大，常数a,c还至少要满足以下条件：</p>

<ol>
<li>若 c 非 0，那么 c 与 m 互质；若 c 为 0，那么 a 与 m 互质</li>
<li>m 所有的素因子均能整除 a-1</li>
<li>若 m 是4的倍数，那么 a-1 也是 4 的倍数</li>
<li>a 和 c 都是正整数且小于 m</li>
</ol>

<p>一些典型的常数取值可以参见wiki上的<a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" target="_blank">线性同余</a>条目。</p>

<h2 id="更高的需求">更高的需求</h2>

<p>我们之所以使用线性同余，就是因为它实现简单，在对随机数质量要求较低的时候，例如用来作为treap的随机数，那么线性同余完全够用，但建议不要使用rand，因为在windows下不少编译器的最大值太小了，导致效果下降，自己写一个用参数<code>a=69069,c=1,m=2^32</code>比rand好，我在那篇关于treap的文章就是用了这组参数。线性同余法最大的缺陷是低位随机性特别差，如果使用类似<code>next() % k</code>的方式来获得区间在$[0,k-1]$的随机数，那么当线性同余迭代方程的m是2的幂且k也是2的幂的时候，灾难就发生了，特别地当k是2的时候，你将得到一个0101的循环序列。为了避免这种情况，通常会取线性同余结果的高位，而且低位去掉得越多，<code>%2</code>的周期就越长。例如结果是64位，取高32位作为最终结果，那么<code>%2</code>的周期就是 $2^{33}$ ，但这样会导致有效位减少，而且问题也没有根本地解决。另一种解决办法是选取一个素数作为m，例如2147483647正是一个素数，但如此一来，线性同余的计算速度就会慢不少，周期也没有前一个的长。两种基本实现如下：</p>

<pre><code class="language-cpp">struct LCG32 : public RNG_base&lt;uint32_t&gt;
{
    uint32_t s;
    static inline uint16_t rotl(const uint16_t x, int k) {
        return (x &lt;&lt; k) | (x &gt;&gt; (16 - k));
    }
    LCG32() { seed(); }
    LCG32(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
    }
    result_type operator()() {
        s = s * 214013UL + 2531011UL;
        return s;
    }
};

struct MCG : public RNG_base&lt;uint32_t, 0x7FFFFFFEULL&gt;
{
    uint64_t s;
    MCG() { seed(); }
    MCG(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
    }
    result_type operator()() {
        s = s * 48271 % 0x7FFFFFFF;
        return (result_type)s;
    }
};
</code></pre>

<p>其中基类<code>RNG_base</code>的定义在下文代码中有。第一个是32位的实现，所以叫做LCG32，如果是64位里面取高32位，那么就叫做<code>LCG64/32</code>。第二个实现没有加法操作，即c=0，这种特例叫做MCG。</p>

<h2 id="随机数的质量和周期">随机数的质量和周期</h2>

<p>如果对生成的随机数质量要求高，例如写一个扑克游戏，如果是52张牌，所有的排列就是 $52!$ （约为$2^{225.5}$），那么我们需要周期比排列数多得多的随机数生成算法以期望所有可能的排列都有机会出现，那到底需要多大呢？这里我们假设平均每16位生成一个8位有效的随机数，我们需要d个随机数得到的排列，即16d个位的所有可能性，都要有可能出现，若满周期的随机数生成器的周期是 $2^{n}$，输出长度为m位，那么我们只要知道$n/m$个输出就能唯一确定生成器的状态，同时这$n/m$个输出的所有可能都会一一出现，即长度为$n$的二进制必定在序列中出现。所以在这种情况下只要$n\geq16d$就能保证所需排列必定会出现。而在前面提到的扑克游戏里，d=52，那么需要的最小周期就是$2^{832}$，总之，只要生成器的周期的$2^{n}$中的n，比你需要生成的排列所需要的二进制流长度要大，那就保证能得到任意一个排列。这时候就最佳选择之一就是<a href="https://en.wikipedia.org/wiki/Mersenne_Twister" target="_blank">梅森旋转</a>，在C++11里的随机数实现默认就是使用它，而且我们一般特指MT19937，即它的周期是 $2^{19937}-1$，如果输出为64位，那么任意长度小于19904位的数据都会在其生成序列中出现（之所以不是19937只是因为它不是输出长度的整数倍），但你要是用这个算法大量生成随机数那是会稍慢一些的，而且这个算法也并没有通过BigCrush的所有测试。我们还存在一种情况，就是需要大量生成随机数，同时质量也有一定要求，速度如果比线性同余还快就更好。</p>

<h2 id="线性同余的改进">线性同余的改进</h2>

<h3 id="输出质量">输出质量</h3>

<p>线性同余法的均匀性非常好，算法也简单，可惜分布性差，有多差呢，咱们用LCG16(0x43FD,0x9EC3)的输出画黑底白点图，相邻两次输出的高9位作为左半图的坐标，低9位作为右半图的坐标，连续采样524288个点，同一坐标出现次数越多亮度越高，于是得到下图</p>

<p><img src="/img/rnd/lcg16.png" alt="" /></p>

<p>左边与右边的都有明显的斜线模式。与以下专业的PCG32生成器做个比较，关注点是亮度比较平均，基本没有特别亮的点，也没有比较多暗点。</p>

<p><img src="/img/rnd/pcg32.png" alt="" /></p>

<p>于是也就有不少人想方设法去改进。首先的改进，便是前面所提及的截取高位作为输出，那么内部数据为64位，输出是32位的，就叫做<code>LCG64/32</code>，同理内部数据为32位，输出是16位的，就叫做<code>LCG32/16</code>，这样一来，随机数质量大幅度提升。基于此实现的版本如下：</p>

<pre><code class="language-cpp">struct LCG32_16 : public RNG_base&lt;uint16_t&gt;
{
    uint32_t s;
    LCG32_16() { seed(); }
    LCG32_16(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        s = s * 214013UL + 2531011UL;
        return s &gt;&gt; 16;
    }
};
</code></pre>

<p>这个代码得到的图形如下</p>

<p><img src="/img/rnd/lcg32_16.png" alt="" /></p>

<p>这样生成的随机数质量就有了一个很大的飞跃。另外，LCG结果的低位，周期性特别短，而LCG结果的高位，对下一个数的影响又特别小，那能不能对这个特性加以利用呢？既然高位对下一个数的影响特别小，我们就创造影响，让高位单独参与计算；既然低位的结果差，那就直接舍弃，同时当高位作为下一个数的位旋转参数，这样避免了最低位的固定 $2^{16}$ 周期的问题。所以可以改写如下：</p>

<pre><code class="language-cpp">struct LCG32_16ro : public RNG_base&lt;uint16_t&gt;
{
    uint32_t s;
    LCG32_16ro() { seed(); }
    LCG32_16ro(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint32_t x = s;
        s = s * 214013UL + 2531011UL;
        return rotl16((uint16_t)(x &gt;&gt; 16u), x &gt;&gt; 28u);
    }
};
</code></pre>

<p><img src="/img/rnd/lcg32_16ro.png" alt="" /></p>

<p>结果反而明显变差了，原因是作为参数的高4位也是输出的一部分，导致那高4位在最终出现的位置是固定的16种情况，解决方法1是不取那4位，取4到11位，方法2是把高16位与低16位做异或运算后再做旋转，两种方案均可解决这个问题，后面的测试使用的是第二种方案，具体代码就不重复了。</p>

<h3 id="输出周期">输出周期</h3>

<p>然后再来看周期，单独一个LCG周期只有 $2^{32}$ 或 $2^{64}$ ，那我们有没有可能通过两个或以上的随机数生成器构造出周期是它们周期之积的的生成器呢？也许一时半会不容易想出来，我们先考虑怎么让一个LCG生成器周期变长。</p>

<p>要注意的是我们不能瞎改，必须是一个满周期的生成器，乱改的话在绝大多数情况下都达不到满周期从而导致返回值的分布不均匀。假如我们手上有一个LCG，周期是p，如果单纯只要周期变长，那我们有一个足够简单的方法，我们增加一个参数x，在原本的LCG输出的结果基础上 xor x 再输出，然后当原来的LCG生成了p次，就让参数x自增1，于是又能生成p个整体与原来不重叠的数，如此循环，于是x的自增周期是p2的话，总周期便是 $p\times{p_2}$ 。可是这明显能感觉到质量可能很糟糕，那解决办法就是，那个x改成另一个LCG来生成即可。这样我们便得到把两个LCG合并得到更大周期的办法。不过，问题是我们为了记录生成次数，似乎还要多定义一个变量来记录生成的次数，这个变量是会影响生成器的状态的，为了避免增加新的变量，在这里我们换个办法，不必生成p次，只要生成结果是某个设定值例如0，就更新第二个LCG，这样就节省了一个变量，于是可以写出以下的代码，为了方便说明，使用的是<code>LCG16</code>，周期是65536。</p>

<pre><code class="language-cpp">struct LCG16_1 : public RNG_base&lt;uint16_t&gt;
{
    uint16_t s, a;
    LCG16_1() { seed(); }
    LCG16_1(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &gt;&gt; 16);
    }
    result_type operator()() {
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ s;
    }
};
</code></pre>

<p>这样把两个 $2^{16}$ 周期的LCG组合起来，确实得到了 $2^{32}$ 周期的LCG，不过之所以用周期这么小的，是为了能发现问题，我们能穷举这个LCG的生成序列，我们能轻易找出多处大段大段的随机数完全相同，有多大段呢，1千到3万个不等，即之前生成的数千个随机数，后面某处又重现了这个序列，而且在 $2^{32}$ 周期内发生。这说明单纯这样组合，结果是糟糕的。具体图形如下：</p>

<p><img src="/img/rnd/lcg16_1.png" alt="" /></p>

<p>所以我们加上前面的位旋转，以期望减少这种情况的出现：</p>

<pre><code class="language-cpp">struct LCG16_2 : public RNG_base&lt;uint16_t&gt;
{
    uint16_t s, a;
    LCG16_2() { seed(); }
    LCG16_2(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &gt;&gt; 16);
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ rotl16(x, x &gt;&gt; 12);
    }
};
</code></pre>

<p><img src="/img/rnd/lcg16_2.png" alt="" /></p>

<p>出现这个情况的原因前面有解释，正是高4位导致的。对此，为了把高4位的模式抹除，改为<code>rotl16(x ^ (x &lt;&lt; k), x &gt;&gt; 12)</code>，只要k大于等于4，这个模式就迅速消失。取k为7得到代码：</p>

<pre><code class="language-cpp">struct LCG16_3 : public RNG_base&lt;uint16_t&gt;
{
    uint16_t s, a;
    LCG16_3() { seed(); }
    LCG16_3(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &gt;&gt; 16);
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ rotl16(x ^ (x &lt;&lt; 7), x &gt;&gt; 12);
    }
};
</code></pre>

<p><img src="/img/rnd/lcg16_3.png" alt="" /></p>

<p>我们还可以再考虑一个问题，之前都是用高位的旋转参数对自己旋转，那可不可以错开，改为旋转下一个数呢？答案是可以的，生成的结果仍然是满周期的，也不存在高4位位置固定的问题，得到的代码和图形是</p>

<pre><code class="language-cpp">struct LCG16_4 : public RNG_base&lt;uint16_t&gt;
{
    uint16_t s, a;
    LCG16_4() { seed(); }
    LCG16_4(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a = (uint16_t)(seed1 &gt;&gt; 16);
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) a = a * (uint16_t)0x101 + (uint16_t)0x9527;
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return a ^ rotl16(s, x &gt;&gt; 12);
    }
};
</code></pre>

<p><img src="/img/rnd/lcg16_4.png" alt="" /></p>

<p>于是我们确实得到了一个看起来更随机的生成器，但3和4的图仔细观察仍然能发现左边的图有规律的线条模式，和专业算法比较还是能看出差距，不过这个问题之后再去解决。那如果我们需要任意加大周期要怎么做呢，如果单纯按这个思路，那么增加了n级，就会导致输出要异或n次，代码也难写。这里要换一个思路，我们把扩展状态做成一个数组，每次只与数组中其中一个元素来异或运算，而选择的方法利用LCG的低位是循环的特性，具体代码如下：</p>

<pre><code class="language-cpp">template &lt;uint16_t ext_bit = 2&gt;
struct LCG16s : public RNG_base&lt;uint16_t&gt;
{
    static const uint16_t ext_size = 1 &lt;&lt; ext_bit, ext_mask = ext_size - 1;
    uint16_t s, a[ext_size];
    LCG16s() { seed(); }
    LCG16s(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a[0] = (uint16_t)(seed1 &gt;&gt; 16);
        if (ext_size &gt; 1) a[1] = (uint16_t)(seed1 &gt;&gt; 32);
        if (ext_size &gt; 2) a[2] = (uint16_t)(seed1 &gt;&gt; 48);
        for (uint16_t i = 3; i &lt; ext_size; ++i) {
            a[i] = rotl16(a[i - 1] * (uint16_t)0x43FD + (uint16_t)0x9EC3, a[i-3] &amp; 15) ^ a[i - 2];
        }
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) {
            for (uint16_t i = 0; i &lt; ext_size; ++i) {
                a[i] = (a[i] * (uint16_t)0x101 + (uint16_t)0x9527);
                if (a[i]) break;
            }
        }
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return rotl16(s, x &gt;&gt; 12) ^ a[x &amp; ext_mask];
    }
};
</code></pre>

<p><img src="/img/rnd/lcg16s.png" alt="" /></p>

<p>从图上就能直观看出这东西有问题，问题在哪呢？以上这个生成器的周期在模板参数假设是n，那么其周期为 $ 2^{16 \times (2^n + 1)}$，可以任意加大周期。可是就在这个时候就出现问题了，我们假设参数是8，那么数组大小为256，那当s为0的时候，大多数情况下只有<code>a[0]</code>发生改变，那导致的结果就是在下一个短周期里，每256个数有255个与前一个短周期完全一样，所以我们要做修改，每次s为0的时候，a数组每一个数都得至少更新一次，且如果<code>a[i]</code>为0，那<code>a[i+1]</code>就更新两遍，这样可以改写如下：</p>

<pre><code class="language-cpp">template &lt;uint16_t ext_bit = 2&gt;
struct LCG16_ext : public RNG_base&lt;uint16_t&gt;
{
    static const uint16_t ext_size = 1 &lt;&lt; ext_bit, ext_mask = ext_size - 1;
    uint16_t s, a[ext_size];
    LCG16_ext() { seed(); }
    LCG16_ext(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = (uint16_t)seed1;
        a[0] = (uint16_t)(seed1 &gt;&gt; 16);
        if (ext_size &gt; 1) a[1] = (uint16_t)(seed1 &gt;&gt; 32);
        if (ext_size &gt; 2) a[2] = (uint16_t)(seed1 &gt;&gt; 48);
        for (uint16_t i = 3; i &lt; ext_size; ++i) {
            a[i] = rotl16(a[i - 1] * (uint16_t)0x43FD + (uint16_t)0x9EC3, a[i-3] &amp; 15) ^ a[i - 2];
        }
    }
    result_type operator()() {
        uint16_t x = s;
        if (s == 0) {
            for (uint16_t i = 0, carry = 0; i &lt; ext_size; ++i) {
                if (carry) carry = (a[i] = (a[i] * (uint16_t)0x101 + (uint16_t)0x9527)) == 0;
                carry |= (a[i] = (a[i] * (uint16_t)0x101 + (uint16_t)0x9527)) == 0;
            }
        }
        s = s * (uint16_t)0x43FD + (uint16_t)0x9EC3;
        return rotl16(s, x &gt;&gt; 12) ^ a[x &amp; ext_mask];
    }
};
</code></pre>

<p><img src="/img/rnd/lcg16_ext.png" alt="" /></p>

<p>以上这个版本经过一些简单的测试，符合满周期且概率均等。当然这个uint16有点太小，于是仍然能从图里看出分布有点问题，左边的图存在明暗间隔的竖条和横条，即问题存在于高位。所以本节的最后提供一个<code>LCG64_32_ext</code>的完整实现，参数ext_bit为n，那么其周期为 $ 2^{32 \times (2^n + 2)}$</p>

<pre><code class="language-cpp">template &lt;uint16_t ext_bit = 2&gt;
struct LCG64_32_ext : public RNG_base&lt;uint32_t&gt;
{
    static const uint64_t ext_size = 1ULL &lt;&lt; ext_bit, ext_mask = ext_size - 1;
    const int init_iter = 256 * 256;
    uint64_t s;
    uint32_t a[ext_size];
    LCG64_32_ext() { seed(); }
    LCG64_32_ext(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s = seed1;
        a[0] = (uint32_t)(seed1 &gt;&gt; 32);
        if (ext_size &gt; 1) a[1] = (uint32_t)seed2;
        if (ext_size &gt; 2) a[2] = (uint32_t)(seed2 &gt;&gt; 32);
        for (uint32_t i = 3; i &lt; ext_size; ++i) {
            a[i] = rotl32((uint32_t)(a[i - 1] * seed_mul + 1), a[i - 2] &amp; 15) ^ a[i - 2];
        }
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint64_t x = s;
        if (s == 0) {
            for (uint64_t i = 0, carry = 0; i &lt; ext_size; ++i) {
                if (carry) carry = (a[i] = (a[i] * 2891336453u + 887987685u)) == 0;
                carry |= (a[i] = (a[i] * 2891336453u + 887987685u)) == 0;
            }
        }
        s = s * 3935559000370003845ULL + 1442695040888963407ULL;
        return rotr32((uint32_t)(s &gt;&gt; 32), x &gt;&gt; 59) ^ a[x &amp; ext_mask];
    }
};
</code></pre>

<p><img src="/img/rnd/lcg64_32_ext.png" alt="" /></p>

<p>这个图已经能与PCG的图看不出明显的差异，而且能通过BigCrash测试。当然，这样的实现还没有经过严格的随机性测试，这里只是给大家思路，以上代码建议不要用于实际使用场景。另外，以上思路参考自<a href="http://www.pcg-random.org/" target="_blank">PCG</a>算法。</p>

<h2 id="lua的修改">lua的修改</h2>

<p>通过参阅lua的源代码，最早的时候，它还是直接使用的C语言内置的rand，后来被诟病随机数范围太小、生成的质量太差。所以后来做了一番改进，在2018年之前，使用的是TausWorthe的一个随机数算法，周期为 $2^{223}-1$ ，所以又叫做 TausWorthe 223 或 TW223，代码参见后文的<code>taus_worthe223</code>。这里要介绍的是lua在2018年之后更换的新随机数算法。</p>

<h2 id="xoshiro-xoroshiro">xoshiro/xoroshiro</h2>

<p>而在2018年，新出现的<a href="http://prng.di.unimi.it/" target="_blank">xoshiro/xoroshiro</a>算法以其周期更大、质量更高、速度更快的特性，很快lua的<a href="http://lua-users.org/lists/lua-l/2018-05/msg00109.html" target="_blank">实现</a>便改用它，而且官方还提供了不同的实现，你可以自行在周期长度、随机数质量、运行速度间自行取舍，这个算法改进自Xorshift，同样属于<a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" target="_blank">LFSR</a>。不过xoshiro/xoroshiro提供的版本实在是太多了，怎么取舍呢？我通过阅读paper，选出了三个建议的版本，分别是<code>xoroshiro128++</code>，<code>xoshiro256**</code>，<code>xoroshiro1024**</code>，名字后面的数字表示周期，例如<code>xoshiro256**</code>的周期是 $2^{256}-1$，而后面的加号和乘号表示生成时所用的运算符，所对应的类名分别是<code>xoroshiro128pp</code>，<code>xoshiro256ss</code>，<code>xoroshiro1024ss</code>。</p>

<p>其生成速度之快超越线性同余法（限64位平台）。而<code>xoshiro256**</code>大多数场合足够使用，且lua<a href="https://github.com/lua/lua/blob/d7bb8df8414f71a290c8a4b1c9f7c6fe839a94df/lmathlib.c#L307" target="_blank">所选择的实现</a>也是它，除非你特别看它不爽非要特别大的周期，那就上<code>xoroshiro1024**</code>吧。而在需要快速产生大量浮点数的场合，官方建议使用<code>xoroshiro128+</code>或<code>xoroshiro256+</code>，但如果生成整数，那请不要选择只有一个<code>+</code>的版本，要选择<code>++</code>或<code>**</code>的版本。</p>

<p>xoshiro/xoroshiro还有一个非常特别的功能，它有个jump和long jump功能，例如对于<code>xoshiro256**</code>，一次jump调用相当于迭代了 $2^{128}$ 次，这样生成的新状态与原来的状态距离非常大，然后用于两个线程，这样就能保证生成的序列不产生重叠，而long jump则相当于迭代 $2^{192}$ 次，这样能生成出4个状态用于4线程，这个特色功能是其它随机数生成器所不具备的。不过以下模板并不包含这部分，有需要的话自己上官网那把代码复制过来用就行。</p>

<h2 id="模板">模板</h2>

<p>这里的实现除了以上所提及的，还包括常见的<code>rand48</code>，<code>taus88</code>，<code>PCG32</code>，<code>well512</code>等等。编译以下代码需要C++11支持，如果要在不支持的编译器上编译就稍微改改就行。</p>

<p><details>
<summary>
  <h4> 点击展开 </h4>
</summary></p>

<pre><code class="language-cpp">template &lt;typename _res_type, uint64_t ret_max = 0xFFFFFFFFFFFFFFFFULL&gt;
struct RNG_base
{
    typedef _res_type result_type;
    static constexpr result_type min() { return 0; }
    static constexpr result_type max() { return (result_type)ret_max; }
    const uint64_t seed_mul = 6364136223846793005ULL;
    const int init_iter = 16;
    uint64_t new_seed() {
        std::random_device rd;
        return ((uint64_t)rd() &lt;&lt; 32) | rd();
    }
    uint64_t def_seed() {
        static uint64_t seed = new_seed();
        seed *= 3935559000370003845ULL;
        return ++seed;
    }
    static inline uint64_t rotl64(const uint64_t x, int k) {
        return (x &lt;&lt; k) | (x &gt;&gt; (64 - k));
    }
    static inline uint64_t rotr64(const uint64_t x, int k) {
        return (x &gt;&gt; k) | (x &lt;&lt; (64 - k));
    }
    static inline uint32_t rotl32(const uint32_t x, int k) {
        return (x &lt;&lt; k) | (x &gt;&gt; (32 - k));
    }
    static inline uint32_t rotr32(const uint32_t x, int k) {
        return (x &gt;&gt; k) | (x &lt;&lt; (32 - k));
    }
    static inline uint16_t rotl16(const uint16_t x, int k) {
        return (x &lt;&lt; k) | (x &gt;&gt; (16 - k));
    }
    static inline uint16_t rotr16(const uint16_t x, int k) {
        return (x &gt;&gt; k) | (x &lt;&lt; (16 - k));
    }
};

struct PCG32 : public RNG_base&lt;uint32_t&gt; // XSH RR
{
    const int init_iter = 1; // min 1
    uint64_t s;
    PCG32() { seed(); }
    PCG32(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint64_t x = s;
        s = s * 6364136223846793005ULL + 1442695040888963407ULL;
        return rotr32((uint32_t)((x ^ (x &gt;&gt; 18)) &gt;&gt; 27), x &gt;&gt; 59);
    }
};

struct rand48 : public RNG_base&lt;uint32_t&gt;
{
    uint16_t s[3];
    static const uint16_t RAND48_A0 = 0xE66D;
    static const uint16_t RAND48_A1 = 0xDEEC;
    static const uint16_t RAND48_A2 = 0x0005;
    static const uint16_t RAND48_C0 = 0x000B;
    rand48() { seed(); }
    rand48(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s[0] = (uint16_t)seed1;
        s[1] = (uint16_t)(seed1 &gt;&gt; 16);
        s[2] = (uint16_t)(seed1 &gt;&gt; 32);
    }
    inline void do_rand48() {
        const uint32_t x0 = s[0];
        const uint32_t x1 = s[1];
        const uint32_t x2 = s[2];

        uint32_t a = RAND48_A0 * x0 + RAND48_C0;
        s[0] = static_cast&lt;uint16_t&gt;(a &amp; 0xFFFF);

        a &gt;&gt;= 16;

        a += RAND48_A0 * x1 + RAND48_A1 * x0;
        s[1] = static_cast&lt;uint16_t&gt;(a &amp; 0xFFFF);

        a &gt;&gt;= 16;
        a += RAND48_A0 * x2 + RAND48_A1 * x1 + RAND48_A2 * x0;
        s[2] = static_cast&lt;uint16_t&gt;(a &amp; 0xFFFF);
    }
    result_type operator()() {
        do_rand48();
        return ((uint32_t)s[2] &lt;&lt; 16) + s[1];
    }
};

struct taus88 : public RNG_base&lt;uint32_t&gt;
{
    uint32_t s[3];
    const int init_iter = 0;
    taus88() { seed(); }
    taus88(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = (uint32_t)seed1;
        s[1] = (uint32_t)(seed1 &gt;&gt; 32);
        s[2] = (uint32_t)(seed2 &gt;&gt; 32);
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    inline uint32_t tausworthe(uint32_t arg, uint32_t stage1, uint32_t stage2, uint32_t stage3, uint32_t limit) {
        return ((arg &amp; limit) &lt;&lt; stage1) ^ (((arg &lt;&lt; stage2) ^ arg) &gt;&gt; stage3);
    }
    result_type operator()() {
        s[0] = tausworthe(s[0], 12, 13, 19, 4294967294UL);
        s[1] = tausworthe(s[1], 4, 2, 25, 4294967288UL);
        s[2] = tausworthe(s[2], 17, 3, 11, 4294967280UL);
        return (s[0] ^ s[1] ^ s[2]);
    }
};

struct taus_worthe223 : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 1; // min 1
    uint64_t gen[4];
    taus_worthe223() { seed(); }
    taus_worthe223(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        gen[0] = seed1;
        gen[1] = seed2;
        gen[2] = seed3;
        gen[3] = seed4;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
#define taus_worthe(i,k,q,s) z = gen[i]; \
    z = (((z &lt;&lt; q) ^ z) &gt;&gt; (k - s)) ^ ((z&amp;((uint64_t)(int64_t)-1 &lt;&lt; (64 - k))) &lt;&lt; s); \
    r ^= z; gen[i] = z
    result_type operator()() {
        uint64_t r = 0, z;
        taus_worthe(0, 63, 31, 18);
        taus_worthe(1, 58, 19, 28);
        taus_worthe(2, 55, 24, 7);
        taus_worthe(3, 47, 21, 8);
        return r;
    }
#undef taus_worthe
};

struct well512 : public RNG_base&lt;uint32_t&gt;
{
    // http://lomont.org/papers/2008/Lomont_PRNG_2008.pdf
    // const int init_iter = 0; // min 0
    const uint64_t seed_mul = 134775813;
    uint32_t s[16];
    uint32_t index;
    well512() { seed(); }
    well512(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = (uint32_t)(seed1);
        s[1] = (uint32_t)(seed1 &gt;&gt; 32);
        s[2] = (uint32_t)(seed2);
        s[3] = (uint32_t)(seed2 &gt;&gt; 32);
        s[4] = (uint32_t)(seed3);
        s[5] = (uint32_t)(seed3 &gt;&gt; 32);
        s[6] = (uint32_t)(seed4);
        s[7] = (uint32_t)(seed4 &gt;&gt; 32);
        uint8_t* t = (uint8_t*)s;
        for (int i = 32, j = 0; i &lt; 64; ++i, ++j) {
            if (i % 4 == 0) {
                for (int k = i / 8; k &lt; 16; ++k)
                    s[k] = s[k - 1] * (uint32_t)seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        index = 0;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        uint32_t a, b, c, d;
        a = s[index];
        c = s[(index + 13) &amp; 15];
        b = a ^ c ^ (a &lt;&lt; 16) ^ (c &lt;&lt; 15);
        c = s[(index + 9) &amp; 15];
        c ^= (c &gt;&gt; 11);
        a = s[index] = b ^ c;
        d = a ^ ((a &lt;&lt; 5) &amp; 0xDA442D24);
        index = (index + 15) &amp; 15;
        a = s[index];
        s[index] = a ^ b ^ d ^ (a &lt;&lt; 2) ^ (b &lt;&lt; 18) ^ (c &lt;&lt; 28);
        return s[index];
    }
};

struct splitmix64 : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s;
    splitmix64() { seed(); }
    splitmix64(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s = seed1;
    }
    result_type operator()() {
        uint64_t z = (s += 0x9e3779b97f4a7c15);
        z = (z ^ (z &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;
        z = (z ^ (z &gt;&gt; 27)) * 0x94d049bb133111eb;
        return z ^ (z &gt;&gt; 31);
    }
};

struct xoshiro64ss : public RNG_base&lt;uint32_t&gt;
{
    //const int init_iter = 1; // min 1
    uint32_t s[2];
    xoshiro64ss() { seed(); }
    xoshiro64ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) {
        s[0] = (uint32_t)seed1;
        s[1] = (uint32_t)(seed1 &gt;&gt; 32);
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint32_t s0 = s[0];
        uint32_t s1 = s[1];
        const uint32_t result = rotl32(s0 * 0x9E3779BB, 5) * 5;
        s1 ^= s0;
        s[0] = rotl32(s0, 26) ^ s1 ^ (s1 &lt;&lt; 9);
        s[1] = rotl32(s1, 13);
        return result;
    }
};

struct xoroshiro128p : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s[2];
    xoroshiro128p() { seed(); }
    xoroshiro128p(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = seed1;
        s[1] = seed2;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t s0 = s[0];
        uint64_t s1 = s[1];
        const uint64_t result = s0 + s1;
        s1 ^= s0;
        s[0] = rotl64(s0, 24) ^ s1 ^ (s1 &lt;&lt; 16);
        s[1] = rotl64(s1, 37);
        return result;
    }
};

struct xoroshiro128pp : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s[2];
    xoroshiro128pp() { seed(); }
    xoroshiro128pp(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = seed1;
        s[1] = seed2;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t s0 = s[0];
        uint64_t s1 = s[1];
        const uint64_t result = rotl64(s0 + s1, 17) + s0;
        s1 ^= s0;
        s[0] = rotl64(s0, 49) ^ s1 ^ (s1 &lt;&lt; 21);
        s[1] = rotl64(s1, 28);
        return result;
    }
};

struct xoroshiro128ss : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 1; // min 1
    uint64_t s[2];
    xoroshiro128ss() { seed(); }
    xoroshiro128ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) {
        s[0] = seed1;
        s[1] = seed2;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t s0 = s[0];
        uint64_t s1 = s[1];
        const uint64_t result = rotl64(s0 * 5, 7) * 9;
        s1 ^= s0;
        s[0] = rotl64(s0, 24) ^ s1 ^ (s1 &lt;&lt; 16);
        s[1] = rotl64(s1, 37);
        return result;
    }
};

struct xoshiro256p : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[4];
    xoshiro256p() { seed(); }
    xoshiro256p(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t result = s[0] + s[3];
        const uint64_t t = s[1] &lt;&lt; 17;
        s[2] ^= s[0];
        s[3] ^= s[1];
        s[1] ^= s[2];
        s[0] ^= s[3];
        s[2] ^= t;
        s[3] = rotl64(s[3], 45);
        return result;
    }
};

struct xoshiro256pp : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[4];
    xoshiro256pp() { seed(); }
    xoshiro256pp(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t result = rotl64(s[0] + s[3], 23) + s[0];
        const uint64_t t = s[1] &lt;&lt; 17;
        s[2] ^= s[0];
        s[3] ^= s[1];
        s[1] ^= s[2];
        s[0] ^= s[3];
        s[2] ^= t;
        s[3] = rotl64(s[3], 45);
        return result;
    }
};

struct xoshiro256ss : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[4];
    xoshiro256ss() { seed(); }
    xoshiro256ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const uint64_t result = rotl64(s[1] * 5, 7) * 9;
        const uint64_t t = s[1] &lt;&lt; 17;
        s[2] ^= s[0];
        s[3] ^= s[1];
        s[1] ^= s[2];
        s[0] ^= s[3];
        s[2] ^= t;
        s[3] = rotl64(s[3], 45);
        return result;
    }
};

struct xoshiro1024ss : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[16];
    int p;
    xoshiro1024ss() { seed(); }
    xoshiro1024ss(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        uint8_t* t = (uint8_t*)s;
        for (int i = 32, j = 0; i &lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    void seed(uint8_t seed[], int size) {
        uint8_t* t = (uint8_t*)s;
        if (size &gt; 128) size = 128;
        for (int i = 0; i &lt; size; ++i) {
            t[i] = ((uint8_t*)seed)[i];
        }
        if (size == 0) {
            size = 8; s[0] = 0x931197d8e3177f17ULL;
        }
        for (int i = size, j = 0; i &lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const int q = p;
        const uint64_t s0 = s[p = (p + 1) &amp; 15];
        uint64_t s15 = s[q];
        const uint64_t result = rotl64(s0 * 5, 7) * 9;

        s15 ^= s0;
        s[q] = rotl64(s0, 25) ^ s15 ^ (s15 &lt;&lt; 27);
        s[p] = rotl64(s15, 36);

        return result;
    }
};

struct xoshiro1024pp : public RNG_base&lt;uint64_t&gt;
{
    //const int init_iter = 0; // min 0
    uint64_t s[16];
    int p;
    xoshiro1024pp() { seed(); }
    xoshiro1024pp(uint64_t seed1) { seed(seed1); }
    void seed() { seed(def_seed()); }
    void seed(uint64_t seed1) { seed(seed1, seed1 * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2) { seed(seed1, seed2, seed2 * seed_mul + 1, (seed1 ^ seed2) * seed_mul + 1); }
    void seed(uint64_t seed1, uint64_t seed2, uint64_t seed3, uint64_t seed4) {
        s[0] = seed1;
        s[1] = seed2;
        s[2] = seed3;
        s[3] = seed4;
        uint8_t* t = (uint8_t*)s;
        for (int i = 32, j = 0; i &lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    void seed(uint8_t seed[], int size) {
        uint8_t* t = (uint8_t*)s;
        if (size &gt; 128) size = 128;
        for (int i = 0; i &lt; size; ++i) {
            t[i] = ((uint8_t*)seed)[i];
        }
        if (size == 0) {
            size = 8; s[0] = 0x931197d8e3177f17ULL;
        }
        for (int i = size, j = 0; i &lt; 128; ++i, ++j) {
            if (i % 8 == 0) {
                for (int k = i / 8; k &lt; 16; ++k)
                    s[k] = s[k - 1] * seed_mul + 1;
                break;
            }
            t[i] = t[j] * (uint8_t)5 + ~t[i - 1];
        }
        p = 0;
        for (int i = 0; i &lt; init_iter; ++i) (*this)();
    }
    result_type operator()() {
        const int q = p;
        const uint64_t s0 = s[p = (p + 1) &amp; 15];
        uint64_t s15 = s[q];
        const uint64_t result = rotl64(s0 + s15, 23) + s15;

        s15 ^= s0;
        s[q] = rotl64(s0, 25) ^ s15 ^ (s15 &lt;&lt; 27);
        s[p] = rotl64(s15, 36);

        return result;
    }
};
</code></pre>

<p></details></p>

<h2 id="效率测试">效率测试</h2>

<p>我们当然不能全信官方的数据，具体表现不同机器不同编译器也可能不相同，所以我们就来测试一下。测试所用的实现均为我个人实现的版本，不代表官方版本的运行效率，PCG32使用的是XSH-RR，PCG64使用的是XSL-RR</p>

<p>在x86下测试标准是生成2亿个64位随机数的运行时间，如生成器生成的是32位，那么生成4亿个32位整数，即以相同输出位数的时间来做比较</p>

<h3 id="x86">x86</h3>

<p>在VS2015上以x86编译的运行时间</p>

<table>
<thead>
<tr>
<th>算法实现</th>
<th align="right">毫秒</th>
</tr>
</thead>

<tbody>
<tr>
<td>LCG32</td>
<td align="right">394</td>
</tr>

<tr>
<td>LCG64_32</td>
<td align="right">1502</td>
</tr>

<tr>
<td>LCG32_16_ext,4</td>
<td align="right">2034</td>
</tr>

<tr>
<td>LCG64_32_ext,2</td>
<td align="right">2579</td>
</tr>

<tr>
<td>PCG32</td>
<td align="right">1819</td>
</tr>

<tr>
<td>PCG64</td>
<td align="right">6705</td>
</tr>

<tr>
<td>PCG32_ext,2</td>
<td align="right">2581</td>
</tr>

<tr>
<td>rand48</td>
<td align="right">2221</td>
</tr>

<tr>
<td>taus88</td>
<td align="right">1232</td>
</tr>

<tr>
<td>taus_worthe223</td>
<td align="right">1844</td>
</tr>

<tr>
<td>well512</td>
<td align="right">1794</td>
</tr>

<tr>
<td>splitmix64</td>
<td align="right">2118</td>
</tr>

<tr>
<td>xorshift128</td>
<td align="right">605</td>
</tr>

<tr>
<td>xorshift128p</td>
<td align="right">882</td>
</tr>

<tr>
<td>xoshiro64ss</td>
<td align="right">534</td>
</tr>

<tr>
<td>xoroshiro128p</td>
<td align="right">1181</td>
</tr>

<tr>
<td>xoroshiro128pp</td>
<td align="right">1194</td>
</tr>

<tr>
<td>xoroshiro128ss</td>
<td align="right">1382</td>
</tr>

<tr>
<td>xoshiro256p</td>
<td align="right">1279</td>
</tr>

<tr>
<td>xoshiro256pp</td>
<td align="right">1856</td>
</tr>

<tr>
<td>xoshiro256ss</td>
<td align="right">1513</td>
</tr>

<tr>
<td>xoshiro1024pp</td>
<td align="right">1472</td>
</tr>

<tr>
<td>xoshiro1024ss</td>
<td align="right">1585</td>
</tr>

<tr>
<td>std::mt19937</td>
<td align="right">1651</td>
</tr>
</tbody>
</table>

<p>在mingw32 gcc5.1.0 以<code>-O2</code>参数编译的结果</p>

<table>
<thead>
<tr>
<th>算法实现</th>
<th align="right">毫秒</th>
</tr>
</thead>

<tbody>
<tr>
<td>LCG32</td>
<td align="right">398</td>
</tr>

<tr>
<td>LCG64_32</td>
<td align="right">1219</td>
</tr>

<tr>
<td>LCG32_16_ext,4</td>
<td align="right">1008</td>
</tr>

<tr>
<td>LCG64_32_ext,2</td>
<td align="right">877</td>
</tr>

<tr>
<td>PCG32</td>
<td align="right">1384</td>
</tr>

<tr>
<td>PCG64</td>
<td align="right">3141</td>
</tr>

<tr>
<td>PCG32_ext,2</td>
<td align="right">1439</td>
</tr>

<tr>
<td>rand48</td>
<td align="right">1084</td>
</tr>

<tr>
<td>taus88</td>
<td align="right">705</td>
</tr>

<tr>
<td>taus_worthe223</td>
<td align="right">1757</td>
</tr>

<tr>
<td>well512</td>
<td align="right">1173</td>
</tr>

<tr>
<td>splitmix64</td>
<td align="right">1267</td>
</tr>

<tr>
<td>xorshift128</td>
<td align="right">663</td>
</tr>

<tr>
<td>xorshift128p</td>
<td align="right">919</td>
</tr>

<tr>
<td>xoshiro64ss</td>
<td align="right">462</td>
</tr>

<tr>
<td>xoroshiro128p</td>
<td align="right">821</td>
</tr>

<tr>
<td>xoroshiro128pp</td>
<td align="right">951</td>
</tr>

<tr>
<td>xoroshiro128ss</td>
<td align="right">1036</td>
</tr>

<tr>
<td>xoshiro256p</td>
<td align="right">845</td>
</tr>

<tr>
<td>xoshiro256pp</td>
<td align="right">1094</td>
</tr>

<tr>
<td>xoshiro256ss</td>
<td align="right">1205</td>
</tr>

<tr>
<td>xoshiro1024pp</td>
<td align="right">1067</td>
</tr>

<tr>
<td>xoshiro1024ss</td>
<td align="right">1074</td>
</tr>

<tr>
<td>std::mt19937</td>
<td align="right">1033</td>
</tr>
</tbody>
</table>

<h3 id="x64">x64</h3>

<p>在VS2015上以x64编译的运行时间</p>

<table>
<thead>
<tr>
<th>算法实现</th>
<th align="right">毫秒</th>
</tr>
</thead>

<tbody>
<tr>
<td>LCG32</td>
<td align="right">396</td>
</tr>

<tr>
<td>LCG64_32</td>
<td align="right">399</td>
</tr>

<tr>
<td>LCG32_16_ext,4</td>
<td align="right">1207</td>
</tr>

<tr>
<td>LCG64_32_ext,2</td>
<td align="right">609</td>
</tr>

<tr>
<td>PCG32</td>
<td align="right">407</td>
</tr>

<tr>
<td>PCG64</td>
<td align="right">670</td>
</tr>

<tr>
<td>PCG32_ext,2</td>
<td align="right">988</td>
</tr>

<tr>
<td>rand48</td>
<td align="right">1033</td>
</tr>

<tr>
<td>taus88</td>
<td align="right">1147</td>
</tr>

<tr>
<td>taus_worthe223</td>
<td align="right">759</td>
</tr>

<tr>
<td>well512</td>
<td align="right">1821</td>
</tr>

<tr>
<td>splitmix64</td>
<td align="right">212</td>
</tr>

<tr>
<td>xorshift128</td>
<td align="right">516</td>
</tr>

<tr>
<td>xorshift128p</td>
<td align="right">328</td>
</tr>

<tr>
<td>xoshiro64ss</td>
<td align="right">515</td>
</tr>

<tr>
<td>xoroshiro128p</td>
<td align="right">215</td>
</tr>

<tr>
<td>xoroshiro128pp</td>
<td align="right">267</td>
</tr>

<tr>
<td>xoroshiro128ss</td>
<td align="right">232</td>
</tr>

<tr>
<td>xoshiro256p</td>
<td align="right">151</td>
</tr>

<tr>
<td>xoshiro256pp</td>
<td align="right">182</td>
</tr>

<tr>
<td>xoshiro256ss</td>
<td align="right">193</td>
</tr>

<tr>
<td>xoshiro1024pp</td>
<td align="right">492</td>
</tr>

<tr>
<td>xoshiro1024ss</td>
<td align="right">462</td>
</tr>

<tr>
<td>std::mt19937</td>
<td align="right">1580</td>
</tr>
</tbody>
</table>

<p>在centos7x64 gcc8.3.1 以<code>-O2</code>参数编译的结果</p>

<table>
<thead>
<tr>
<th>算法实现</th>
<th align="right">毫秒</th>
</tr>
</thead>

<tbody>
<tr>
<td>LCG32</td>
<td align="right">426</td>
</tr>

<tr>
<td>LCG64_32</td>
<td align="right">413</td>
</tr>

<tr>
<td>LCG32_16_ext,4</td>
<td align="right">1115</td>
</tr>

<tr>
<td>LCG64_32_ext,2</td>
<td align="right">505</td>
</tr>

<tr>
<td>PCG32</td>
<td align="right">434</td>
</tr>

<tr>
<td>PCG64</td>
<td align="right">392</td>
</tr>

<tr>
<td>PCG32_ext,2</td>
<td align="right">511</td>
</tr>

<tr>
<td>rand48</td>
<td align="right">839</td>
</tr>

<tr>
<td>taus88</td>
<td align="right">707</td>
</tr>

<tr>
<td>taus_worthe223</td>
<td align="right">448</td>
</tr>

<tr>
<td>well512</td>
<td align="right">1009</td>
</tr>

<tr>
<td>splitmix64</td>
<td align="right">186</td>
</tr>

<tr>
<td>xorshift128</td>
<td align="right">525</td>
</tr>

<tr>
<td>xorshift128p</td>
<td align="right">229</td>
</tr>

<tr>
<td>xoshiro64ss</td>
<td align="right">476</td>
</tr>

<tr>
<td>xoroshiro128p</td>
<td align="right">168</td>
</tr>

<tr>
<td>xoroshiro128pp</td>
<td align="right">217</td>
</tr>

<tr>
<td>xoroshiro128ss</td>
<td align="right">237</td>
</tr>

<tr>
<td>xoshiro256p</td>
<td align="right">181</td>
</tr>

<tr>
<td>xoshiro256pp</td>
<td align="right">191</td>
</tr>

<tr>
<td>xoshiro256ss</td>
<td align="right">182</td>
</tr>

<tr>
<td>xoshiro1024pp</td>
<td align="right">292</td>
</tr>

<tr>
<td>xoshiro1024ss</td>
<td align="right">314</td>
</tr>

<tr>
<td>std::mt19937</td>
<td align="right">2112</td>
</tr>
</tbody>
</table>

<p>从以上数据来看，首先要区分架构，如果是32位的，<code>++</code>的更快，而在64位上则大多<code>**</code>稍快，而现在大多数系统都支持64位的情况下，优先考虑<code>**</code>的版本。而256与128的差距很小，不建议使用128，除非你确实要省这么点内存。综合最佳的是<code>xoshiro256**</code>，即表格里的xoshiro256ss，64位架构下比线性同余快，而且质量好得多，推荐使用它。而如果你需要同时考虑32位和64位，那选择<code>xoshiro256++</code>也是不错的。再者，如果你只需要生成浮点随机数，那么xoroshiro128p是速度最快的。不过老实说，大多数场合都没有必要对这么点差别纠结，选择一个合适的就行了，而且VS测试结果很迷，优化得让人猜不透，我认为以gcc的结果优先作为参考。以上数据仅供参考。</p>

<h2 id="随机性测试">随机性测试</h2>

<p>使用 TestU01 1.2.3 版的 SmallCrash, Crash 和 BigCrash 进行测试（如SmallCrash未通过则不测试Crash，Crash未通过则不测试BigCrash），横线<code>-</code>表示通过测试，<code>/</code>表示不进行测试，<code>?</code>表示未测试</p>

<table>
<thead>
<tr>
<th>算法实现</th>
<th align="left">状态空间(bits)</th>
<th align="left">状态周期</th>
<th align="left">SmallCrash<br/>未通过项</th>
<th align="left">Crash<br/>未通过项</th>
<th align="left">BigCrash<br/>未通过项</th>
</tr>
</thead>

<tbody>
<tr>
<td>LCG32</td>
<td align="left">32</td>
<td align="left">$2^{32}$</td>
<td align="left">MaxOft<br/>&hellip;.<sup>[1]</sup></td>
<td align="left">/</td>
<td align="left">/</td>
</tr>

<tr>
<td>LCG64_32</td>
<td align="left">64</td>
<td align="left">$2^{32}$</td>
<td align="left">-</td>
<td align="left">CollisionOver<br/>BirthdaySpacings</td>
<td align="left">/</td>
</tr>

<tr>
<td>LCG32_16ro</td>
<td align="left">32</td>
<td align="left">$2^{32}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">MaxOft<br/>&hellip;.<sup>[2]</sup></td>
</tr>

<tr>
<td>LCG32_16_ext,0</td>
<td align="left">48</td>
<td align="left">$2^{48}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">SerialOver<br/>&hellip;<sup>[3]</sup></td>
</tr>

<tr>
<td>LCG32_16_ext,4</td>
<td align="left">288</td>
<td align="left">$2^{288}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>LCG64_32_ext,0</td>
<td align="left">96</td>
<td align="left">$2^{96}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>PCG16</td>
<td align="left">32</td>
<td align="left">$2^{32}$</td>
<td align="left">-</td>
<td align="left">SerialOver<br/>MaxOft</td>
<td align="left">/</td>
</tr>

<tr>
<td>PCG32</td>
<td align="left">64</td>
<td align="left">$2^{64}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>PCG64</td>
<td align="left">128</td>
<td align="left">$2^{128}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>PCG32_ext,0</td>
<td align="left">96</td>
<td align="left">$2^{96}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>rand48</td>
<td align="left">48</td>
<td align="left">$2^{48}$</td>
<td align="left">SimpPoker<br/>&hellip;.<sup>[4]</sup></td>
<td align="left">/</td>
<td align="left">/</td>
</tr>

<tr>
<td>taus88</td>
<td align="left">96</td>
<td align="left">$2^{88}-1$</td>
<td align="left">-</td>
<td align="left">MatrixRank<br/>LinearComp</td>
<td align="left">/</td>
</tr>

<tr>
<td>taus_worthe223</td>
<td align="left">256</td>
<td align="left">$2^{223}-1$</td>
<td align="left">-</td>
<td align="left">MaxOft<br/>MatrixRank<br/>LinearComp</td>
<td align="left">/</td>
</tr>

<tr>
<td>well512</td>
<td align="left">512</td>
<td align="left">$2^{512}-1$</td>
<td align="left">-</td>
<td align="left">MatrixRank<br/>LinearComp</td>
<td align="left">/</td>
</tr>

<tr>
<td>splitmix64</td>
<td align="left">64</td>
<td align="left">$2^{64}$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xorshift64s</td>
<td align="left">64</td>
<td align="left">$2^{64}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">MatrixRank</td>
</tr>

<tr>
<td>xorshift128</td>
<td align="left">128</td>
<td align="left">$2^{128}-1$</td>
<td align="left">MaxOft</td>
<td align="left">/</td>
<td align="left">/</td>
</tr>

<tr>
<td>xorshift128p</td>
<td align="left">128</td>
<td align="left">$2^{128}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-<sup>[5]</sup></td>
</tr>

<tr>
<td>xoshiro64ss</td>
<td align="left">64</td>
<td align="left">$2^{64}-1$</td>
<td align="left">-</td>
<td align="left">A.S.<sup>[6]</sup></td>
<td align="left">/</td>
</tr>

<tr>
<td>xoroshiro128p</td>
<td align="left">128</td>
<td align="left">$2^{128}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xoroshiro128pp</td>
<td align="left">128</td>
<td align="left">$2^{128}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xoroshiro128ss</td>
<td align="left">128</td>
<td align="left">$2^{128}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xoshiro256p</td>
<td align="left">256</td>
<td align="left">$2^{256}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xoshiro256pp</td>
<td align="left">256</td>
<td align="left">$2^{256}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xoshiro256ss</td>
<td align="left">256</td>
<td align="left">$2^{256}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xoshiro1024pp</td>
<td align="left">1056</td>
<td align="left">$2^{1024}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>xoshiro1024ss</td>
<td align="left">1056</td>
<td align="left">$2^{1024}-1$</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>

<tr>
<td>std::mt19937</td>
<td align="left">20032</td>
<td align="left">$2^{19937}-1$</td>
<td align="left">-</td>
<td align="left">LinearComp</td>
<td align="left">/</td>
</tr>
</tbody>
</table>

<p>注解：</p>

<ol>
<li>LCG32未通过的项：BirthdaySpacings, Collision, Gap, SimpPoker, CouponCollector, MaxOft, WeightDistrib, MatrixRank, HammingIndep, RandomWalk1</li>
<li>LCG32_16ro的实现代码并不是本文中描述的有问题的版本，它是列表里唯一一个32位能通过SmallCrash和Crash测试的实现。BigCrash未通过的项：CouponCollector, Gap, MaxOft, WeightDistrib, SumCollector, LongestHeadRun, PeriodsInStrings</li>
<li>LCG32_16ext,0在BigCrash未通过的项：SerialOver, CouponCollector, WeightDistrib, PeriodsInStrings</li>
<li>rand48未通过的项：BirthdaySpacings, Gap, SimpPoker, WeightDistrib, CouponCollector</li>
<li>据wiki，xorshift128p输出reversed的情况下不能通过BigCrash测试</li>
<li>xoshiro64ss未通过的项：AppearanceSpacings</li>
</ol>

<p>随机性测试的部分结果也会带有一定的随机性，多次测试的结果可能不同，测试结果仅供参考</p>

<h2 id="生成-0-1-0-范围的均匀分布浮点数">生成 $[0, 1.0)$ 范围的均匀分布浮点数</h2>

<p>以上模板生成的都是无符号整数，如果要生成浮点数的话，以上的模板里除了<code>MCG</code>不能直接用以下函数外，其它的都可以直接使用（速度快），用来把生成的整数转换成对应的浮点数。又或者，你可以直接用STL的<code>uniform_real_distribution</code>（通用性好），以上全部模板支持STL的distribution系列。</p>

<pre><code class="language-cpp">float rand_float(uint32_t rnd)
{
    union {
        float f;
        uint32_t u;
    }x;
    x.u = ((rnd &gt;&gt; 9) | 0x3F800000UL);
    return x.f - 1.0f;
}

double rand_float(uint64_t rnd)
{
    union {
        double d;
        uint64_t u;
    } x;
    x.u = ((rnd &gt;&gt; 12) | 0x3FF0000000000000UL);
    return x.d - 1.0;
}
</code></pre>

<h2 id="生成-0-n-范围的均匀分布随机整数">生成 $[0, n]$ 范围的均匀分布随机整数</h2>

<p>很多人第一个方案就是 <code>rnd % (n + 1)</code> ，其实这是错误的，在你对随机数分布要求不高的时候可以这么用，否则只要n+1不是2的整数次幂，获得的随机数就不是均匀分布的，除了直接使用STL的<code>uniform_int_distribution</code>，自己写的话，除了<code>MCG</code>不能直接用以下函数外，其它的大多可以直接使用（条件是参数eg的随机引擎生成的随机数最大值必须大于等于n）</p>

<pre><code class="language-cpp">template&lt;class _Eg&gt;
static uint64_t i64_distribution(_Eg&amp; eg, uint64_t n)
{
    ++n;
    if ((n &amp; -n) == n)
        return (int64_t)eg() &amp; (n-1);
    uint64_t m = n;
    while (m &amp; (m - 1)) m += m &amp; -m;
    --m;
    for (;;)
    {
        uint64_t r = (uint64_t)eg() &amp; m;
        if (r &lt; n)
            return r;
    }
}
</code></pre>

<p>不过这样的缺点是如果n比较小，那随机数据的大部分都浪费了，为了能更大地利用随机数据，可以做如下的改进，按n的大小分为1，2，4，8字节，每次从随机数据里取1，2，4，8个字节，多余的部分留下次使用，这样既照顾了速度也照顾了数据利用率。如果你需要能生成任意大小，那么你需要把随机数引擎作为二进制流数据生成，然后再从二进制流读取 $log_2n$ 个bit来做以上操作，这样代码较为复杂，但在n较小的时候能最大限度的利用生成的数据，这里就不具体展开了，有这个需求的话直接使用 <code>uniform_int_distribution</code> 就足够了。以上全部模板支持直接调用。</p>

<p>网上还有很多其它的错误生成方法，以下给大家带来一个视频，我觉得讲解得不错</p>

<iframe src="https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful/player" width="960" height="540" allowFullScreen frameBorder="0" title="rand() Considered Harmful - Microsoft Channel 9 Video"></iframe>

<h2 id="后记">后记</h2>

<p>随机数生成是一个大坑，以上只是做个简单得不能再简单的介绍，我只是碰巧看到lua更新了这个顺便更新一波，写个普及文，要是自己去创造一个随机数算法，我觉得比写别的算法还困难不少，绝大多数的实现都经不起数学推敲。之后有时间再收集收集资料再做介绍。</p>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" target="_blank">线性同余</a> LCG</p>

<p><a href="https://en.wikipedia.org/wiki/Lehmer_random_number_generator" target="_blank">MCG</a></p>

<p><a href="https://en.wikipedia.org/wiki/Mersenne_Twister" target="_blank">梅森旋转</a></p>

<p><a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register" target="_blank">LFSR</a></p>

<p><a href="http://prng.di.unimi.it/" target="_blank">xoshiro/xoroshiro</a></p>

<p><a href="http://www.pcg-random.org/" target="_blank">PCG</a></p>

<p><a href="http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf" target="_blank">PCG pdf</a></p>

<p><a href="http://www.sprng.org/Version5.0/parameters.html" target="_blank">LCG Generator Parameters</a></p>

<p><a href="https://en.wikipedia.org/wiki/List_of_random_number_generators" target="_blank">List of random number generators</a></p>
    </div>

    


    

<div class="article-tags">
  
  <a class="badge badge-light" href="">算法</a>
  
  <a class="badge badge-light" href="/tags/lcg/">LCG</a>
  
  <a class="badge badge-light" href="/tags/pcg/">PCG</a>
  
  <a class="badge badge-light" href="/tags/xoshiro/xoroshiro/">xoshiro/xoroshiro</a>
  
  <a class="badge badge-light" href="">随机数</a>
  
  <a class="badge badge-light" href="">模板</a>
  
  <a class="badge badge-light" href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
  
</div>



    
      








  






  
  
  
    
  
  
  <div class="media author-card">
    
      
      <img class="portrait mr-3" src="/authors/admin/avatar_hu7aaa46bd12fd0c0b960b4100abd18eca_101820_250x250_fill_q90_lanczos_center.jpg" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title"><a href="/">抱抱熊</a></h5>
      
      <p class="card-text">一个喜欢折腾和研究算法的大学生</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/baobaobear" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>



      
      
      <div class="article-widget">
        <div class="hr-light"></div>
        <h3>Related</h3>
        <ul>
          
          <li><a href="/post/20191231-persistent_segtree/">可持久化线段树</a></li>
          
          <li><a href="/post/20191216-kmp-manacher/">扩展KMP与Manacher</a></li>
          
          <li><a href="/post/20191215-fhq-treap/">FHQ Treap</a></li>
          
          <li><a href="/post/20191213-tree-sequence/">平衡树与序列维护</a></li>
          
          <li><a href="/post/20191211-treap-sbt/">Treap与SBT</a></li>
          
        </ul>
      </div>
      
    

    

    
<section id="comments">
  
    
<div id="disqus_thread"></div>
<script>
  let disqus_config = function () {
    
    
    
  };
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
      return;
    }
    var d = document, s = d.createElement('script'); s.async = true;
    s.src = 'https://' + "baobaobear" + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  
</section>



  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js" integrity="sha256-0w92bcB21IY5+rGI84MGj52jNfHNbXVeQLrZ0CGdjNY=" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/cpp.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js" integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log==" crossorigin="anonymous"></script>
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    <script id="dsq-count-scr" src="https://baobaobear.disqus.com/count.js" async></script>
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.d6bd04fdad2ad213aa8111c5a3b72fc5.js"></script>

    






  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
