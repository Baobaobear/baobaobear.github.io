<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂谈 | Baobaobear</title>
    <link>/categories/%E6%9D%82%E8%B0%88/</link>
      <atom:link href="/categories/%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml" />
    <description>杂谈</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 05 Mar 2021 00:00:00 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>杂谈</title>
      <link>/categories/%E6%9D%82%E8%B0%88/</link>
    </image>
    
    <item>
      <title>大整数高精度计算——有趣的实现</title>
      <link>/post/20210305-bigint_fun/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210305-bigint_fun/</guid>
      <description>&lt;p&gt;这里收录一些有意思的实现，不过我都有进行改编以更方便使用，不过千万不要指望这性能有多高。收录的条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持四则运算，必须包含除法及求余&lt;/li&gt;
&lt;li&gt;支持字符串输入输出&lt;/li&gt;
&lt;li&gt;代码不长&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;small-biginteger-library-for-contest&#34;&gt;small biginteger library for contest&lt;/h2&gt;

&lt;p&gt;代码原作者Jane Alam Jan，你可以在Google上直接搜索&lt;code&gt;small_biginteger_library_for_contest.pdf&lt;/code&gt;并下载到原始说明文档及代码，这里提供一份代码，改动不多，增加了int的构造函数和其它不等号的重载，且增加输出到string而不直接输出终端，以便在其它场合使用更方便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Bigint {
    // representations and structures
    std::string a; // to store the digits
    int sign;      // sign = -1 for negative numbers, sign = 1 otherwise
    // constructors
    Bigint() {}                            // default constructor
    Bigint(std::string b) { (*this) = b; } // constructor for string
    Bigint(int v) {
        char buf[30];
        sprintf(buf, &amp;quot;%d&amp;quot;, v);
        (*this) = buf;
    }
    // some helpful methods
    int size() { return a.size(); } // returns number of digits
    Bigint inverseSign() {
        sign *= -1;
        return (*this);
    }
    Bigint normalize(int newSign) { // removes leading 0, fixes sign
        for (int i = a.size() - 1; i &amp;gt; 0 &amp;amp;&amp;amp; a[i] == &#39;0&#39;; i--)
            a.erase(a.begin() + i);
        sign = (a.size() == 1 &amp;amp;&amp;amp; a[0] == &#39;0&#39;) ? 1 : newSign;
        return (*this);
    }
    // assignment operator
    void operator=(std::string b) { // assigns a string to Bigint
        a = b[0] == &#39;-&#39; ? b.substr(1) : b;
        reverse(a.begin(), a.end());
        this-&amp;gt;normalize(b[0] == &#39;-&#39; ? -1 : 1);
    }
    // conditional operators
    bool operator&amp;lt;(const Bigint &amp;amp;b) const { // less than operator
        if (sign != b.sign) return sign &amp;lt; b.sign;
        if (a.size() != b.a.size()) return sign == 1 ? a.size() &amp;lt; b.a.size() : a.size() &amp;gt; b.a.size();
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            if (a[i] != b.a[i]) return sign == 1 ? a[i] &amp;lt; b.a[i] : a[i] &amp;gt; b.a[i];
        return false;
    }
    bool operator==(const Bigint &amp;amp;b) const { return a == b.a &amp;amp;&amp;amp; sign == b.sign; }
    // mathematical operators
    Bigint operator+(Bigint b) { // addition operator overloading
        if (sign != b.sign) return (*this) - b.inverseSign();
        Bigint c;
        for (int i = 0, carry = 0; i &amp;lt; a.size() || i &amp;lt; b.size() || carry; i++) {
            carry += (i &amp;lt; a.size() ? a[i] - 48 : 0) + (i &amp;lt; b.a.size() ? b.a[i] - 48 : 0);
            c.a += (carry % 10 + 48);
            carry /= 10;
        }
        return c.normalize(sign);
    }
    Bigint operator-(Bigint b) { // subtraction operator overloading
        if (sign != b.sign) return (*this) + b.inverseSign();
        int s = sign;
        sign = b.sign = 1;
        if ((*this) &amp;lt; b) return ((b - (*this)).inverseSign()).normalize(-s);
        Bigint c;
        for (int i = 0, borrow = 0; i &amp;lt; a.size(); i++) {
            borrow = a[i] - borrow - (i &amp;lt; b.size() ? b.a[i] : 48);
            c.a += borrow &amp;gt;= 0 ? borrow + 48 : borrow + 58;
            borrow = borrow &amp;gt;= 0 ? 0 : 1;
        }
        return c.normalize(s);
    }
    Bigint operator*(Bigint b) { // multiplication operator overloading
        Bigint c(&amp;quot;0&amp;quot;);
        for (int i = 0, k = a[i] - 48; i &amp;lt; a.size(); i++, k = a[i] - 48) {
            while (k--)
                c = c + b;                // ith digit is k, so, we add k times
            b.a.insert(b.a.begin(), &#39;0&#39;); // multiplied by 10
        }
        return c.normalize(sign * b.sign);
    }
    Bigint operator/(Bigint b) { // division operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;), d;
        for (int j = 0; j &amp;lt; a.size(); j++)
            d.a += &amp;quot;0&amp;quot;;
        int dSign = sign * b.sign;
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b, d.a[i]++;
        }
        return d.normalize(dSign);
    }
    Bigint operator%(Bigint b) { // modulo operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;);
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b;
        }
        return c.normalize(sign);
    }
    std::string to_str() const {
        std::string s;
        if (sign == -1) s += &#39;-&#39;;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            s += a[i];
        return s;
    }
    bool operator&amp;gt;(const Bigint &amp;amp;b) const { return b &amp;lt; *this; }
    bool operator&amp;lt;=(const Bigint &amp;amp;b) const { return !(b &amp;lt; *this); }
    bool operator&amp;gt;=(const Bigint &amp;amp;b) const { return !(*this &amp;lt; b); }
    bool operator!=(const Bigint &amp;amp;b) const { return !(*this == b); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现使用string来实现大整数，于是缺点就非常明显了，就是性能低下，非常低，求个300阶乘都要1.5秒。不过，这代码里有不少写法是牺牲性能换代码长度，有的思路确实也不错。在同样代码长度级别下，我实现的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger/blob/main/bigint_tiny.h&#34; target=&#34;_blank&#34;&gt;BigIntTiny&lt;/a&gt;有着好得多的性能。或者来直接看以下这份更短的实现。&lt;/p&gt;

&lt;h2 id=&#34;一份60行不到的大整数实现&#34;&gt;一份60行不到的大整数实现&lt;/h2&gt;

&lt;p&gt;改编自&lt;a href=&#34;https://wu-kan.cn/_posts/2019-01-26-%E9%AB%98%E7%B2%BE%E5%BA%A6/&#34; target=&#34;_blank&#34;&gt;wu-kan&lt;/a&gt;以及&lt;a href=&#34;https://zhuanlan.zhihu.com/p/72730434&#34; target=&#34;_blank&#34;&gt;hqztrue&lt;/a&gt;的基于bitset实现的定长大整数，支持10进制输入输出，四则运算及位运算均支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;string&amp;gt;

#define BINT_MAXSIZE 2048
typedef typename std::bitset&amp;lt;BINT_MAXSIZE&amp;gt; Bint;
bool operator&amp;lt;(const Bint &amp;amp;a, const Bint &amp;amp;b) {
    for (int i = a.size() - 1; i &amp;gt;= 0; --i)
        if (a[i] != b[i]) return a[i] &amp;lt; b[i];
    return false;
}
bool operator&amp;gt;(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b &amp;lt; a; }
bool operator&amp;lt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(b &amp;lt; a); }
bool operator&amp;gt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(a &amp;lt; b); }
Bint operator+(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b.any() ? (a ^ b) + ((a &amp;amp; b) &amp;lt;&amp;lt; 1) : a; }
Bint &amp;amp;operator+=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a + b; }
Bint operator-(const Bint &amp;amp;a) { return Bint(1) + ~a; }
Bint operator-(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b.any() ? (a ^ b) - ((~a &amp;amp; b) &amp;lt;&amp;lt; 1) : a; }
Bint &amp;amp;operator-=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a - b; }
Bint operator*(Bint a, Bint b) {
    Bint r(0);
    for (; b.any(); b &amp;gt;&amp;gt;= 1, a &amp;lt;&amp;lt;= 1) if (b[0]) r += a;
    return r;
}
Bint &amp;amp;operator*=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a * b; }
std::pair&amp;lt;Bint, Bint&amp;gt; divide(Bint a, const Bint &amp;amp;b) {
    Bint c = 0;
    int i = 0;
    while (b &amp;lt;&amp;lt; (i + 1) &amp;lt;= a) ++i;
    for (; i &amp;gt;= 0; --i)
        if (a &amp;gt;= (b &amp;lt;&amp;lt; i)) a -= b &amp;lt;&amp;lt; i, c.set(i, 1);
    return std::make_pair(c, a);
}
Bint operator/(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).first; }
Bint &amp;amp;operator/=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a / b; }
Bint operator%(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).second; }
Bint &amp;amp;operator%=(Bint &amp;amp;a, const Bint &amp;amp;b) { return a = a % b; }
Bint BintFromStr(const char *p) {
    Bint x = 0;
    int sign = 1;
    for (; *p == &#39;-&#39;; ++p) sign = -sign;
    for (; *p &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; *p &amp;lt;= &#39;9&#39;; ++p) x = (x &amp;lt;&amp;lt; 3) + (x &amp;lt;&amp;lt; 1) + (*p - &#39;0&#39;);
    return sign &amp;gt; 0 ? x : -x;
}
Bint BintFromInt(int i) {
    char buf[20];
    sprintf(buf, &amp;quot;%d&amp;quot;, i);
    return BintFromStr(buf);
}
std::string BintToStr(Bint x) {
    std::string out = x == 0 ? &amp;quot;0&amp;quot; : &amp;quot;&amp;quot;;
    std::vector&amp;lt;Bint&amp;gt; v;
    if (x[x.size() - 1]) out += &#39;-&#39;, x = -x;
    for (Bint y = 1; y &amp;lt;= x; y = (y &amp;lt;&amp;lt; 3) + (y &amp;lt;&amp;lt; 1)) v.push_back(y);
    for (int i = v.size() - 1; i &amp;gt;= 0; --i) {
        int t = 0;
        for (int l = 3; l &amp;gt;= 0; --l)
            if (x &amp;gt;= (v[i] &amp;lt;&amp;lt; l)) x -= v[i] &amp;lt;&amp;lt; l, t += 1 &amp;lt;&amp;lt; l;
        out += t + &#39;0&#39;;
    }
    return out;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现的代码就短到极致了，但性能同样也挺糟糕的，而且负数支持不佳（做除法会出错，需要自己转为正数做除法，或者可以自己写个类封装一下来解决这个问题），还有一个缺点是受bitset所限只能定长，不过在绝大部分情况下还能比前一份代码来得快不少，比如说求阶乘，长度设置为2048，求300的阶乘，这份代码只要0.01秒，前一份代码却要1.5秒，相差上百倍。要是改成求1000阶乘，设置长度为16384，计算时间为0.3秒（事实上这里面大部分时间花在了转出时转换到10进制，实际计算时间不到0.1秒），而前一份代码用时55秒。所以如果真要临时用用大整数，还是这个好，又短又不至于太慢。&lt;/p&gt;

&lt;h2 id=&#34;其它的github库实现&#34;&gt;其它的Github库实现&lt;/h2&gt;

&lt;p&gt;以下是我在Github找到的平均性能表现较好的一些小型实现，已经按平均性能进行排序（优先按1万位以内的乘法和除法运算性能进行排序&lt;del&gt;，才没有打广告&lt;/del&gt;）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;Baobaobear/MiniBigInteger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kedixa/klibcpp&#34; target=&#34;_blank&#34;&gt;kedixa/klibcpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ron4fun/BigIntegerCPP&#34; target=&#34;_blank&#34;&gt;ron4fun/BigIntegerCPP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square1001/bigint-library&#34; target=&#34;_blank&#34;&gt;square1001/bigint-library&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个只能在x64平台且只能用支持AT&amp;amp;T内联汇编编译器(如GCC/clang)的实现 &lt;a href=&#34;https://github.com/calebsander/bigint&#34; target=&#34;_blank&#34;&gt;calebsander/bigint&lt;/a&gt;，它的加减法和小规模乘法速度确实飞快，比前面列举到的都快，但受编译环境限制较大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>很头疼拼图</title>
      <link>/post/20210118-htt/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210118-htt/</guid>
      <description>&lt;p&gt;本拼图难度较高，是给程序解答专用的题目（手工解我觉得没多少可能，但不排除有运气极佳的人），是检验你的程序效率有多高用的。&lt;/p&gt;

&lt;p&gt;它的名字是很头疼拼图，因为放入的块有H和两种T形状，而HTT就是很头疼。一共有21个块，放入一个12x12的框里，具体形状如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/htt.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是12x12。全部21块放入即成功解出，每一块均可以任意平移、旋转、翻转。你需要确定本题有多少个本质不同的解及相应具体答案。答案就不在这公开了，祝玩得开心。&lt;/p&gt;

&lt;p&gt;其实还没完，以下还有一题加强版&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/1149.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;名字叫1149，取自每种形状的块数，全部共15块，都放入12x12的框内即可。同样的，你需要确定本题有多少个本质不同的解及相应具体答案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小恐龙拼图</title>
      <link>/post/20210101-dino/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210101-dino/</guid>
      <description>&lt;p&gt;本拼图难度较高，同时作为2021新年的起点！&lt;/p&gt;

&lt;p&gt;它的名字是小恐龙拼图，因为需要连同右边小恐龙形状的拼图块一起放入，一共有11个块，放入一个12x12的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/dino.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是12x12。全部11块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>101010拼图</title>
      <link>/post/20201231-101010/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201231-101010/</guid>
      <description>&lt;p&gt;前两个拼图最多算热个身，难度不高，真正有点挑战的是以下这个，作为2020的纪念&lt;/p&gt;

&lt;p&gt;它的名字是101010，因为需要把10个块放入一个10x10的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/101010.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是10x10。右边的块每一块都写了x2，表示有两块完全一样的形状，全部10块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10个问号拼图</title>
      <link>/post/20201214-10question/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201214-10question/</guid>
      <description>&lt;p&gt;刷题经常搞得自己一脸问号，就想到弄一个由问号组成的拼图，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/10question.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由10块一样的形似问号组合而成，所以我命名为&lt;code&gt;10个问号&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是10x10。要求把右边的“十”无重叠放入到10个问号里，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orz14拼图</title>
      <link>/post/20201123-orz14puzzle/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201123-orz14puzzle/</guid>
      <description>&lt;p&gt;为了表达对大佬的膜拜，特设计一款拼图，由14个近似Orz形状的小块组合而成，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/orz14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由14块一样的小块组合而成，所以我命名为&lt;code&gt;Orz14&lt;/code&gt;，同时也有Orz一直到4的含义。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是11x11。要求把右边的绿色小块也一并无重叠放入，这一块就代表大佬，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解迷建模</title>
      <link>/post/20201023-puzzle/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201023-puzzle/</guid>
      <description>&lt;p&gt;这次来聊点简单的，也许你偶尔有机会在地摊上看到有人摆了一堆解锁玩具，这回我们通过建模来解决当中属于迷宫类型的玩具。&lt;/p&gt;

&lt;h2 id=&#34;魔金-円&#34;&gt;魔金·円&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk - Solved.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一图是初始状态，第二图是解开后各自的形状。为了更能理解接下来我说的，最好当然是你手上有一个一样的。&lt;/p&gt;

&lt;p&gt;但是，事实上可以存在两种不同的初始状态，其路线也略不相同，以下会做说明。&lt;/p&gt;

&lt;h3 id=&#34;编码&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;稍微操作几下，我们就会发现，它的操作很简单，它的边缘有一上一下，在中间的孔也有一左一右，即边缘的宽度小于等于中间的孔时，就可穿过一格。我们把它如下图摆放(俯视图)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这两个disks都有一个特点，有一个孔特别长，这两个孔交错时为初始位置。我们把这个特殊的孔编号为0，然后这个孔中间一左一右大小不同，我们按小的为主方向，于是上图左边的disk从0号孔开始顺时针编码1到6，右边的disk从0号孔开始也是顺时针编码1到6。由于都是顺时针，我称它为同向的初始状态（还有一种是反向的）。&lt;/p&gt;

&lt;p&gt;再来看，左边的disk从0孔到1孔顺时针方向的边是粗的（如下图红色圈），但右边的disk从0孔到1孔顺时针方向的边是细的（如下图蓝色圈），这也决定这两个disk是不同的，在这规定顺时针方向下粗的是disk a，细的是disk b，且a总是放左边，b放右边，如图的交错方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;观察完毕后，为了方便写成代码，我们开始对disk a进行状态描述，如下图，对孔1为例子，取它的顺时针方向的边与它作为一组，按图上次序编码，窄的为0，宽的取1&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后按定义好的方向，进行编码，得到如下的编码表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int disk_shape[2][7][4] = {
    {
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 0},
        {1, 0, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
    },
    {
        {1, 0, 0, 1},
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 1, 0},
    },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了编码，接下来的事情就是判断哪些位置能做操作了。对于每一个位置，我们都有对&lt;code&gt;disk a&lt;/code&gt;顺时针和逆时针，对&lt;code&gt;disk b&lt;/code&gt;顺时针和逆时针共4种操作，那直接写成代码并打印，看看哪些可以即可。&lt;/p&gt;

&lt;h3 id=&#34;具体代码&#34;&gt;具体代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int st_map[7][7][4];

void genmap()
{
    int disk_shape[2][7][4] = {
        {
            {1, 0, 1, 0},
            {0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 1},
        },
        {
            {1, 0, 0, 1},
            {0, 1, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 0, 0},
            {0, 0, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 1, 0},
        },
    };
    for (int dl = 0; dl &amp;lt; 7; ++dl)
    {
        for (int dr = 0; dr &amp;lt; 7; ++dr)
        {
            char s[5] = &amp;quot;    &amp;quot;;
            // 反向
            /*
            if (disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][2])
               s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][2])
               s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            // 同向
            //*
            if (disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][3])
                s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][3])
                s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            printf(&amp;quot;%4s,&amp;quot;, s);
        }
        puts(&amp;quot;&amp;quot;);
    }
}

int main()
{
    genmap();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是UD对应&lt;code&gt;disk a&lt;/code&gt;的操作，LR对应&lt;code&gt;disk b&lt;/code&gt;的操作&lt;/p&gt;

&lt;h3 id=&#34;结果&#34;&gt;结果&lt;/h3&gt;

&lt;p&gt;我把运行结果导入到表格并对可移动的路径进行染色，结果如下（黄色的是起点和终点状态，深绿色是最短路径）&lt;/p&gt;

&lt;h4 id=&#34;同向&#34;&gt;同向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;反向&#34;&gt;反向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来的事情就简单了，路径明显不唯一，只要按定义操作，怎么走都可以，两种方向均最短15步。&lt;/p&gt;

&lt;h2 id=&#34;魔金-磁&#34;&gt;魔金·磁&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它也是个迷宫，它有两个小环，开口处有一边有个小齿，这导致了这两个小环的路线是不一样的。&lt;/p&gt;

&lt;h3 id=&#34;编码-1&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;首先，小环横跨两个区域，那么我们对区域进行编号，且规定图上可见的面为正面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后，两个小环规定，齿在正面时，开口所占区域为十位，另一区域为个位，于是，初始状态分别是09和90（十位的0不能省略）&lt;/p&gt;

&lt;p&gt;但是这个由于比较复杂，编码的时间可能比手动列出状态还麻烦，所以我直接手动把所有的状态做成表格&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet_s.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表格中前两行，表示该状态可以跳转到哪些状态，第三行表示该状态距离解出还需要的步数。每一格的红色数字表示向此数字走能最快到达出口。蓝色表示向还原的方向，没有蓝色时按红色数字的方向。&lt;/p&gt;

&lt;p&gt;特殊情况是30这个状态，即第三行第0列，它移动到20或36，分别能移动到两种不同的初始状态。&lt;/p&gt;

&lt;p&gt;蓝色和橙色格子表示两条不同状态的路线，而绿色表示这两条路线的公共部分。&lt;/p&gt;

&lt;p&gt;但是，记忆这个表太难，且操作起来不是太舒服，唯一好处就是任意情况都能处理。为了快速解开或复原，我加了一个方便操作的数字串：&lt;/p&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;p&gt;90：6-3-52-0-3- 25-2-4-587-0-0&lt;br /&gt;
09：-8-7-5-8-6-523-0 25-2-4-587-0-0&lt;/p&gt;

&lt;p&gt;还原：&lt;/p&gt;

&lt;p&gt;90：7-4-852-5-3-20 -2-3-56-0-9&lt;br /&gt;
09：7-4-852-5-3-20 6-258-5-7-8-0-9&lt;/p&gt;

&lt;p&gt;规定初始状态是小环开口小齿在正面，减号表示小环自身转90度，数字表示移动小环其中一则到此区域。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;这种方法只能对比较规范的puzzle进行建模，我看到网上似乎没有针对这两而做的解法视频，所以我就做了一个建模版本，把路线图形化，这样比起单纯一个正解视频，你可以知道任意情况下怎么解，这个是优点。不过缺点是你得花点时间去理解它是怎么编码的。好久没更新了，所以来写点特别的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mingw 的 Bug</title>
      <link>/post/20191006-mingw-bug/</link>
      <pubDate>Sun, 06 Oct 2019 13:04:08 +0800</pubDate>
      <guid>/post/20191006-mingw-bug/</guid>
      <description>&lt;p&gt;这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。&lt;/p&gt;

&lt;p&gt;一开始我使用&lt;code&gt;std::random_shuffle&lt;/code&gt;打乱数组并用&lt;code&gt;std::sort&lt;/code&gt;排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是&lt;code&gt;std::sort&lt;/code&gt;对这种方式打乱的数据排序有点问题导致变慢。&lt;/p&gt;

&lt;p&gt;后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，&lt;code&gt;std::sort&lt;/code&gt;的时间是完全正常的，非得&lt;code&gt;std::random_shuffle&lt;/code&gt;才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向&lt;code&gt;std::random_shuffle&lt;/code&gt;，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是&lt;code&gt;arr[i] = i&lt;/code&gt;，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在&lt;a href=&#34;https://en.cppreference.com/w/cpp/algorithm/random_shuffle&#34; target=&#34;_blank&#34;&gt;cppreference&lt;/a&gt;下源代码长下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; class RandomIt &amp;gt;
void random_shuffle( RandomIt first, RandomIt last )
{
    typename std::iterator_traits&amp;lt;RandomIt&amp;gt;::difference_type i, n;
    n = last - first;
    for (i = n-1; i &amp;gt; 0; --i) {
        using std::swap;
        swap(first[i], first[std::rand() % (i+1)]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码我看着就不对，这个是生成不了我的执行结果的，于是又找到了下面这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator&amp;gt;
inline void random_shuffle(RandomAccessIterator first,
                           RandomAccessIterator last) {
  __random_shuffle(first, last, distance_type(first));
}
 
 
template &amp;lt;class RandomAccessIterator, class RandomNumberGenerator&amp;gt;
void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                    RandomNumberGenerator&amp;amp; rand) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i)
    iter_swap(i, first + rand((i - first) + 1));
}
 
 
template &amp;lt;class RandomAccessIterator, class Distance&amp;gt;
void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                      Distance*) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i) 
#ifdef __STL_NO_DRAND48
    iter_swap(i, first + Distance(rand() % ((i - first) + 1)));
#else
  iter_swap(i, first + Distance(lrand48() % ((i - first) + 1)));
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了这个代码，我瞬间明白这到底是怎么回事了，你能从中发现些什么吗？&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我发现的是，前面的代码用的是rand，而之前我发现的，是数组里前32768个数都特别大，我的直觉是这个rand函数最大值就是32767从而导致以上问题，结果一查，还真的只有mingw的rand函数的最大值这么小，也就是说如果你希望代码跨平台，使用&lt;code&gt;std::random_shuffle&lt;/code&gt;要慎重，当然最好是减少依赖。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>博客第一文，附hugo表格的坑</title>
      <link>/post/20191005-first-post/</link>
      <pubDate>Sat, 05 Oct 2019 23:12:10 +0800</pubDate>
      <guid>/post/20191005-first-post/</guid>
      <description>&lt;p&gt;第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把&lt;code&gt;\n&lt;/code&gt;自动换成&lt;code&gt;\r\n&lt;/code&gt;从而导致主题应用失败，服了。&lt;/p&gt;

&lt;p&gt;另一个坑就是hugo的表格，你不能像以下这么写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a|b|c
-|-|-
1|2|3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a  | b | c
---|---|---
1  | 2 | 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果就是这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;区别是什么呢？在表格的第二行是&lt;code&gt;---|---|---&lt;/code&gt;，这一行是用来描述对齐方式的，不过hugo的引擎要求每列至少3个字符，所以刚好3个字符时只能是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
:--
--:
:-:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中四选一，任何一个只剩下两个字符就不算是表格。&lt;/p&gt;

&lt;p&gt;本博客计划是发布我的研究成果，当然主要是算法方面，而且主要是网上不会轻易搜索到的东西。&lt;/p&gt;

&lt;p&gt;更多的东西可以关注我的 Github &lt;a href=&#34;https://github.com/Baobaobear&#34; target=&#34;_blank&#34;&gt;账号&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _CRT_SECURE_NO_WARNINGS
#include &amp;lt;stdio.h&amp;gt;
 
int g_eof;
int get_lv(char c) {
	return !(c == &#39;+&#39; || c == &#39;-&#39;);
}
 
double get_val(double v[], char op) {
	if (op == &#39;+&#39;) return v[0] + v[1];
	if (op == &#39;-&#39;) return v[0] - v[1];
	if (op == &#39;*&#39;) return v[0] * v[1];
	if (op == &#39;/&#39;) return v[0] / v[1];
	return v[0];
}
 
double calc(char* op, int level, double val, char o, int i) {
	char c[2] = { o };
	double v[2] = { val };
	if ((g_eof = scanf(&amp;quot;%lf&amp;quot;, &amp;amp;v[i])) != EOF)
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	if (c[i] == &#39;(&#39;) {
		v[i] = calc(&amp;amp;c[i], 0, 0, 0, 0);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	}
	if (i &amp;gt; 0) {
		if (!(c[i] == &#39;\n&#39; || c[i] == &#39;)&#39;
			|| get_lv(c[0]) &amp;gt;= get_lv(c[1])))
			v[i] = calc(&amp;amp;c[1], get_lv(c[1]), v[1], c[1], get_lv(c[1]) &amp;gt; 0);
		v[0] = get_val(v, c[0]);
		c[0] = c[1];
	}
	if (c[0] == &#39;\n&#39; || c[0] == &#39;)&#39; || get_lv(c[0]) &amp;lt; level) {
		*op = c[0];
		return v[0];
	}
	return calc(op, level, v[0], c[0], 1);
}
 
int main(void) {
	char op;
	while (g_eof != EOF)
		printf(&amp;quot;= %.15g\n&amp;quot;, calc(&amp;amp;op, 0, 0, &#39;\n&#39;, 0));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
