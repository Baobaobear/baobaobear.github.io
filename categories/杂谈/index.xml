<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂谈 | Baobaobear</title>
    <link>/categories/%E6%9D%82%E8%B0%88/</link>
      <atom:link href="/categories/%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml" />
    <description>杂谈</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 01 Jan 2021 00:00:00 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>杂谈</title>
      <link>/categories/%E6%9D%82%E8%B0%88/</link>
    </image>
    
    <item>
      <title>小恐龙拼图</title>
      <link>/post/20210101-dino/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210101-dino/</guid>
      <description>&lt;p&gt;本拼图难度较高，同时作为2021新年的起点！&lt;/p&gt;

&lt;p&gt;它的名字是小恐龙拼图，因为需要连同右边小恐龙形状的拼图块一起放入，一共有11个块，放入一个12x12的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/dino.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是12x12。全部11块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>101010拼图</title>
      <link>/post/20201231-101010/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201231-101010/</guid>
      <description>&lt;p&gt;前两个拼图最多算热个身，难度不高，真正有点挑战的是以下这个，作为2020的纪念&lt;/p&gt;

&lt;p&gt;它的名字是101010，因为需要把10个块放入一个10x10的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/101010.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是10x10。右边的块每一块都写了x2，表示有两块完全一样的形状，全部10块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10个问号拼图</title>
      <link>/post/20201214-10question/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201214-10question/</guid>
      <description>&lt;p&gt;刷题经常搞得自己一脸问号，就想到弄一个由问号组成的拼图，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/10question.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由10块一样的形似问号组合而成，所以我命名为&lt;code&gt;10个问号&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是10x10。要求把右边的“十”无重叠放入到10个问号里，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orz14拼图</title>
      <link>/post/20201123-orz14puzzle/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201123-orz14puzzle/</guid>
      <description>&lt;p&gt;为了表达对大佬的膜拜，特设计一款拼图，由14个近似Orz形状的小块组合而成，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/orz14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由14块一样的小块组合而成，所以我命名为&lt;code&gt;Orz14&lt;/code&gt;，同时也有Orz一直到4的含义。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是11x11。要求把右边的绿色小块也一并无重叠放入，这一块就代表大佬，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解迷建模</title>
      <link>/post/20201023-puzzle/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201023-puzzle/</guid>
      <description>&lt;p&gt;这次来聊点简单的，也许你偶尔有机会在地摊上看到有人摆了一堆解锁玩具，这回我们通过建模来解决当中属于迷宫类型的玩具。&lt;/p&gt;

&lt;h2 id=&#34;魔金-円&#34;&gt;魔金·円&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk - Solved.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一图是初始状态，第二图是解开后各自的形状。为了更能理解接下来我说的，最好当然是你手上有一个一样的。&lt;/p&gt;

&lt;p&gt;但是，事实上可以存在两种不同的初始状态，其路线也略不相同，以下会做说明。&lt;/p&gt;

&lt;h3 id=&#34;编码&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;稍微操作几下，我们就会发现，它的操作很简单，它的边缘有一上一下，在中间的孔也有一左一右，即边缘的宽度小于等于中间的孔时，就可穿过一格。我们把它如下图摆放(俯视图)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这两个disks都有一个特点，有一个孔特别长，这两个孔交错时为初始位置。我们把这个特殊的孔编号为0，然后这个孔中间一左一右大小不同，我们按小的为主方向，于是上图左边的disk从0号孔开始顺时针编码1到6，右边的disk从0号孔开始也是顺时针编码1到6。由于都是顺时针，我称它为同向的初始状态（还有一种是反向的）。&lt;/p&gt;

&lt;p&gt;再来看，左边的disk从0孔到1孔顺时针方向的边是粗的（如下图红色圈），但右边的disk从0孔到1孔顺时针方向的边是细的（如下图蓝色圈），这也决定这两个disk是不同的，在这规定顺时针方向下粗的是disk a，细的是disk b，且a总是放左边，b放右边，如图的交错方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;观察完毕后，为了方便写成代码，我们开始对disk a进行状态描述，如下图，对孔1为例子，取它的顺时针方向的边与它作为一组，按图上次序编码，窄的为0，宽的取1&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后按定义好的方向，进行编码，得到如下的编码表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int disk_shape[2][7][4] = {
    {
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 0},
        {1, 0, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
    },
    {
        {1, 0, 0, 1},
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 1, 0},
    },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了编码，接下来的事情就是判断哪些位置能做操作了。对于每一个位置，我们都有对&lt;code&gt;disk a&lt;/code&gt;顺时针和逆时针，对&lt;code&gt;disk b&lt;/code&gt;顺时针和逆时针共4种操作，那直接写成代码并打印，看看哪些可以即可。&lt;/p&gt;

&lt;h3 id=&#34;具体代码&#34;&gt;具体代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int st_map[7][7][4];

void genmap()
{
    int disk_shape[2][7][4] = {
        {
            {1, 0, 1, 0},
            {0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 1},
        },
        {
            {1, 0, 0, 1},
            {0, 1, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 0, 0},
            {0, 0, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 1, 0},
        },
    };
    for (int dl = 0; dl &amp;lt; 7; ++dl)
    {
        for (int dr = 0; dr &amp;lt; 7; ++dr)
        {
            char s[5] = &amp;quot;    &amp;quot;;
            // 反向
            /*
            if (disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][2])
               s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][2])
               s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            // 同向
            //*
            if (disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][3])
                s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][3])
                s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            printf(&amp;quot;%4s,&amp;quot;, s);
        }
        puts(&amp;quot;&amp;quot;);
    }
}

int main()
{
    genmap();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是UD对应&lt;code&gt;disk a&lt;/code&gt;的操作，LR对应&lt;code&gt;disk b&lt;/code&gt;的操作&lt;/p&gt;

&lt;h3 id=&#34;结果&#34;&gt;结果&lt;/h3&gt;

&lt;p&gt;我把运行结果导入到表格并对可移动的路径进行染色，结果如下（黄色的是起点和终点状态，深绿色是最短路径）&lt;/p&gt;

&lt;h4 id=&#34;同向&#34;&gt;同向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;反向&#34;&gt;反向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来的事情就简单了，路径明显不唯一，只要按定义操作，怎么走都可以，两种方向均最短15步。&lt;/p&gt;

&lt;h2 id=&#34;魔金-磁&#34;&gt;魔金·磁&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它也是个迷宫，它有两个小环，开口处有一边有个小齿，这导致了这两个小环的路线是不一样的。&lt;/p&gt;

&lt;h3 id=&#34;编码-1&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;首先，小环横跨两个区域，那么我们对区域进行编号，且规定图上可见的面为正面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后，两个小环规定，齿在正面时，开口所占区域为十位，另一区域为个位，于是，初始状态分别是09和90（十位的0不能省略）&lt;/p&gt;

&lt;p&gt;但是这个由于比较复杂，编码的时间可能比手动列出状态还麻烦，所以我直接手动把所有的状态做成表格&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet_s.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表格中前两行，表示该状态可以跳转到哪些状态，第三行表示该状态距离解出还需要的步数。每一格的红色数字表示向此数字走能最快到达出口。蓝色表示向还原的方向，没有蓝色时按红色数字的方向。&lt;/p&gt;

&lt;p&gt;特殊情况是30这个状态，即第三行第0列，它移动到20或36，分别能移动到两种不同的初始状态。&lt;/p&gt;

&lt;p&gt;蓝色和橙色格子表示两条不同状态的路线，而绿色表示这两条路线的公共部分。&lt;/p&gt;

&lt;p&gt;但是，记忆这个表太难，且操作起来不是太舒服，唯一好处就是任意情况都能处理。为了快速解开或复原，我加了一个方便操作的数字串：&lt;/p&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;p&gt;90：6-3-52-0-3- 25-2-4-587-0-0&lt;br /&gt;
09：-8-7-5-8-6-523-0 25-2-4-587-0-0&lt;/p&gt;

&lt;p&gt;还原：&lt;/p&gt;

&lt;p&gt;90：7-4-852-5-3-20 -2-3-56-0-9&lt;br /&gt;
09：7-4-852-5-3-20 6-258-5-7-8-0-9&lt;/p&gt;

&lt;p&gt;规定初始状态是小环开口小齿在正面，减号表示小环自身转90度，数字表示移动小环其中一则到此区域。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;这种方法只能对比较规范的puzzle进行建模，我看到网上似乎没有针对这两而做的解法视频，所以我就做了一个建模版本，把路线图形化，这样比起单纯一个正解视频，你可以知道任意情况下怎么解，这个是优点。不过缺点是你得花点时间去理解它是怎么编码的。好久没更新了，所以来写点特别的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mingw 的 Bug</title>
      <link>/post/20191006-mingw-bug/</link>
      <pubDate>Sun, 06 Oct 2019 13:04:08 +0800</pubDate>
      <guid>/post/20191006-mingw-bug/</guid>
      <description>&lt;p&gt;这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。&lt;/p&gt;

&lt;p&gt;一开始我使用&lt;code&gt;std::random_shuffle&lt;/code&gt;打乱数组并用&lt;code&gt;std::sort&lt;/code&gt;排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是&lt;code&gt;std::sort&lt;/code&gt;对这种方式打乱的数据排序有点问题导致变慢。&lt;/p&gt;

&lt;p&gt;后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，&lt;code&gt;std::sort&lt;/code&gt;的时间是完全正常的，非得&lt;code&gt;std::random_shuffle&lt;/code&gt;才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向&lt;code&gt;std::random_shuffle&lt;/code&gt;，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是&lt;code&gt;arr[i] = i&lt;/code&gt;，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在&lt;a href=&#34;https://en.cppreference.com/w/cpp/algorithm/random_shuffle&#34; target=&#34;_blank&#34;&gt;cppreference&lt;/a&gt;下源代码长下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; class RandomIt &amp;gt;
void random_shuffle( RandomIt first, RandomIt last )
{
    typename std::iterator_traits&amp;lt;RandomIt&amp;gt;::difference_type i, n;
    n = last - first;
    for (i = n-1; i &amp;gt; 0; --i) {
        using std::swap;
        swap(first[i], first[std::rand() % (i+1)]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码我看着就不对，这个是生成不了我的执行结果的，于是又找到了下面这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator&amp;gt;
inline void random_shuffle(RandomAccessIterator first,
                           RandomAccessIterator last) {
  __random_shuffle(first, last, distance_type(first));
}
 
 
template &amp;lt;class RandomAccessIterator, class RandomNumberGenerator&amp;gt;
void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                    RandomNumberGenerator&amp;amp; rand) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i)
    iter_swap(i, first + rand((i - first) + 1));
}
 
 
template &amp;lt;class RandomAccessIterator, class Distance&amp;gt;
void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                      Distance*) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i) 
#ifdef __STL_NO_DRAND48
    iter_swap(i, first + Distance(rand() % ((i - first) + 1)));
#else
  iter_swap(i, first + Distance(lrand48() % ((i - first) + 1)));
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了这个代码，我瞬间明白这到底是怎么回事了，你能从中发现些什么吗？&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我发现的是，前面的代码用的是rand，而之前我发现的，是数组里前32768个数都特别大，我的直觉是这个rand函数最大值就是32767从而导致以上问题，结果一查，还真的只有mingw的rand函数的最大值这么小，也就是说如果你希望代码跨平台，使用&lt;code&gt;std::random_shuffle&lt;/code&gt;要慎重，当然最好是减少依赖。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>博客第一文，附hugo表格的坑</title>
      <link>/post/20191005-first-post/</link>
      <pubDate>Sat, 05 Oct 2019 23:12:10 +0800</pubDate>
      <guid>/post/20191005-first-post/</guid>
      <description>&lt;p&gt;第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把&lt;code&gt;\n&lt;/code&gt;自动换成&lt;code&gt;\r\n&lt;/code&gt;从而导致主题应用失败，服了。&lt;/p&gt;

&lt;p&gt;另一个坑就是hugo的表格，你不能像以下这么写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a|b|c
-|-|-
1|2|3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a  | b | c
---|---|---
1  | 2 | 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果就是这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;区别是什么呢？在表格的第二行是&lt;code&gt;---|---|---&lt;/code&gt;，这一行是用来描述对齐方式的，不过hugo的引擎要求每列至少3个字符，所以刚好3个字符时只能是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
:--
--:
:-:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中四选一，任何一个只剩下两个字符就不算是表格。&lt;/p&gt;

&lt;p&gt;本博客计划是发布我的研究成果，当然主要是算法方面，而且主要是网上不会轻易搜索到的东西。&lt;/p&gt;

&lt;p&gt;更多的东西可以关注我的 Github &lt;a href=&#34;https://github.com/Baobaobear&#34; target=&#34;_blank&#34;&gt;账号&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _CRT_SECURE_NO_WARNINGS
#include &amp;lt;stdio.h&amp;gt;
 
int g_eof;
int get_lv(char c) {
	return !(c == &#39;+&#39; || c == &#39;-&#39;);
}
 
double get_val(double v[], char op) {
	if (op == &#39;+&#39;) return v[0] + v[1];
	if (op == &#39;-&#39;) return v[0] - v[1];
	if (op == &#39;*&#39;) return v[0] * v[1];
	if (op == &#39;/&#39;) return v[0] / v[1];
	return v[0];
}
 
double calc(char* op, int level, double val, char o, int i) {
	char c[2] = { o };
	double v[2] = { val };
	if ((g_eof = scanf(&amp;quot;%lf&amp;quot;, &amp;amp;v[i])) != EOF)
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	if (c[i] == &#39;(&#39;) {
		v[i] = calc(&amp;amp;c[i], 0, 0, 0, 0);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	}
	if (i &amp;gt; 0) {
		if (!(c[i] == &#39;\n&#39; || c[i] == &#39;)&#39;
			|| get_lv(c[0]) &amp;gt;= get_lv(c[1])))
			v[i] = calc(&amp;amp;c[1], get_lv(c[1]), v[1], c[1], get_lv(c[1]) &amp;gt; 0);
		v[0] = get_val(v, c[0]);
		c[0] = c[1];
	}
	if (c[0] == &#39;\n&#39; || c[0] == &#39;)&#39; || get_lv(c[0]) &amp;lt; level) {
		*op = c[0];
		return v[0];
	}
	return calc(op, level, v[0], c[0], 1);
}
 
int main(void) {
	char op;
	while (g_eof != EOF)
		printf(&amp;quot;= %.15g\n&amp;quot;, calc(&amp;amp;op, 0, 0, &#39;\n&#39;, 0));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
