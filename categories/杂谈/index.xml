<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂谈 | Baobaobear</title>
    <link>/categories/%E6%9D%82%E8%B0%88/</link>
      <atom:link href="/categories/%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml" />
    <description>杂谈</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 15 Dec 2021 00:00:00 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>杂谈</title>
      <link>/categories/%E6%9D%82%E8%B0%88/</link>
    </image>
    
    <item>
      <title>折腾NAND</title>
      <link>/post/20211220-ssd/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0800</pubDate>
      <guid>/post/20211220-ssd/</guid>
      <description>

&lt;p&gt;近期在折腾SSD、SD、U盘，折腾差不多来写个总结，坑不少。本文部分内容会随着时间而变化，于2021年12月编写。&lt;/p&gt;

&lt;h2 id=&#34;常见nand硬件&#34;&gt;常见NAND硬件&lt;/h2&gt;

&lt;p&gt;用于储存的基于NAND的硬件，有SD卡、MicroSD卡，U盘，移动固态硬盘，固态硬盘，通常来说，SD卡这类体积小的速度最慢，U盘次之，再就是移动固态硬盘，最快是固态硬盘。之所以说通常，因为还要看接口和协议速度。&lt;/p&gt;

&lt;h2 id=&#34;颗粒品质-原片-白片-黑片&#34;&gt;颗粒品质，原片、白片、黑片&lt;/h2&gt;

&lt;p&gt;储存颗粒按品质划分可以分为三大类，原片、白片、黑片。原片就是品质最好的，原厂最严格标准下的产品，白片就是从晶圆上不及格的里面，把还相对较好的挑选出来，黑片就是白片也不如，在剩下的挑选还能用的，同时把坏区进行屏蔽后造出来的颗粒，某宝上特别便宜的U盘肯定是黑片，还有像MP3，玩具等，通常都是用的黑片。黑片寿命说不准，快的一个星期，慢的2年，看运气。&lt;/p&gt;

&lt;h2 id=&#34;颗粒类型-slc-mlc-tlc-qlc-3d-nand&#34;&gt;颗粒类型，SLC、MLC、TLC、QLC、3D NAND&lt;/h2&gt;

&lt;p&gt;SLC表示，一个存储单元，只存0和1，即1bit，MLC保存00、01、10、11，即2bits，同理，TLC可以保存3bits，QLC保存4bits。SLC最贵，速度最快，寿命最长，可达10W次擦除（原片颗粒的情况下，不算白片黑片，下同）。MLC次之，约3000到5000次擦除。TLC再次之，约1000次擦除。QLC速度最慢，寿命最短，约800次擦除。另外，3D NAND可以大幅度提升寿命，3D TLC可达3000到5000次擦除，3D QLC可达1000到3000次擦除。&lt;/p&gt;

&lt;h2 id=&#34;颗粒的读取-写入-擦除&#34;&gt;颗粒的读取、写入、擦除&lt;/h2&gt;

&lt;p&gt;一片NAND划分为很多个Die，Die是执行指令的最小单位。每个Die分为多个Plane，每个Plane分为多个Block，Block是擦除的最小单位，每个Block分为很多Page，读取时，以Page为单位，一次性读入整个Page的内容，如果一个Page大小有8k，那就是一次性读入8k的数据。而写入有点特殊，在一个Block里，只能按顺序写入，每次写入的单位为Page，不能跳着写，也不能回头写。擦除时，每次只能把整个Block擦除，然后再按顺序写入。&lt;/p&gt;

&lt;h2 id=&#34;主控&#34;&gt;主控&lt;/h2&gt;

&lt;p&gt;主控对SSD的寿命和速度处于非常主要的地位，同时也是NAND里面最容易挂掉的模块，它工作时发热很厉害，连续长时间下载写入或磁盘测速之类的可能会让主控过热烧毁。NAND是原片，多数情况下主控比NAND本身还要早挂掉。&lt;/p&gt;

&lt;p&gt;主控还负责FTL层，即从逻辑地址映射到物理地址的映射。FTL通常包含GC算法、Wear leveling（WL）磨损平衡算法。&lt;/p&gt;

&lt;p&gt;另外还有一个关键点，就是看主控支不支持TRIM指令（在NVME上不叫这个名字，但为了统一通常还是这么称呼），在支持TRIM指令的主控上，配合操作系统，能大大优化GC。绝大多数的MicroSD卡和SD卡都不支持TRIM，大部分低端U盘也不支持，少数移动SSD不支持。不支持TRIM的后果，是当写入量累计达到它的容量时，因为主控并不知道还有哪些地方可以写入，于是只好原地写入，磨损平衡就不存在了。所以，这种不支持TRIM指令的，通常都没有做磨损平衡，会把它当普通硬盘一样写入。&lt;/p&gt;

&lt;p&gt;查看硬件支不支持TRIM，在Windows上有很多方式，最简单的方法，插入U盘或SD卡后，右键属性，在工具页面有个优化按钮，点进去就能看到当前所有驱动器的媒体类型，识别为固态硬盘的，就是支持TRIM，如果只是显示硬盘驱动器的，就是不支持TRIM。或者还可以用DiskGenius，对驱动器右键，看有没有“TRIM优化”这一项。&lt;/p&gt;

&lt;p&gt;也就是说，对于大多数SD卡，如果要寿命长，那么最好是老实地放相机之类的使用，就每次存资料放满了，格式化再存，不要只存一点点数据就删除了再存。&lt;/p&gt;

&lt;p&gt;当然并不是说不支持TRIM就一定没有磨损平衡，比如说，你的SD卡使用了exfat格式，SD卡主控能认出来，自己找到没有使用的地方进行GC的话，那确实不需要支持TRIM就可以达到相似的效果。如果SD卡厂商宣传上写了支持的文件系统，那很可能就是这个类型。&lt;/p&gt;

&lt;p&gt;对于支持GC和WL的，存在写入放大的问题。比如说，要写入一个10K大小的数据，需要占用2个page，但已经没有一个block可以直接写入2个Page，这时候就需要做一次GC，把2个各有一个空余page的block里有用的数据读出，再重新写入，这样再把原本要写入的数据写入到2个空出来的page里面。于是，原本写入2个page大小的数据，结果是写入了2个block，考虑到1个block里面假设有128个page的话，那就是放大写入128倍。但是，对于不支持GC和WL的，每满一次之后每次写入都在写入放大，每次写入都是把整个block读出，然后和要写入的数据合并，再整个写入。不论你写入的数据量是1字节还是10k，本质上都写入了一个block，这就是掉速原因之一。而且这种掉速无法通过格式化恢复。&lt;/p&gt;

&lt;p&gt;好的主控还能对过早损坏的块做屏蔽处理，比如说通常SSD标注为500G而不是512G（但SD卡会标注为512G），那一点空间一来是保存FTL的LBA/PBA表，二来是减少写入放大的次数，三是做坏块的替换品。而对于有屏蔽坏块能力的主控，即使用白片用户也很难感知（等到你能感知到的时候已经过了保修），所以SSD里用白片那是一大片，最简单可以用价格看出来，比如说，三星的SSD差不多0.9元/G，而还有西数之类的，有0.6元/G的，大概率是白片。&lt;/p&gt;

&lt;p&gt;另外，还有一个冷数据的问题，通常你保存的数据里，有80%是存了就长期不会改动的，这些就称之为冷数据。好的主控还应该能对冷数据定期进行移动，以避免剩余空间较少时，反复写入的都是相同的位置，导致过早擦除过量。所以好的主控对寿命的影响起到关键因素。&lt;/p&gt;

&lt;h2 id=&#34;tbw&#34;&gt;TBW&lt;/h2&gt;

&lt;p&gt;这是个单位，比如300TBW是指累计写入300TB。在SSD产品上，写入量超过这个数量就不保修，这个数值并不代表其寿命，但可以作为其寿命的参考值。&lt;/p&gt;

&lt;h2 id=&#34;wintogo&#34;&gt;Wintogo&lt;/h2&gt;

&lt;p&gt;所谓Wintogo，就是把Windows系统安装在移动设备上，这样要用自己安装的环境配置，直接插个U盘就可以了。不过这个对移动设备有不低的要求，有多不低呢？比如说Sandisk全线U盘没有一个能跑Wintogo，因为不支持TRIM，会导致用着用着系统很卡很慢，而且它的移动硬盘也很诡异的不支持TRIM，很多人反映会越用越慢。反过来，如果你想买优质U盘，搜索Wintogo的U盘即可，而且这种盘比同价位的Sandisk要快得多，读400M写300M是标配，性价比甩开几条大街。&lt;/p&gt;

&lt;p&gt;而使用硬盘盒+SSD来做大号U盘也是没有问题的，主要要注意的是硬盘盒，如果你用NVME M.2的SSD，而且你没有红色的USB3.2 Gen2接口的话，那避免使用高端硬盘盒，找那些支持Gen1就可以的硬盘盒，以避免供电不足导致掉盘。当然这样就会导致速度限制在400M到500M，略微比U盘快一点点的程度吧。或者，你如果有USB typec口，就直接用这种口的硬盘盒，就没有供电上的问题。相比较厂商卖的移动硬盘比呢？个人觉得自己配的性价比更高，700块不到可以搞到一块1T的SSD+盒子，比起Sandisk不但性能更高，还更便宜，还能上Wintogo。&lt;/p&gt;

&lt;p&gt;不过上WTG要注意的是安装最好选择离线，不然安装好后它会马上帮你更新驱动，在更新USB驱动时会可能会导致USB临时掉线，但同时你的系统盘就是USB，那后果就是突然死机，如果死机那一时刻还有别的东西正在更新（比如万恶的Windows更新），那就可能直接导致系统挂掉无法修复。可以先离线安装好并重启，再进行网络连接，避免系统在同时更新多个，外加一点运气，死机重启后就能用的话，就恭喜了。另外，WTG最好关闭休眠功能，不然有的机器唤醒时USB还没及时连上，又得死机。&lt;/p&gt;

&lt;h2 id=&#34;缓外&#34;&gt;缓外&lt;/h2&gt;

&lt;p&gt;所谓缓外，通常指写入超过缓存的量的时候的写入速度。现在的SSD对于使用TLC或QLC的，最大问题就是速度慢，通常是使用SLC作为缓存，有的是使用独立的SLC，有的是把TLC直接模拟为SLC。在缓存内的时候速度很好看，几百M甚至上G，而缓外才真正看出这个盘的实际水平。&lt;/p&gt;

&lt;h2 id=&#34;选购建议&#34;&gt;选购建议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SD卡（含MicroSD）：一定要网购，绝对不要在街上买（90%是假货而且比正品更贵），然后找那些声称终身质保的产品（单价超过1.5元/G），然后使劲用就好了。比如某迪最高端的红黑卡。&lt;/li&gt;
&lt;li&gt;U盘：一定要网购，找Wintogo的U盘，推荐Chipfancier。不建议买大厂的，贵且慢。&lt;/li&gt;
&lt;li&gt;移动硬盘：如果钱不是问题，那直接上三星，其它情况的话看你的需求来选择，500M到800M的速度就够用的话用硬盘盒+SSD，100出头的盒子就够用了，一定要有typec接口的。如果要买厂家完整方案的，不要选择某迪和雷某某。至于怎么选SSD看下面。&lt;/li&gt;
&lt;li&gt;SSD：一定要网购，挑质保长的，TBW除以容量大的。要品质上三星。如果是配置盒子用，盒子速度是10Gbps的，那要个大厂的便宜的就够了，最重要的是发热少。最好问清楚卖家缓外速度，缓外500M以上的是TLC，只有60到100M的肯定是QLC，在中间的说不准。貌似看不到有卖MLC的，所以只要别掉到QLC里，或者上钞能力就行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结，啥都不懂就盲选三星。如果你是想搞WTG，而且你的机器有雷电typec或USB 3.2 Gen2（红色），那么用硬盘盒+SSD，否则用U盘。&lt;/p&gt;

&lt;h2 id=&#34;商家标识的坑&#34;&gt;商家标识的坑&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;只标识读取速度，不标写入速度（大多数SD卡）：这样写入速度达不到你也没有理由要求售后，因为商家没保证写入。&lt;/li&gt;
&lt;li&gt;只标识读取和写入，不标缓外：同理，超出缓存的掉速，商家不保证其速度。商家经常在这种地方出新品的同时在降级（用更差的主控导致缓外速度更慢），以拉开商家自己其它产品的差距，避免特定型号“太香”，同时多赚钱。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其它-关于叠瓦盘srm&#34;&gt;其它：关于叠瓦盘SRM&lt;/h2&gt;

&lt;p&gt;叠瓦盘的原理这里就不介绍了，随便Google就有。叠瓦盘有着和NAND相似的特性，重叠区块写入如果规定必须按顺序来，那么就不存在写入特别慢的情况，否则就要按顺序一条一条磁道进行恢复，速度非常慢。为了克服这个问题，新式叠瓦盘是支持TRIM的，使用和SSD一样的管理算法来克服写入速度的问题，也就是说叠瓦是必然的发展趋势。也就是说，如果你看到磁盘上标示支持TRIM，那就是叠瓦盘。但如果你看到不支持TRIM的叠瓦盘，别买，买了就后悔。不过即使支持TRIM，磁盘还是不可避免地在长期使用后连续的数据变成碎片化，从而导致读写变慢，以及偶尔的GC可能会导致一段时间没有响应，外部表现为写入速度为0，会变多慢这完全依赖于主控。所以能买垂直式CRM就尽量用CRM，SRM的问题还不少。不过支持TRIM的SRM盘在系统里会怎么显示我还不清楚，我手上没这个可以测试。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;和硬件打交道，本质上就是和奸商斗智斗勇，并不是你多给钱就一定能得到应有的东西。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>折腾linux</title>
      <link>/post/20210621-ubuntu/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210621-ubuntu/</guid>
      <description>&lt;p&gt;近期在折腾linux，折腾差不多来写个总结，这货折腾了我很长的时间。由于USB3.0已经发展很久了，现在随便买的MicroSD/SD卡或U盘基本上都是USB3.0 class 10起步，所以考虑直接用这些来安装系统，这样你对哪个系统不满意直接换个U盘或SD卡就搞定了，而且测试下来速度也不慢。即使你的机器只有USB2.0接口，那也是能用的，就是启动时能感觉出来慢一些。这个也是方便咱们在校学生只有一台电脑，能方便更换系统不必每次折腾一次硬盘，同时可以熟悉比赛时所用的linux环境。另外，如果你想偷懒，我在这也准备了一些系统镜像，直接刷入U盘即可使用，请参见本文最末尾。本文主要针对LTS20版ubuntu，存在有效时限。&lt;/p&gt;

&lt;h2 id=&#34;在usb存储器上安装linux操作系统&#34;&gt;在USB存储器上安装linux操作系统&lt;/h2&gt;

&lt;p&gt;在USB设备上安装个linux系统是很容易的，比起windows和MacOS来说，容易很多。这里有两种操作方式，一是使用虚拟机，这样我们只需要准备一个U盘（或SD或MicroSD卡，下文中说的U盘通常指这三者，且容量必须是16G或以上），二是使用真实机器来安装，这样我们需要准备两个U盘，多出来的一个是用来制作安装盘，安装工具推荐 &lt;a href=&#34;https://rufus.ie/&#34; target=&#34;_blank&#34;&gt;Rufus&lt;/a&gt; 和 &lt;a href=&#34;https://www.pendrivelinux.com/yumi-multiboot-usb-creator/&#34; target=&#34;_blank&#34;&gt;YUMI&lt;/a&gt; 以及 &lt;a href=&#34;www.ventoy.net&#34; target=&#34;_blank&#34;&gt;Ventoy&lt;/a&gt;，后两者可以用于制作多启动的U盘。&lt;/p&gt;

&lt;p&gt;然后，我们要对目标U盘进行分区，可以用DiskGenius或linux上的分区工具GParted。首先要创建MBR分区表或GPT分区表（如果是GParted，要注意建立分区表的时候并没有MBR，而是显示为msdos），如果你的机器支持UEFI启动就可以用GPT，如果要简单好操作就MBR。MBR的话很简单，直接划分一个swap区，一个ext4即可。如果你同时需要它当U盘用，那多分第一个区分为fat32。而如果是GPT那就要多分1个100M的fat32，并且标记为boot/esp。这样U盘就准备好了。之所以要先分区，是因为安装程序的分区工具有可能无法做更细致的操作。GPT的稍微复杂些，来直接看我的GPT分区结果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/ubuntu/u_p.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后一个分区需要视发行版本来决定保留多大，有的没有要求，有的需要8M，那个分区设置&lt;code&gt;bios_grub&lt;/code&gt;标记，用于兼容传统Bios启动。如果使用虚拟机，则直接使用iso光盘启动，真实机器用U盘启动，启动后的安装步骤是几乎一样的。另外还有一点要注意的是，如果U盘分区总是出错，或后面安装系统总是出错，且这个盘的牌子是Kingston或SanDisk，那你很可能手上的是扩容盘或假货（我会说我被假货坑过么），要确认是不是扩容盘，一个简单点的方法是把盘用&lt;code&gt;Gparted&lt;/code&gt;创建gpt分区表，然后随便分个区，然后重新插入并刷新，如果Gparted会报错，那很可能是扩容盘。&lt;/p&gt;

&lt;p&gt;如果你用虚拟机来安装，那么请确认你的虚拟机是不是设置为EFI模式启动，必须以这个模式启动安装，才支持UEFI。启动ubuntu安装程序后，为了安装速度快一点，不要更新，需要更新的话可以安装好后操作。安装好后，它提示要重启，这里不要重启，继续执行以下命令来制作Bios启动（假如系统安装在sdb3，如果不是，要自行修改）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/sdb3 /mnt
sudo grub-install --target=i386-pc --recheck --boot-directory=/mnt/boot /dev/sdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，分区结果如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/ubuntu/u_part.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上安装方法不限于ubuntu，虽然基于ubuntu的成功率最高，但其它版本也有不少可以。有的发行版会要求你手动把那个100M标记为boot的分区，手动挂载到&lt;code&gt;/boot/efi&lt;/code&gt;，否则会导致安装失败。另外要注意一个情况，有的时候安装后那个U盘/SD卡启动失败或安装失败，这个时候要更换U盘或读卡器再次尝试，因为扩容U盘/黑片和部分差的读卡器确实会导致这种问题。另外如果系统支持btrfs文件系统，也建议格式化为btrfs文件系统，对U盘会更友好。&lt;/p&gt;

&lt;h2 id=&#34;基本软件的安装&#34;&gt;基本软件的安装&lt;/h2&gt;

&lt;h3 id=&#34;chromium&#34;&gt;Chromium&lt;/h3&gt;

&lt;p&gt;这里不提Firefox是因为它不存在Chromium的问题。安装它不难，在软件包找到它直接安装就是，关键问题是需要设置代理来访问扩展商店，解决方法是在命令行执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chromium --proxy-server=&amp;quot;socks5://127.0.0.1:1080&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chromium --proxy-server=&amp;quot;http://127.0.0.1:8080&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有了这个，就可以安装代理插件，之后的事情就容易多了。有相当的软件都有类似的命令行代理设置，通常Google一下即有答案。&lt;/p&gt;

&lt;h3 id=&#34;输入法&#34;&gt;输入法&lt;/h3&gt;

&lt;p&gt;如果你一开始选择的语言就是中文来安装，那么通常会给你自动安装好中文输入法，否则你要手动做以下步骤&lt;/p&gt;

&lt;p&gt;如果输入法进程没有默认启动，那么需要编辑&lt;code&gt;.bashrc&lt;/code&gt;，如果是ibus则添加以下内容到最末尾&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GTK_IM_MODULE=ibus 
export QT_IM_MODULE=ibus 
export XMODIFIERS=@im=ibus 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果还不行，那么还需要添加以下内容到&lt;code&gt;/etc/profile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export GTK_IM_MODULE=ibus 
export QT_IM_MODULE=ibus 
export XMODIFIERS=@im=ibus 
ibus-daemon -drx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不管你使用iBus还是fcitx，都可以安装Rime，安装好后，如果是ibus，就创建并编辑 &lt;code&gt;~/.config/ibus/rime/default.custom.yaml&lt;/code&gt;，内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patch:
    schema_list:
        - schema: luna_pinyin
        - schema: wubi86
        - schema: wubi_pinyin
        - schema: double_pinyin

    &amp;quot;ascii_composer/switch_key/Shift_L&amp;quot;: commit_code
    &amp;quot;ascii_composer/switch_key/Shift_R&amp;quot;: commit_code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;schema_list&lt;/code&gt;就是输入法列表，依次为拼音，五笔，五笔拼音，自然码双拼。另外还需要安装对应的输入法码表&lt;/p&gt;

&lt;p&gt;五笔：
&lt;code&gt;sudo apt install librime-data-wubi&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;双拼：
&lt;code&gt;sudo apt install librime-data-double-pinyin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;更多的输入法可以在包管理器上查找。但默认xubuntu似乎没有安装这样的包管理器，但你可以搜索 Muon 软件包管理器安装，安装后就可以轻松查询到rime相关的输入法码表了。&lt;/p&gt;

&lt;p&gt;以上操作完成后，需要点击输入法的图标，点【部署】，成功后便可用&lt;code&gt;win+space&lt;/code&gt;或&lt;code&gt;ctrl+space&lt;/code&gt;在不同输入法之间切换，&lt;code&gt;ctrl+~&lt;/code&gt;用在rime里面切换不同码表或选项（半角全角简体繁体等）&lt;/p&gt;

&lt;p&gt;另外还有一种比较快捷的输入法方法，先安装Chromium，然后安装 Google Input 扩展，选择你要用的输入法即可在网页里输入，适用于做测试需要临时输入的情况。&lt;/p&gt;

&lt;h3 id=&#34;exfat文件格式支持&#34;&gt;exfat文件格式支持&lt;/h3&gt;

&lt;p&gt;默认是不支持的，但大容量的卡必然用到，所以肯定要安装一把&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt install exfat-utils&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外如果需要支持这个分区的分区软件，可以安装&lt;code&gt;KDE Partition Manager&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;rdp远程桌面或ssh-sftp&#34;&gt;RDP远程桌面或SSH/SFTP&lt;/h3&gt;

&lt;p&gt;安装Remmina即可，支持剪贴板复制文本和图片，但不支持剪贴板复制文件，且通过共享目录的方式传送文件在通常情况下非常慢（需要手动把连接质量设置为best），而且容易掉线。如果需要经常传送文件，这个功能建议使用SMB或NFS代替，速度差别巨大。&lt;/p&gt;

&lt;h3 id=&#34;音效软件-pulseeffects&#34;&gt;音效软件 PulseEffects&lt;/h3&gt;

&lt;p&gt;网上很多人说windows上有什么SRS啥的音效增强软件，而ubuntu上没有云云，其实软件包里自带的这个PulseEffects已经做得挺不错了，不过要注意的是安装好后，在设置里要勾上&lt;code&gt;Start Service at Login&lt;/code&gt;，这一步很重要。&lt;/p&gt;

&lt;p&gt;另外如果有时候重启了没有声音，多半是PulseAudio出问题了，&lt;a href=&#34;https://askubuntu.com/questions/748112/pulseaudio-process-is-not-starting&#34; target=&#34;_blank&#34;&gt;参见这个&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;刚安装好的时候，equaliser这个模块的功能通常是用不了的，需要执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt install lsp-plugins&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装&lt;code&gt;lsp-plugins&lt;/code&gt;后重启系统即可。&lt;/p&gt;

&lt;h3 id=&#34;屏幕截图&#34;&gt;屏幕截图&lt;/h3&gt;

&lt;p&gt;推荐安装Flameshot，然后在系统设置的键盘，在应用程序快捷键处，对快捷键Print的命令，修改为&lt;code&gt;/usr/bin/flameshot gui&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;windows上的字体&#34;&gt;windows上的字体&lt;/h3&gt;

&lt;p&gt;如果这个发行版有字体管理器，直接用它安装即可。但如果没有的话，那么把字体文件复制到fonts路径（如果后缀不是ttf，而是ttc的，要先改后缀），例如是&lt;code&gt;/usr/local/share/fonts&lt;/code&gt;，然后执行 &lt;code&gt;sudo fc-cache -f -v&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;系统备份&#34;&gt;系统备份&lt;/h3&gt;

&lt;p&gt;如果你的空间足够，那可以安装&lt;code&gt;timeshift&lt;/code&gt;使用。&lt;/p&gt;

&lt;h3 id=&#34;护眼红移&#34;&gt;护眼红移&lt;/h3&gt;

&lt;p&gt;有的发行版本身就支持，如果不支持时安装&lt;code&gt;redshift&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;屏保&#34;&gt;屏保&lt;/h3&gt;

&lt;p&gt;如果你实在是闲，可以安装xscreensaver，这个比windows自带的丰富得多。lubuntu版本已安装。&lt;/p&gt;

&lt;h3 id=&#34;其它坑&#34;&gt;其它坑&lt;/h3&gt;

&lt;p&gt;没事不要在home的模板文件夹里放东西，东西一多会卡得很慢。&lt;/p&gt;

&lt;h2 id=&#34;u盘或sd卡选择-深坑-且部分内容会随时间过期-所以不详细讲&#34;&gt;U盘或SD卡选择（深坑，且部分内容会随时间过期，所以不详细讲）&lt;/h2&gt;

&lt;h3 id=&#34;读写速度问题&#34;&gt;读写速度问题&lt;/h3&gt;

&lt;p&gt;这个要注意了，如果你是打算用这个卡较长时间玩，那么在选择上就要注意一点了，首先一盘的U盘或SD卡并没有提供4K小文件（不是4K视频，是指大小在4K以内的小文件）的读写速度，而是视频录制速度，而4K小文件的读写速度直接影响你的体验。但是这个由于没有标注，你只可以通过评测论坛来提供的测试数据来做参考。我就遇到过大文件写入没啥问题，但4K小文件奇慢的tf卡（没错，就是Kingston，不知道是不是假货，手上N个全部一个德行）。当然，这个和你直接上SSD的速度完全不能比，但替代老机械硬盘已经没有什么问题，所以如果你有一台笔记本有USB3.0接口同时不带SSD，那可以考虑上U盘。要买的话一定要容量至少是64G的，即使你只是想用来玩玩看。&lt;/p&gt;

&lt;h3 id=&#34;寿命问题&#34;&gt;寿命问题&lt;/h3&gt;

&lt;p&gt;在U盘或SD上安装这个不得不考虑的就是它的寿命。现在大多数的U盘或SD卡，都是用TLC甚至QLC，那么大概只有1000次写入。而中低端卡或U盘往往没有wear leveling即磨损均衡，导致坏得很快，但这个信息同样没有在卡上标注，那怎么办？如果你想稳定长期使用，那么建议找针对WTG设计的U盘，寿命最佳，随便折腾。其次是大牌子的中高端SD/Micro SD卡。低端卡和其它小牌子的质量真的不行，。&lt;/p&gt;

&lt;h3 id=&#34;读卡器的问题&#34;&gt;读卡器的问题&lt;/h3&gt;

&lt;p&gt;没错，这里也是有坑的。首先，有的笔记本虽然有读卡口，但是不支持从卡启动，所以还是必须上读卡器从USB启动。有的读卡器不支持引导（别以为是你没有设置好Bios启动顺序），有的读卡器不支持32G以上的卡（有的遇到64G的卡直接报只读），有的读卡器会莫名读写错误导致写入失败或启动失败（要是确认这个读卡器会有这个问题，千万不要再用了，谁和你有仇就送给他），有的读卡器不支持虚拟机，无法用在虚拟系统里（这种读卡器特点是支持同时读两张卡的那种），有的3.0的迷你读卡器发热厉害，同时卡的位置与发热位置近，温度过高会让卡的寿命大幅度缩小甚至导致写入出错。反正总会在你想象不到的地方出坑。这里也是提醒你有时候不是卡的锅。&lt;/p&gt;

&lt;p&gt;而且，既然读卡器有坑，那么MicorSD转SD的卡套自然也可能出问题。有一些卡套是假的，也有一些牌子都没写，这类卡容易存在读写错误，以及识别率低或容易磨损接触不良等问题。&lt;/p&gt;

&lt;h3 id=&#34;推荐&#34;&gt;推荐&lt;/h3&gt;

&lt;p&gt;鉴于我试过的实在太少，这里U盘我没有可推荐的，你可以上网搜索WTG，适合WTG的U盘都很耐折腾。如果你只是要用来玩玩，那么弄SD/MicroSD卡也行。我觉得可以考虑的品牌：SAMSUNG, SanDisk。而容量最好是128G及以上，SD卡的话速度建议选择标注U3，V30，A1或以上。&lt;/p&gt;

&lt;h3 id=&#34;对于非linux系统&#34;&gt;对于非linux系统&lt;/h3&gt;

&lt;p&gt;对于windows，那要求就高得多了，不要想着用SD卡，如果用普通的U盘，那是卡得你根本不想用（但同样的U盘安装linux跑跑还是过得去的），我也还没有足够的资源去尝试高端产品（主要是穷），所以这里略过。至于MacOS我还没有资源来测试。
。&lt;/p&gt;

&lt;h2 id=&#34;快速部署镜像&#34;&gt;快速部署镜像&lt;/h2&gt;

&lt;p&gt;我放在了&lt;a href=&#34;https://github.com/Baobaobear/linux_image/releases&#34; target=&#34;_blank&#34;&gt;这个github页面&lt;/a&gt;，你可以把压缩包下载后，直接写入U盘，然后做扩大分区的操作，就可以使用了。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;折腾linux你要准备好重装5次以上的打算，这就是一个踩坑的过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>大整数高精度计算——有趣的实现</title>
      <link>/post/20210305-bigint_fun/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210305-bigint_fun/</guid>
      <description>&lt;p&gt;这里收录一些有意思的实现，不过我都有进行改编以更方便使用，不过千万不要指望这性能有多高。收录的条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持四则运算，必须包含除法及求余&lt;/li&gt;
&lt;li&gt;支持字符串输入输出&lt;/li&gt;
&lt;li&gt;代码不长&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;small-biginteger-library-for-contest&#34;&gt;small biginteger library for contest&lt;/h2&gt;

&lt;p&gt;代码原作者Jane Alam Jan，你可以在Google上直接搜索&lt;code&gt;small_biginteger_library_for_contest.pdf&lt;/code&gt;并下载到原始说明文档及代码，这里提供一份代码，改动不多，增加了int的构造函数和其它不等号的重载，乘法效率有优化，且增加输出到string而不直接输出终端，以便在其它场合使用更方便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Bigint {
    // representations and structures
    std::string a; // to store the digits
    int sign;      // sign = -1 for negative numbers, sign = 1 otherwise
    // constructors
    Bigint() {}                            // default constructor
    Bigint(std::string b) { (*this) = b; } // constructor for string
    Bigint(int v) {
        char buf[30];
        sprintf(buf, &amp;quot;%d&amp;quot;, v);
        (*this) = buf;
    }
    // some helpful methods
    int size() { return a.size(); } // returns number of digits
    Bigint inverseSign() {
        sign *= -1;
        return (*this);
    }
    Bigint normalize(int newSign) { // removes leading 0, fixes sign
        for (int i = a.size() - 1; i &amp;gt; 0 &amp;amp;&amp;amp; a[i] == &#39;0&#39;; i--)
            a.erase(a.begin() + i);
        sign = (a.size() == 1 &amp;amp;&amp;amp; a[0] == &#39;0&#39;) ? 1 : newSign;
        return (*this);
    }
    // assignment operator
    void operator=(std::string b) { // assigns a string to Bigint
        a = b[0] == &#39;-&#39; ? b.substr(1) : b;
        reverse(a.begin(), a.end());
        this-&amp;gt;normalize(b[0] == &#39;-&#39; ? -1 : 1);
    }
    // conditional operators
    bool operator&amp;lt;(const Bigint &amp;amp;b) const { // less than operator
        if (sign != b.sign) return sign &amp;lt; b.sign;
        if (a.size() != b.a.size()) return sign == 1 ? a.size() &amp;lt; b.a.size() : a.size() &amp;gt; b.a.size();
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            if (a[i] != b.a[i]) return sign == 1 ? a[i] &amp;lt; b.a[i] : a[i] &amp;gt; b.a[i];
        return false;
    }
    bool operator==(const Bigint &amp;amp;b) const { return a == b.a &amp;amp;&amp;amp; sign == b.sign; }
    // mathematical operators
    Bigint operator+(Bigint b) { // addition operator overloading
        if (sign != b.sign) return (*this) - b.inverseSign();
        Bigint c;
        for (int i = 0, carry = 0; i &amp;lt; a.size() || i &amp;lt; b.size() || carry; i++) {
            carry += (i &amp;lt; a.size() ? a[i] - 48 : 0) + (i &amp;lt; b.a.size() ? b.a[i] - 48 : 0);
            c.a += (carry % 10 + 48);
            carry /= 10;
        }
        return c.normalize(sign);
    }
    Bigint operator-(Bigint b) { // subtraction operator overloading
        if (sign != b.sign) return (*this) + b.inverseSign();
        int s = sign;
        sign = b.sign = 1;
        if ((*this) &amp;lt; b) return ((b - (*this)).inverseSign()).normalize(-s);
        Bigint c;
        for (int i = 0, borrow = 0; i &amp;lt; a.size(); i++) {
            borrow = a[i] - borrow - (i &amp;lt; b.size() ? b.a[i] : 48);
            c.a += borrow &amp;gt;= 0 ? borrow + 48 : borrow + 58;
            borrow = borrow &amp;gt;= 0 ? 0 : 1;
        }
        return c.normalize(s);
    }
    Bigint operator*(Bigint b) { // multiplication operator overloading
        if (b &amp;lt; *this) return b * *this;
        Bigint c(&amp;quot;0&amp;quot;);
        for (int i = 0, k = a[i] - 48; i &amp;lt; a.size(); i++, k = a[i] - 48) {
            while (k--)
                c = c + b;                // ith digit is k, so, we add k times
            b.a.insert(b.a.begin(), &#39;0&#39;); // multiplied by 10
        }
        return c.normalize(sign * b.sign);
    }
    Bigint operator/(Bigint b) { // division operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;), d;
        for (int j = 0; j &amp;lt; a.size(); j++)
            d.a += &amp;quot;0&amp;quot;;
        int dSign = sign * b.sign;
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b, d.a[i]++;
        }
        return d.normalize(dSign);
    }
    Bigint operator%(Bigint b) { // modulo operator overloading
        if (b.size() == 1 &amp;amp;&amp;amp; b.a[0] == &#39;0&#39;) b.a[0] /= (b.a[0] - 48);
        Bigint c(&amp;quot;0&amp;quot;);
        b.sign = 1;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--) {
            c.a.insert(c.a.begin(), &#39;0&#39;);
            c = c + a.substr(i, 1);
            while (!(c &amp;lt; b))
                c = c - b;
        }
        return c.normalize(sign);
    }
    std::string to_str() const {
        std::string s;
        if (sign == -1) s += &#39;-&#39;;
        for (int i = a.size() - 1; i &amp;gt;= 0; i--)
            s += a[i];
        return s;
    }
    bool operator&amp;gt;(const Bigint &amp;amp;b) const { return b &amp;lt; *this; }
    bool operator&amp;lt;=(const Bigint &amp;amp;b) const { return !(b &amp;lt; *this); }
    bool operator&amp;gt;=(const Bigint &amp;amp;b) const { return !(*this &amp;lt; b); }
    bool operator!=(const Bigint &amp;amp;b) const { return !(*this == b); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现使用string来实现大整数，于是缺点就非常明显了，就是性能低下，求个2000阶乘用时0.7秒，2000位的除法平均用时0.2秒（在mingw下开O2），但对于商全是9的情况下用时0.5秒。不过，这代码里有不少写法是牺牲性能换代码长度，有的思路确实也不错。在同样代码长度级别下，我实现的&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger/blob/main/bigint_tiny.h&#34; target=&#34;_blank&#34;&gt;BigIntTiny&lt;/a&gt;有着好得多的性能（2000阶乘用时0.03秒，2000位的除法0.02秒）。&lt;/p&gt;

&lt;h2 id=&#34;一份70行不到的大整数实现&#34;&gt;一份70行不到的大整数实现&lt;/h2&gt;

&lt;p&gt;改编自&lt;a href=&#34;https://wu-kan.cn/_posts/2019-01-26-%E9%AB%98%E7%B2%BE%E5%BA%A6/&#34; target=&#34;_blank&#34;&gt;wu-kan&lt;/a&gt;以及&lt;a href=&#34;https://zhuanlan.zhihu.com/p/72730434&#34; target=&#34;_blank&#34;&gt;hqztrue&lt;/a&gt;的基于bitset实现的定长大整数（对定长长度除以3.322就可得到对应的最大10进制位数），支持10进制输入输出，四则运算及位运算均支持。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;string&amp;gt;

#define BINT_MAXSIZE (1&amp;lt;&amp;lt;15)
typedef typename std::bitset&amp;lt;BINT_MAXSIZE&amp;gt; Bint;
bool operator&amp;lt;(const Bint &amp;amp;a, const Bint &amp;amp;b) {
    for (int i = a.size() - 1; i &amp;gt;= 0; --i)
        if (a[i] != b[i]) return a[i] &amp;lt; b[i];
    return false;
}
bool operator&amp;gt;(const Bint &amp;amp;a, const Bint &amp;amp;b) { return b &amp;lt; a; }
bool operator&amp;lt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(b &amp;lt; a); }
bool operator&amp;gt;=(const Bint &amp;amp;a, const Bint &amp;amp;b) { return !(a &amp;lt; b); }
Bint operator+(Bint a, Bint b) {
    while (b.any()) {
        Bint c = (a &amp;amp; b) &amp;lt;&amp;lt; 1;
        a ^= b, b = c;
    }
    return a;
}
Bint operator-(const Bint &amp;amp;a) { return Bint(1) + ~a; }
Bint operator-(Bint a, Bint b) {
    while (b.any()) {
        Bint c = (~a &amp;amp; b) &amp;lt;&amp;lt; 1;
        a ^= b, b = c;
    }
    return a;
}
Bint operator*(Bint a, Bint b) {
    if (a &amp;lt; b) return b * a;
    Bint r(0);
    for (; b.any(); b &amp;gt;&amp;gt;= 1, a &amp;lt;&amp;lt;= 1) if (b[0]) r = r + a;
    return r;
}
std::pair&amp;lt;Bint, Bint&amp;gt; divide(Bint a, const Bint &amp;amp;b) {
    Bint c = 0;
    int i = 0;
    while (b &amp;lt;&amp;lt; (i + 1) &amp;lt;= a) ++i;
    for (; i &amp;gt;= 0; --i)
        if (a &amp;gt;= (b &amp;lt;&amp;lt; i)) a = a - (b &amp;lt;&amp;lt; i), c.set(i, 1);
    return std::make_pair(c, a);
}
Bint operator/(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).first; }
Bint operator%(const Bint &amp;amp;a, const Bint &amp;amp;b) { return divide(a, b).second; }
Bint BintFromStr(const char *p) {
    Bint x = 0;
    int sign = 1;
    for (; *p == &#39;-&#39;; ++p) sign = -sign;
    for (; *p &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; *p &amp;lt;= &#39;9&#39;; ++p) x = (x &amp;lt;&amp;lt; 3) + (x &amp;lt;&amp;lt; 1) + (*p - &#39;0&#39;);
    return sign &amp;gt; 0 ? x : -x;
}
Bint BintFromInt(int i) {
    char buf[20];
    sprintf(buf, &amp;quot;%d&amp;quot;, i);
    return BintFromStr(buf);
}
std::string BintToStr(Bint x) {
    std::string out = x == 0 ? &amp;quot;0&amp;quot; : &amp;quot;&amp;quot;;
    std::vector&amp;lt;Bint&amp;gt; v;
    if (x[x.size() - 1]) out += &#39;-&#39;, x = -x;
    for (Bint y = 1; y &amp;lt;= x; y = (y &amp;lt;&amp;lt; 3) + (y &amp;lt;&amp;lt; 1)) v.push_back(y);
    for (int i = v.size() - 1; i &amp;gt;= 0; --i) {
        int t = 0;
        for (int l = 3; l &amp;gt;= 0; --l)
            if (x &amp;gt;= (v[i] &amp;lt;&amp;lt; l)) x = x - (v[i] &amp;lt;&amp;lt; l), t += 1 &amp;lt;&amp;lt; l;
        out += t + &#39;0&#39;;
    }
    return out;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现的代码就短到极致了（原始代码更短，但为了解决较长长度时的递归溢出只好多写几行），但性能同样也挺糟糕的，而且负数支持不佳（做除法会出错，需要自己转为正数做除法，或者可以自己写个类封装一下来解决这个问题），还有一个缺点是受bitset所限只能定长，但部分运算性能上比上一份略好，例如说设置长度为&lt;code&gt;1&amp;lt;&amp;lt;15&lt;/code&gt;，求2000阶乘用时0.4秒，但2000位除法用时0.7秒。但对于长度较短的时候不失为一个简易实现。所以这个适用于临时用用的大整数，对于只有加法和乘法运算时会更优于前一个。&lt;/p&gt;

&lt;h2 id=&#34;其它的github库实现&#34;&gt;其它的Github库实现&lt;/h2&gt;

&lt;p&gt;以下是我在Github找到的平均性能表现较好的一些小型实现，已经按平均性能进行排序（优先按1万位以内的乘法和除法运算性能进行排序&lt;del&gt;，才没有打广告&lt;/del&gt;）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Baobaobear/MiniBigInteger&#34; target=&#34;_blank&#34;&gt;Baobaobear/MiniBigInteger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kedixa/klibcpp&#34; target=&#34;_blank&#34;&gt;kedixa/klibcpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ron4fun/BigIntegerCPP&#34; target=&#34;_blank&#34;&gt;ron4fun/BigIntegerCPP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/square1001/bigint-library&#34; target=&#34;_blank&#34;&gt;square1001/bigint-library&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个只能在x64平台且只能用支持AT&amp;amp;T内联汇编编译器(如GCC/clang)的实现 &lt;a href=&#34;https://github.com/calebsander/bigint&#34; target=&#34;_blank&#34;&gt;calebsander/bigint&lt;/a&gt;，它的加减法和小规模乘法速度确实飞快，比前面列举到的都快，但受编译环境限制较大。&lt;/p&gt;

&lt;h2 id=&#34;备注&#34;&gt;备注&lt;/h2&gt;

&lt;p&gt;以上两份代码于2021/06/22有修改，优化了乘法效率，解决递归溢出，同时更新测试结果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>很头疼拼图</title>
      <link>/post/20210118-htt/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210118-htt/</guid>
      <description>&lt;p&gt;本拼图难度较高，是给程序解答专用的题目（手工解我觉得没多少可能，但不排除有运气极佳的人），是检验你的程序效率有多高用的。&lt;/p&gt;

&lt;p&gt;它的名字是很头疼拼图，因为放入的块有H和两种T形状，而HTT就是很头疼。一共有21个块，放入一个12x12的框里，具体形状如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/htt.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是12x12。全部21块放入即成功解出，每一块均可以任意平移、旋转、翻转。你需要确定本题有多少个本质不同的解及相应具体答案。答案就不在这公开了，祝玩得开心。&lt;/p&gt;

&lt;p&gt;其实还没完，以下还有一题加强版&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/1149.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;名字叫1149，取自每种形状的块数，全部共15块，都放入12x12的框内即可。同样的，你需要确定本题有多少个本质不同的解及相应具体答案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小恐龙拼图</title>
      <link>/post/20210101-dino/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0800</pubDate>
      <guid>/post/20210101-dino/</guid>
      <description>&lt;p&gt;本拼图难度较高，同时作为2021新年的起点！&lt;/p&gt;

&lt;p&gt;它的名字是小恐龙拼图，因为需要连同右边小恐龙形状的拼图块一起放入，一共有11个块，放入一个12x12的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/dino.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是12x12。全部11块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>101010拼图</title>
      <link>/post/20201231-101010/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201231-101010/</guid>
      <description>&lt;p&gt;前两个拼图最多算热个身，难度不高，真正有点挑战的是以下这个，作为2020的纪念&lt;/p&gt;

&lt;p&gt;它的名字是101010，因为需要把10个块放入一个10x10的框里，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/101010.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上是就是原题，每个小方块长宽均为1，底板尺寸是10x10。右边的块每一块都写了x2，表示有两块完全一样的形状，全部10块放入即成功解出，每一块均可以任意平移、旋转、翻转。答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10个问号拼图</title>
      <link>/post/20201214-10question/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201214-10question/</guid>
      <description>&lt;p&gt;刷题经常搞得自己一脸问号，就想到弄一个由问号组成的拼图，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/10question.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由10块一样的形似问号组合而成，所以我命名为&lt;code&gt;10个问号&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是10x10。要求把右边的“十”无重叠放入到10个问号里，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orz14拼图</title>
      <link>/post/20201123-orz14puzzle/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201123-orz14puzzle/</guid>
      <description>&lt;p&gt;为了表达对大佬的膜拜，特设计一款拼图，由14个近似Orz形状的小块组合而成，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/orz14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为由14块一样的小块组合而成，所以我命名为&lt;code&gt;Orz14&lt;/code&gt;，同时也有Orz一直到4的含义。&lt;/p&gt;

&lt;p&gt;以上是就是原题，不同颜色来区分不同位置的小块。每个小方块长宽均为1，底板尺寸是11x11。要求把右边的绿色小块也一并无重叠放入，这一块就代表大佬，放入即成功解出，答案就不在这公开了，祝玩得开心。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解迷建模</title>
      <link>/post/20201023-puzzle/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0800</pubDate>
      <guid>/post/20201023-puzzle/</guid>
      <description>&lt;p&gt;这次来聊点简单的，也许你偶尔有机会在地摊上看到有人摆了一堆解锁玩具，这回我们通过建模来解决当中属于迷宫类型的玩具。&lt;/p&gt;

&lt;h2 id=&#34;魔金-円&#34;&gt;魔金·円&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/Cast Disk - Solved.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一图是初始状态，第二图是解开后各自的形状。为了更能理解接下来我说的，最好当然是你手上有一个一样的。&lt;/p&gt;

&lt;p&gt;但是，事实上可以存在两种不同的初始状态，其路线也略不相同，以下会做说明。&lt;/p&gt;

&lt;h3 id=&#34;编码&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;稍微操作几下，我们就会发现，它的操作很简单，它的边缘有一上一下，在中间的孔也有一左一右，即边缘的宽度小于等于中间的孔时，就可穿过一格。我们把它如下图摆放(俯视图)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这两个disks都有一个特点，有一个孔特别长，这两个孔交错时为初始位置。我们把这个特殊的孔编号为0，然后这个孔中间一左一右大小不同，我们按小的为主方向，于是上图左边的disk从0号孔开始顺时针编码1到6，右边的disk从0号孔开始也是顺时针编码1到6。由于都是顺时针，我称它为同向的初始状态（还有一种是反向的）。&lt;/p&gt;

&lt;p&gt;再来看，左边的disk从0孔到1孔顺时针方向的边是粗的（如下图红色圈），但右边的disk从0孔到1孔顺时针方向的边是细的（如下图蓝色圈），这也决定这两个disk是不同的，在这规定顺时针方向下粗的是disk a，细的是disk b，且a总是放左边，b放右边，如图的交错方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;观察完毕后，为了方便写成代码，我们开始对disk a进行状态描述，如下图，对孔1为例子，取它的顺时针方向的边与它作为一组，按图上次序编码，窄的为0，宽的取1&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后按定义好的方向，进行编码，得到如下的编码表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int disk_shape[2][7][4] = {
    {
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 0},
        {1, 0, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
    },
    {
        {1, 0, 0, 1},
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {1, 0, 0, 1},
        {0, 1, 1, 0},
    },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了编码，接下来的事情就是判断哪些位置能做操作了。对于每一个位置，我们都有对&lt;code&gt;disk a&lt;/code&gt;顺时针和逆时针，对&lt;code&gt;disk b&lt;/code&gt;顺时针和逆时针共4种操作，那直接写成代码并打印，看看哪些可以即可。&lt;/p&gt;

&lt;h3 id=&#34;具体代码&#34;&gt;具体代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int st_map[7][7][4];

void genmap()
{
    int disk_shape[2][7][4] = {
        {
            {1, 0, 1, 0},
            {0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 1},
        },
        {
            {1, 0, 0, 1},
            {0, 1, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 0, 0},
            {0, 0, 1, 0},
            {1, 0, 0, 1},
            {0, 1, 1, 0},
        },
    };
    for (int dl = 0; dl &amp;lt; 7; ++dl)
    {
        for (int dr = 0; dr &amp;lt; 7; ++dr)
        {
            char s[5] = &amp;quot;    &amp;quot;;
            // 反向
            /*
            if (disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][0])
               s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][2])
               s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][3] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][2])
               s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            // 同向
            //*
            if (disk_shape[0][(dl + 0) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 0) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[0] = &#39;D&#39;, st_map[dl][dr][0] = 1;
            if (disk_shape[0][(dl + 6) % 7][3] &amp;lt;= disk_shape[1][dr][1] &amp;amp;&amp;amp; disk_shape[0][(dl + 6) % 7][2] &amp;lt;= disk_shape[1][dr][0])
                s[1] = &#39;U&#39;, st_map[dl][dr][1] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 0) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 0) % 7][3])
                s[2] = &#39;R&#39;, st_map[dl][dr][2] = 1;
            if (disk_shape[0][dl][0] &amp;gt;= disk_shape[1][(dr + 6) % 7][2] &amp;amp;&amp;amp; disk_shape[0][dl][1] &amp;gt;= disk_shape[1][(dr + 6) % 7][3])
                s[3] = &#39;L&#39;, st_map[dl][dr][3] = 1;
            //*/
            printf(&amp;quot;%4s,&amp;quot;, s);
        }
        puts(&amp;quot;&amp;quot;);
    }
}

int main()
{
    genmap();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是UD对应&lt;code&gt;disk a&lt;/code&gt;的操作，LR对应&lt;code&gt;disk b&lt;/code&gt;的操作&lt;/p&gt;

&lt;h3 id=&#34;结果&#34;&gt;结果&lt;/h3&gt;

&lt;p&gt;我把运行结果导入到表格并对可移动的路径进行染色，结果如下（黄色的是起点和终点状态，深绿色是最短路径）&lt;/p&gt;

&lt;h4 id=&#34;同向&#34;&gt;同向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;反向&#34;&gt;反向&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/yen_r2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来的事情就简单了，路径明显不唯一，只要按定义操作，怎么走都可以，两种方向均最短15步。&lt;/p&gt;

&lt;h2 id=&#34;魔金-磁&#34;&gt;魔金·磁&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它也是个迷宫，它有两个小环，开口处有一边有个小齿，这导致了这两个小环的路线是不一样的。&lt;/p&gt;

&lt;h3 id=&#34;编码-1&#34;&gt;编码&lt;/h3&gt;

&lt;p&gt;首先，小环横跨两个区域，那么我们对区域进行编号，且规定图上可见的面为正面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后，两个小环规定，齿在正面时，开口所占区域为十位，另一区域为个位，于是，初始状态分别是09和90（十位的0不能省略）&lt;/p&gt;

&lt;p&gt;但是这个由于比较复杂，编码的时间可能比手动列出状态还麻烦，所以我直接手动把所有的状态做成表格&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/puz/duet_s.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;表格中前两行，表示该状态可以跳转到哪些状态，第三行表示该状态距离解出还需要的步数。每一格的红色数字表示向此数字走能最快到达出口。蓝色表示向还原的方向，没有蓝色时按红色数字的方向。&lt;/p&gt;

&lt;p&gt;特殊情况是30这个状态，即第三行第0列，它移动到20或36，分别能移动到两种不同的初始状态。&lt;/p&gt;

&lt;p&gt;蓝色和橙色格子表示两条不同状态的路线，而绿色表示这两条路线的公共部分。&lt;/p&gt;

&lt;p&gt;但是，记忆这个表太难，且操作起来不是太舒服，唯一好处就是任意情况都能处理。为了快速解开或复原，我加了一个方便操作的数字串：&lt;/p&gt;

&lt;p&gt;解锁：&lt;/p&gt;

&lt;p&gt;90：6-3-52-0-3- 25-2-4-587-0-0&lt;br /&gt;
09：-8-7-5-8-6-523-0 25-2-4-587-0-0&lt;/p&gt;

&lt;p&gt;还原：&lt;/p&gt;

&lt;p&gt;90：7-4-852-5-3-20 -2-3-56-0-9&lt;br /&gt;
09：7-4-852-5-3-20 6-258-5-7-8-0-9&lt;/p&gt;

&lt;p&gt;规定初始状态是小环开口小齿在正面，减号表示小环自身转90度，数字表示移动小环其中一则到此区域。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;这种方法只能对比较规范的puzzle进行建模，我看到网上似乎没有针对这两而做的解法视频，所以我就做了一个建模版本，把路线图形化，这样比起单纯一个正解视频，你可以知道任意情况下怎么解，这个是优点。不过缺点是你得花点时间去理解它是怎么编码的。好久没更新了，所以来写点特别的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mingw 的 Bug</title>
      <link>/post/20191006-mingw-bug/</link>
      <pubDate>Sun, 06 Oct 2019 13:04:08 +0800</pubDate>
      <guid>/post/20191006-mingw-bug/</guid>
      <description>&lt;p&gt;这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。&lt;/p&gt;

&lt;p&gt;一开始我使用&lt;code&gt;std::random_shuffle&lt;/code&gt;打乱数组并用&lt;code&gt;std::sort&lt;/code&gt;排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是&lt;code&gt;std::sort&lt;/code&gt;对这种方式打乱的数据排序有点问题导致变慢。&lt;/p&gt;

&lt;p&gt;后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，&lt;code&gt;std::sort&lt;/code&gt;的时间是完全正常的，非得&lt;code&gt;std::random_shuffle&lt;/code&gt;才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向&lt;code&gt;std::random_shuffle&lt;/code&gt;，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是&lt;code&gt;arr[i] = i&lt;/code&gt;，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在&lt;a href=&#34;https://en.cppreference.com/w/cpp/algorithm/random_shuffle&#34; target=&#34;_blank&#34;&gt;cppreference&lt;/a&gt;下源代码长下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; class RandomIt &amp;gt;
void random_shuffle( RandomIt first, RandomIt last )
{
    typename std::iterator_traits&amp;lt;RandomIt&amp;gt;::difference_type i, n;
    n = last - first;
    for (i = n-1; i &amp;gt; 0; --i) {
        using std::swap;
        swap(first[i], first[std::rand() % (i+1)]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码我看着就不对，这个是生成不了我的执行结果的，于是又找到了下面这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator&amp;gt;
inline void random_shuffle(RandomAccessIterator first,
                           RandomAccessIterator last) {
  __random_shuffle(first, last, distance_type(first));
}
 
 
template &amp;lt;class RandomAccessIterator, class RandomNumberGenerator&amp;gt;
void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                    RandomNumberGenerator&amp;amp; rand) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i)
    iter_swap(i, first + rand((i - first) + 1));
}
 
 
template &amp;lt;class RandomAccessIterator, class Distance&amp;gt;
void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                      Distance*) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i) 
#ifdef __STL_NO_DRAND48
    iter_swap(i, first + Distance(rand() % ((i - first) + 1)));
#else
  iter_swap(i, first + Distance(lrand48() % ((i - first) + 1)));
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了这个代码，我瞬间明白这到底是怎么回事了，你能从中发现些什么吗？&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我发现的是，前面的代码用的是rand，而之前我发现的，是数组里前32768个数都特别大，我的直觉是这个rand函数最大值就是32767从而导致以上问题，结果一查，还真的只有mingw的rand函数的最大值这么小，也就是说如果你希望代码跨平台，使用&lt;code&gt;std::random_shuffle&lt;/code&gt;要慎重，当然最好是减少依赖。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>博客第一文，附hugo表格的坑</title>
      <link>/post/20191005-first-post/</link>
      <pubDate>Sat, 05 Oct 2019 23:12:10 +0800</pubDate>
      <guid>/post/20191005-first-post/</guid>
      <description>&lt;p&gt;第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把&lt;code&gt;\n&lt;/code&gt;自动换成&lt;code&gt;\r\n&lt;/code&gt;从而导致主题应用失败，服了。&lt;/p&gt;

&lt;p&gt;另一个坑就是hugo的表格，你不能像以下这么写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a|b|c
-|-|-
1|2|3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a  | b | c
---|---|---
1  | 2 | 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果就是这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;区别是什么呢？在表格的第二行是&lt;code&gt;---|---|---&lt;/code&gt;，这一行是用来描述对齐方式的，不过hugo的引擎要求每列至少3个字符，所以刚好3个字符时只能是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
:--
--:
:-:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中四选一，任何一个只剩下两个字符就不算是表格。&lt;/p&gt;

&lt;p&gt;本博客计划是发布我的研究成果，当然主要是算法方面，而且主要是网上不会轻易搜索到的东西。&lt;/p&gt;

&lt;p&gt;更多的东西可以关注我的 Github &lt;a href=&#34;https://github.com/Baobaobear&#34; target=&#34;_blank&#34;&gt;账号&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _CRT_SECURE_NO_WARNINGS
#include &amp;lt;stdio.h&amp;gt;
 
int g_eof;
int get_lv(char c) {
	return !(c == &#39;+&#39; || c == &#39;-&#39;);
}
 
double get_val(double v[], char op) {
	if (op == &#39;+&#39;) return v[0] + v[1];
	if (op == &#39;-&#39;) return v[0] - v[1];
	if (op == &#39;*&#39;) return v[0] * v[1];
	if (op == &#39;/&#39;) return v[0] / v[1];
	return v[0];
}
 
double calc(char* op, int level, double val, char o, int i) {
	char c[2] = { o };
	double v[2] = { val };
	if ((g_eof = scanf(&amp;quot;%lf&amp;quot;, &amp;amp;v[i])) != EOF)
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	if (c[i] == &#39;(&#39;) {
		v[i] = calc(&amp;amp;c[i], 0, 0, 0, 0);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	}
	if (i &amp;gt; 0) {
		if (!(c[i] == &#39;\n&#39; || c[i] == &#39;)&#39;
			|| get_lv(c[0]) &amp;gt;= get_lv(c[1])))
			v[i] = calc(&amp;amp;c[1], get_lv(c[1]), v[1], c[1], get_lv(c[1]) &amp;gt; 0);
		v[0] = get_val(v, c[0]);
		c[0] = c[1];
	}
	if (c[0] == &#39;\n&#39; || c[0] == &#39;)&#39; || get_lv(c[0]) &amp;lt; level) {
		*op = c[0];
		return v[0];
	}
	return calc(op, level, v[0], c[0], 1);
}
 
int main(void) {
	char op;
	while (g_eof != EOF)
		printf(&amp;quot;= %.15g\n&amp;quot;, calc(&amp;amp;op, 0, 0, &#39;\n&#39;, 0));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
