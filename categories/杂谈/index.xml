<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杂谈 | Baobaobear</title>
    <link>/categories/%E6%9D%82%E8%B0%88/</link>
      <atom:link href="/categories/%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml" />
    <description>杂谈</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 06 Oct 2019 13:04:08 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>杂谈</title>
      <link>/categories/%E6%9D%82%E8%B0%88/</link>
    </image>
    
    <item>
      <title>Mingw 的 Bug</title>
      <link>/post/20191006-mingw-bug/</link>
      <pubDate>Sun, 06 Oct 2019 13:04:08 +0800</pubDate>
      <guid>/post/20191006-mingw-bug/</guid>
      <description>&lt;p&gt;这个问题最早的时候是今年8月，我在测试排序算法的速度，发现mingw上总有点不一样，而linux下的gcc是正常的，也在群里问过人，没人明白到底怎么回事，先描述一下当时遇到的情况。&lt;/p&gt;

&lt;p&gt;一开始我使用&lt;code&gt;std::random_shuffle&lt;/code&gt;打乱数组并用&lt;code&gt;std::sort&lt;/code&gt;排序，在VS上并没有发现什么问题，gcc也正常。但在mingw上，这样打乱的数组排序所花的时间，比起其它打乱方式的，例如直接赋值一个随机数的方式，要明显慢了近1倍，这个诡异的问题一直没想通是为啥。当时觉得可能是&lt;code&gt;std::sort&lt;/code&gt;对这种方式打乱的数据排序有点问题导致变慢。&lt;/p&gt;

&lt;p&gt;后来，为了和std函数脱钩，我自己重新写了随机数函数和random_shuffle函数，结果发现我的random_shuffle函数打乱的结果，&lt;code&gt;std::sort&lt;/code&gt;的时间是完全正常的，非得&lt;code&gt;std::random_shuffle&lt;/code&gt;才会出现两倍的情况，一时间我还以为是我写的有问题，还更换了不同随机函数，怎么也发现不了原因，终于把怀疑转向&lt;code&gt;std::random_shuffle&lt;/code&gt;，我就对这个函数的执行结果输出到文件，这一输出立即把我搞懵了，输出的结果分布特别有规律，初值我用的是&lt;code&gt;arr[i] = i&lt;/code&gt;，打乱后结果前32768个数都是数组里最大的数值，一时没明白怎么回事，难道它的实现很不寻常吗？我就去翻了一下源代码，在&lt;a href=&#34;https://en.cppreference.com/w/cpp/algorithm/random_shuffle&#34; target=&#34;_blank&#34;&gt;cppreference&lt;/a&gt;下源代码长下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; class RandomIt &amp;gt;
void random_shuffle( RandomIt first, RandomIt last )
{
    typename std::iterator_traits&amp;lt;RandomIt&amp;gt;::difference_type i, n;
    n = last - first;
    for (i = n-1; i &amp;gt; 0; --i) {
        using std::swap;
        swap(first[i], first[std::rand() % (i+1)]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码我看着就不对，这个是生成不了我的执行结果的，于是又找到了下面这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class RandomAccessIterator&amp;gt;
inline void random_shuffle(RandomAccessIterator first,
                           RandomAccessIterator last) {
  __random_shuffle(first, last, distance_type(first));
}
 
 
template &amp;lt;class RandomAccessIterator, class RandomNumberGenerator&amp;gt;
void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                    RandomNumberGenerator&amp;amp; rand) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i)
    iter_swap(i, first + rand((i - first) + 1));
}
 
 
template &amp;lt;class RandomAccessIterator, class Distance&amp;gt;
void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                      Distance*) {
  if (first == last) return;
  for (RandomAccessIterator i = first + 1; i != last; ++i) 
#ifdef __STL_NO_DRAND48
    iter_swap(i, first + Distance(rand() % ((i - first) + 1)));
#else
  iter_swap(i, first + Distance(lrand48() % ((i - first) + 1)));
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了这个代码，我瞬间明白这到底是怎么回事了，你能从中发现些什么吗？&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我发现的是，前面的代码用的是rand，而之前我发现的，是数组里前32768个数都特别大，我的直觉是这个rand函数最大值就是32767从而导致以上问题，结果一查，还真的只有mingw的rand函数的最大值这么小，也就是说如果你希望代码跨平台，使用&lt;code&gt;std::random_shuffle&lt;/code&gt;要慎重，当然最好是减少依赖。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>博客第一文，附hugo表格的坑</title>
      <link>/post/20191005-first-post/</link>
      <pubDate>Sat, 05 Oct 2019 23:12:10 +0800</pubDate>
      <guid>/post/20191005-first-post/</guid>
      <description>&lt;p&gt;第一次使用这个hugo就遇到一堆坑，主题并不是随便用，会有SHA-256校验，而在windows平台下用git，clone下来会把&lt;code&gt;\n&lt;/code&gt;自动换成&lt;code&gt;\r\n&lt;/code&gt;从而导致主题应用失败，服了。&lt;/p&gt;

&lt;p&gt;另一个坑就是hugo的表格，你不能像以下这么写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a|b|c
-|-|-
1|2|3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样hugo的引擎是不认为这是表格，正确的做法是改成下面这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a  | b | c
---|---|---
1  | 2 | 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示结果就是这样&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;区别是什么呢？在表格的第二行是&lt;code&gt;---|---|---&lt;/code&gt;，这一行是用来描述对齐方式的，不过hugo的引擎要求每列至少3个字符，所以刚好3个字符时只能是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
:--
--:
:-:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中四选一，任何一个只剩下两个字符就不算是表格。&lt;/p&gt;

&lt;p&gt;本博客计划是发布我的研究成果，当然主要是算法方面，而且主要是网上不会轻易搜索到的东西。&lt;/p&gt;

&lt;p&gt;更多的东西可以关注我的 Github &lt;a href=&#34;https://github.com/Baobaobear&#34; target=&#34;_blank&#34;&gt;账号&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _CRT_SECURE_NO_WARNINGS
#include &amp;lt;stdio.h&amp;gt;
 
int g_eof;
int get_lv(char c) {
	return !(c == &#39;+&#39; || c == &#39;-&#39;);
}
 
double get_val(double v[], char op) {
	if (op == &#39;+&#39;) return v[0] + v[1];
	if (op == &#39;-&#39;) return v[0] - v[1];
	if (op == &#39;*&#39;) return v[0] * v[1];
	if (op == &#39;/&#39;) return v[0] / v[1];
	return v[0];
}
 
double calc(char* op, int level, double val, char o, int i) {
	char c[2] = { o };
	double v[2] = { val };
	if ((g_eof = scanf(&amp;quot;%lf&amp;quot;, &amp;amp;v[i])) != EOF)
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	if (c[i] == &#39;(&#39;) {
		v[i] = calc(&amp;amp;c[i], 0, 0, 0, 0);
		scanf(&amp;quot;%c&amp;quot;, &amp;amp;c[i]);
	}
	if (i &amp;gt; 0) {
		if (!(c[i] == &#39;\n&#39; || c[i] == &#39;)&#39;
			|| get_lv(c[0]) &amp;gt;= get_lv(c[1])))
			v[i] = calc(&amp;amp;c[1], get_lv(c[1]), v[1], c[1], get_lv(c[1]) &amp;gt; 0);
		v[0] = get_val(v, c[0]);
		c[0] = c[1];
	}
	if (c[0] == &#39;\n&#39; || c[0] == &#39;)&#39; || get_lv(c[0]) &amp;lt; level) {
		*op = c[0];
		return v[0];
	}
	return calc(op, level, v[0], c[0], 1);
}
 
int main(void) {
	char op;
	while (g_eof != EOF)
		printf(&amp;quot;= %.15g\n&amp;quot;, calc(&amp;amp;op, 0, 0, &#39;\n&#39;, 0));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
